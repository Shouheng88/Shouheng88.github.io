<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Android,Java,计算机网络,OkHttp,源码阅读," />





  <link rel="alternate" href="/atom.xml" title="WngShhng 的博客" type="application/atom+xml" />






<meta name="description" content="1、OkHttp 的基本使用OkHttp 是 Square 的一款应用于 Android 和 Java 的 Http 和 Http/2 客户端。使用的时候只需要在 Gradle 里面加入下面一行依赖即可引入： implementation &amp;apos;com.squareup.okhttp3:okhttp:3.11.0&amp;apos; 我们知道，Http 请求有多种类型，常用的分为 Get 和 Pos">
<meta name="keywords" content="Android,Java,计算机网络,OkHttp,源码阅读">
<meta property="og:type" content="article">
<meta property="og:title" content="Andriod 网络框架 OkHttp 源码解析">
<meta property="og:url" content="http://yoursite.com/2018/10/17/Andriod 网络框架 OkHttp 源码解析/index.html">
<meta property="og:site_name" content="WngShhng 的博客">
<meta property="og:description" content="1、OkHttp 的基本使用OkHttp 是 Square 的一款应用于 Android 和 Java 的 Http 和 Http/2 客户端。使用的时候只需要在 Gradle 里面加入下面一行依赖即可引入： implementation &amp;apos;com.squareup.okhttp3:okhttp:3.11.0&amp;apos; 我们知道，Http 请求有多种类型，常用的分为 Get 和 Pos">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/10/19/1668c58f05078818">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/10/19/1668c5c04f04eab2?w=1099&h=506&f=png&s=26593">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/10/19/1668c5c6363ea20f?w=853&h=875&f=png&s=84443">
<meta property="og:updated_time" content="2018-10-19T12:55:57.186Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Andriod 网络框架 OkHttp 源码解析">
<meta name="twitter:description" content="1、OkHttp 的基本使用OkHttp 是 Square 的一款应用于 Android 和 Java 的 Http 和 Http/2 客户端。使用的时候只需要在 Gradle 里面加入下面一行依赖即可引入： implementation &amp;apos;com.squareup.okhttp3:okhttp:3.11.0&amp;apos; 我们知道，Http 请求有多种类型，常用的分为 Get 和 Pos">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2018/10/19/1668c58f05078818">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/10/17/Andriod 网络框架 OkHttp 源码解析/"/>





  <title>Andriod 网络框架 OkHttp 源码解析 | WngShhng 的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">WngShhng 的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Focus on Java, Android & life</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/17/Andriod 网络框架 OkHttp 源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="WngShhng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WngShhng 的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Andriod 网络框架 OkHttp 源码解析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-17T20:20:23+08:00">
                2018-10-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android网络访问/" itemprop="url" rel="index">
                    <span itemprop="name">Android网络访问</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="1、OkHttp-的基本使用"><a href="#1、OkHttp-的基本使用" class="headerlink" title="1、OkHttp 的基本使用"></a>1、OkHttp 的基本使用</h2><p>OkHttp 是 Square 的一款应用于 Android 和 Java 的 Http 和 Http/2 客户端。使用的时候只需要在 Gradle 里面加入下面一行依赖即可引入：</p>
<pre><code>implementation &apos;com.squareup.okhttp3:okhttp:3.11.0&apos;
</code></pre><p>我们知道，Http 请求有多种类型，常用的分为 Get 和 Post，而 POST 又分为 Form 和 Multiple 等。下面我们以 Form 类型的请求为例来看下 OkHttp 的 API 设计逻辑：</p>
<pre><code>OkHttpClient internalHttpClient = new OkHttpClient();
FormBody.Builder formBodyBuilder = new FormBody.Builder();
RequestBody body = formBodyBuilder.build();
Request.Builder builder = new Request.Builder().url(&quot;host:port/url&quot;).post(body);
Request request = builder.build();
Response response = internalHttpClient.newCall(request).execute();
String retJson = response.body().string();
</code></pre><p>这里我们先用了 <code>FormBody</code> 的构建者模式创建 Form 类型请求的请求体，然后使用 <code>Request</code> 的构建者创建完整的 Form 请求。之后，我们用创建好的 OkHttp 客户端 <code>internalHttpClient</code> 来获取一个请求，并从请求的请求体中获取 Json 数据。</p>
<p>根据 OkHttp 的 API，如果我们希望发送一个 Multipart 类型的请求的时候就需要使用 <code>MultipartBody</code> 的构建者创建 Multipart 请求的请求体。然后同样使用 <code>Request</code> 的构建者创建完整的 Multipart 请求，剩下的逻辑相同。</p>
<p>除了使用上面的直接实例化一个 OkHttp 客户端的方式，我们也可以使用 <code>OkHttpClient</code> 的构建者 <code>OkHttpClient.Builder</code> 来创建 OkHttp 客户端。</p>
<p>所以，我们可以总结：</p>
<ol>
<li>OkHttp 为不同的请求类型都提供了一个构建者方法用来创建请求体 <code>RequestBody</code>；</li>
<li>因为请求体只是整个请求的一部分，所以，又要用 <code>Request.Builder</code> 构建一个请求对象 <code>Request</code>；</li>
<li>这样我们得到了一个完整的 Http 请求，然后使用 <code>OkHttpClient</code> 对象进行网络访问得到响应对象 <code>Response</code>。</li>
</ol>
<p>OkHttp 本身的设计比较友好，思路非常清晰，按照上面的思路搞懂了人家的 API 设计逻辑，自己再基于 OkHttp 封装一个库自然问题不大。</p>
<h2 id="2、OkHttp-源码分析"><a href="#2、OkHttp-源码分析" class="headerlink" title="2、OkHttp 源码分析"></a>2、OkHttp 源码分析</h2><p>上面我们提到的一些是基础的 API 类，是提供给用户使用的。这些类的设计只是基于构建者模式，非常容易理解。这里我们关注点也不在这些 API 类上面，而是 OkHttp 内部的请求执行相关的类。下面我们就开始对 OkHttp 的请求过程进行源码分析（源码版本：3.10.0）。</p>
<h3 id="2-1-一个请求的大致流程"><a href="#2-1-一个请求的大致流程" class="headerlink" title="2.1 一个请求的大致流程"></a>2.1 一个请求的大致流程</h3><p>参考之前的示例程序，抛弃构建请求的过程不讲，单从请求的发送过程来看，我们的线索应该从 <code>OkHttpClient.newCall(Request)</code> 开始。下面是这个方法的定义，它会创建一个 <code>RealCall</code> 对象，并把 <code>OkHttpClient</code> 对象和 <code>Request</code> 对象作为参数传入进去：</p>
<pre><code>@Override public Call newCall(Request request) {
    return RealCall.newRealCall(this, request, false /* for web socket */);
}
</code></pre><p>然后，RealCall 调用内部的静态方法 <code>newRealCall</code> 在其中创建一个 <code>RealCall</code> 实例并将其返回：</p>
<pre><code>static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
    RealCall call = new RealCall(client, originalRequest, forWebSocket);
    call.eventListener = client.eventListenerFactory().create(call);
    return call;
}
</code></pre><p>然后，当返回了 <code>RealCall</code> 之后，我们又会调用它的 <code>execute()</code> 方法来获取响应结果，下面是这个方法的定义：</p>
<pre><code>@Override public Response execute() throws IOException {
    synchronized (this) {
        if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);
        executed = true;
    }
    captureCallStackTrace();
    eventListener.callStart(this);
    try {
        // 加入到一个双端队列中
        client.dispatcher().executed(this);
        // 从这里拿的响应Response
        Response result = getResponseWithInterceptorChain();
        if (result == null) throw new IOException(&quot;Canceled&quot;);
        return result;
    } catch (IOException e) {
        eventListener.callFailed(this, e);
        throw e;
    } finally {
        client.dispatcher().finished(this);
    }
}
</code></pre><p>这里我们会用 <code>client</code> 对象（实际也就是上面创建 <code>RealCall</code> 的时候传入的 <code>OkHttpClient</code>）的 <code>dispatcher()</code> 方法来获取一个 <code>Dispatcher</code> 对象，并调用它的 <code>executed()</code> 方法来将当前的 <code>RealCall</code> 加入到一个双端队列中，下面是 <code>executed(RealCall)</code> 方法的定义，这里的 <code>runningSyncCalls</code> 的类型是 <code>Deque&lt;RealCall&gt;</code>：</p>
<pre><code>synchronized void executed(RealCall call) {
    runningSyncCalls.add(call);
}
</code></pre><p>让我们回到上面的 <code>execute()</code>  方法，在把 <code>RealCall</code> 加入到双端队列之后，我们又调用了 <code>getResponseWithInterceptorChain()</code> 方法，下面就是该方法的定义。</p>
<pre><code>Response getResponseWithInterceptorChain() throws IOException {
    // 添加一系列拦截器，注意添加的顺序
    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();
    interceptors.addAll(client.interceptors());
    interceptors.add(retryAndFollowUpInterceptor);
    // 桥拦截器
    interceptors.add(new BridgeInterceptor(client.cookieJar()));
    // 缓存拦截器：从缓存中拿数据
    interceptors.add(new CacheInterceptor(client.internalCache()));
    // 网络连接拦截器：建立网络连接
    interceptors.add(new ConnectInterceptor(client));
    if (!forWebSocket) {
        interceptors.addAll(client.networkInterceptors());
    }
    // 服务器请求拦截器：向服务器发起请求获取数据
    interceptors.add(new CallServerInterceptor(forWebSocket));
    // 构建一条责任链
    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
        originalRequest, this, eventListener, client.connectTimeoutMillis(),
        client.readTimeoutMillis(), client.writeTimeoutMillis());
    // 处理责任链
    return chain.proceed(originalRequest);
}
</code></pre><p>这里，我们创建了一个列表对象之后把 <code>client</code> 中的拦截器、重连拦截器、桥拦截器、缓存拦截器、网络连接拦截器和服务器请求拦截器等<strong>依次</strong>加入到列表中。然后，我们用这个列表创建了一个拦截器链。这里使用了责任链设计模式，每当一个拦截器执行完毕之后会调用下一个拦截器或者不调用并返回结果。显然，我们最终拿到的响应就是这个链条执行之后返回的结果。当我们自定义一个拦截器的时候，也会被加入到这个拦截器链条里。</p>
<p>这里我们遇到了很多的新类，比如 <code>RealCall</code>、<code>Dispatcher</code> 以及责任链等。下文中，我们会对这些类之间的关系以及责任链中的环节做一个分析，而这里我们先对整个请求的流程做一个大致的梳理。下面是这个过程大致的时序图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/19/1668c58f05078818" alt="OkHttp请求时序图"></p>
<h3 id="2-2-分发器-Dispatcher"><a href="#2-2-分发器-Dispatcher" class="headerlink" title="2.2 分发器 Dispatcher"></a>2.2 分发器 Dispatcher</h3><p>上面我们提到了 <code>Dispatcher</code> 这个类，它的作用是对请求进行分发。以最开始的示例代码为例，在使用 OkHttp 的时候，我们会创建一个 <code>RealCall</code> 并将其加入到双端队列中。但是请注意这里的双端队列的名称是 <code>runningSyncCalls</code>，也就是说这种请求是同步请求，会在当前的线程中立即被执行。所以，下面的 <code>getResponseWithInterceptorChain()</code> 就是这个同步的执行过程。而当我们执行完毕的时候，又会调用 <code>Dispatcher</code> 的 <code>finished(RealCall)</code> 方法把该请求从队列中移除。所以，这种同步的请求无法体现分发器的“分发”功能。</p>
<p>除了同步的请求，还有异步类型的请求：当我们拿到了 <code>RealCall</code> 的时候，调用它的 <code>enqueue(Callback responseCallback)</code> 方法并设置一个回调即可。该方法会执行下面这行代码：</p>
<pre><code>client.dispatcher().enqueue(new AsyncCall(responseCallback));
</code></pre><p>即使用上面的回调创建一个  <code>AsyncCall</code> 并调用  <code>enqueue(AsyncCall)</code>。这里的 <code>AsyncCall</code> 间接继承自 <code>Runnable</code>，是一个可执行的对象，并且会在 <code>Runnable</code> 的 <code>run()</code> 方法里面调用 <code>AsyncCall</code> 的 <code>execute()</code> 方法。<code>AsyncCall</code> 的 <code>execute()</code> 方法与 <code>RealCall</code> 的 <code>execute()</code> 方法类似，都使用责任链来完成一个网络请求。只是后者可以放在一个异步的线程中进行执行。</p>
<p>当我们调用了 <code>Dispatcher</code> 的 <code>enqueue(AsyncCall)</code> 方法的时候也会将 <code>AsyncCall</code> 加入到一个队列中，并会在请求执行完毕的时候从该队列中移除，只是这里的队列是 <code>runningAsyncCalls</code> 或者 <code>readyAsyncCalls</code>。它们都是一个双端队列，并用来存储异步类型的请求。它们的区别是，<code>runningAsyncCalls</code> 是正在执行的队列，当正在执行的队列达到了限制的时候，就会将其放置到就绪队列 <code>readyAsyncCalls</code> 中：</p>
<pre><code>synchronized void enqueue(AsyncCall call) {
    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {
        runningAsyncCalls.add(call);
        executorService().execute(call);
    } else {
        readyAsyncCalls.add(call);
    }
}
</code></pre><p>当把该请求加入到了正在执行的队列之后，我们会立即使用一个线程池来执行该 <code>AsyncCall</code>。这样这个请求的责任链就会在一个线程池当中被异步地执行了。这里的线程池由 <code>executorService()</code> 方法返回：</p>
<pre><code>public synchronized ExecutorService executorService() {
    if (executorService == null) {
        executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
        new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));
    }
    return executorService;
}
</code></pre><p>显然，当线程池不存在的时候会去创建一个线程池。除了上面的这种方式，我们还可以在构建 <code>OkHttpClient</code> 的时候，自定义一个 <code>Dispacher</code>，并在其构造方法中为其指定一个线程池。下面我们类比 OkHttp 的同步请求绘制了一个异步请求的时序图。你可以通过将两个图对比来了解两种实现方式的不同：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/19/1668c5c04f04eab2?w=1099&amp;h=506&amp;f=png&amp;s=26593" alt="OkHttp异步请求"></p>
<p>以上就是分发器 <code>Dispacher</code> 的逻辑，看上去并没有那么复杂。并且从上面的分析中，我们可以看出实际请求的执行过程并不是在这里完成的，这里只能决定在哪个线程当中执行请求并把请求用双端队列缓存下来，而实际的请求执行过程是在责任链中完成的。下面我们就来分析一下 OkHttp 里的责任链的执行过程。</p>
<h3 id="2-3-责任链的执行过程"><a href="#2-3-责任链的执行过程" class="headerlink" title="2.3 责任链的执行过程"></a>2.3 责任链的执行过程</h3><p>在典型的责任链设计模式里，很多对象由每一个对象对其下级的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。责任链在现实生活中的一种场景就是面试，当某轮面试官觉得你没有资格进入下一轮的时候可以否定你，不然会让下一轮的面试官继续面试。</p>
<p>在 OkHttp 里面，责任链的执行模式与之稍有不同。这里我们主要来分析一下在 OkHttp 里面，责任链是如何执行的，至于每个链条里面的具体逻辑，我们会在随后一一说明。</p>
<p>回到 2.1 的代码，有两个地方需要我们注意：</p>
<ol>
<li>是当创建一个责任链 <code>RealInterceptorChain</code> 的时候，我们传入的第 5 个参数是 0。该参数名为 <code>index</code>，会被赋值给 <code>RealInterceptorChain</code> 实例内部的同名全局变量。</li>
<li>当启用责任链的时候，会调用它的 <code>proceed(Request)</code> 方法。</li>
</ol>
<p>下面是 <code>proceed(Request)</code> 方法的定义：</p>
<pre><code>@Override public Response proceed(Request request) throws IOException {
    return proceed(request, streamAllocation, httpCodec, connection);
}
</code></pre><p>这里又调用了内部的重载的 <code>proceed()</code> 方法。下面我们对该方法进行了简化：</p>
<pre><code>public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
    RealConnection connection) throws IOException {
    if (index &gt;= interceptors.size()) throw new AssertionError();
    // ...
    // 调用责任链的下一个拦截器
    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
        writeTimeout);
    Interceptor interceptor = interceptors.get(index);
    Response response = interceptor.intercept(next);
    // ...
    return response;
}
</code></pre><p>注意到这里使用责任链进行处理的时候，会新建下一个责任链并把 <code>index+!</code> 作为下一个责任链的 <code>index</code>。然后，我们使用 <code>index</code> 从拦截器列表中取出一个拦截器，调用它的 <code>intercept()</code> 方法，并把下一个执行链作为参数传递进去。</p>
<p>这样，当下一个拦截器希望自己的下一级继续处理这个请求的时候，可以调用传入的责任链的 <code>proceed()</code> 方法；如果自己处理完毕之后，下一级不需要继续处理，那么就直接返回一个 <code>Response</code> 实例即可。因为，每次都是在当前的 <code>index</code> 基础上面加 1，所以能在调用  <code>proceed()</code> 的时候准确地从拦截器列表中取出下一个拦截器进行处理。</p>
<p>我们还要注意的地方是之前提到过重试拦截器，这种拦截器会在内部启动一个 <code>while</code> 循环，并在循环体中调用执行链的 <code>proceed()</code> 方法来实现请求的不断重试。这是因为在它那里的拦截器链的 <code>index</code> 是固定的，所以能够每次调用 <code>proceed()</code> 的时候，都能够从自己的下一级执行一遍链条。下面就是这个责任链的执行过程：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/10/19/1668c5c6363ea20f?w=853&amp;h=875&amp;f=png&amp;s=84443" alt="责任链执行过程"></p>
<p>清楚了 OkHttp 的拦截器链的执行过程之后，我们来看一下各个拦截器做了什么逻辑。</p>
<h3 id="2-3-重试和重定向：RetryAndFollowUpInterceptor"><a href="#2-3-重试和重定向：RetryAndFollowUpInterceptor" class="headerlink" title="2.3 重试和重定向：RetryAndFollowUpInterceptor"></a>2.3 重试和重定向：RetryAndFollowUpInterceptor</h3><p><code>RetryAndFollowUpInterceptor</code> 主要用来当请求失败的时候进行重试，以及在需要的情况下进行重定向。我们上面说，责任链会在进行处理的时候调用第一个拦截器的 <code>intercept()</code> 方法。如果我们在创建 OkHttp 客户端的时候没有加入自定义拦截器，那么<br><code>RetryAndFollowUpInterceptor</code> 就是我们的责任链中最先被调用的拦截器。</p>
<pre><code>@Override public Response intercept(Chain chain) throws IOException {
    // ...
    // 注意这里我们初始化了一个 StreamAllocation 并赋值给全局变量，它的作用我们后面会提到
    StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),
            createAddress(request.url()), call, eventListener, callStackTrace);
    this.streamAllocation = streamAllocation;
    // 用来记录重定向的次数
    int followUpCount = 0;
    Response priorResponse = null;
    while (true) {
        if (canceled) {
            streamAllocation.release();
            throw new IOException(&quot;Canceled&quot;);
        }

        Response response;
        boolean releaseConnection = true;
        try {
            // 这里从当前的责任链开始执行一遍责任链，是一种重试的逻辑
            response = realChain.proceed(request, streamAllocation, null, null);
            releaseConnection = false;
        } catch (RouteException e) {
            // 调用 recover 方法从失败中进行恢复，如果可以恢复就返回true，否则返回false
            if (!recover(e.getLastConnectException(), streamAllocation, false, request)) {
                throw e.getLastConnectException();
            }
            releaseConnection = false;
            continue;
        } catch (IOException e) {
            // 重试与服务器进行连接
            boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
            if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;
            releaseConnection = false;
            continue;
        } finally {
            // 如果 releaseConnection 为 true 则表明中间出现了异常，需要释放资源
            if (releaseConnection) {
                streamAllocation.streamFailed(null);
                streamAllocation.release();
            }
        }

        // 使用之前的响应 priorResponse 构建一个响应，这种响应的响应体 body 为空
        if (priorResponse != null) {
            response = response.newBuilder()
                    .priorResponse(priorResponse.newBuilder().body(null).build())
                    .build();
        }

        // 根据得到的响应进行处理，可能会增加一些认证信息、重定向或者处理超时请求
        // 如果该请求无法继续被处理或者出现的错误不需要继续处理，将会返回 null
        Request followUp = followUpRequest(response, streamAllocation.route());

        // 无法重定向，直接返回之前的响应
        if (followUp == null) {
            if (!forWebSocket) {
                streamAllocation.release();
            }
            return response;
        }

        // 关闭资源
        closeQuietly(response.body());

        // 达到了重定向的最大次数，就抛出一个异常
        if (++followUpCount &gt; MAX_FOLLOW_UPS) {
            streamAllocation.release();
            throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);
        }

        if (followUp.body() instanceof UnrepeatableRequestBody) {
            streamAllocation.release();
            throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());
        }

        // 这里判断新的请求是否能够复用之前的连接，如果无法复用，则创建一个新的连接
        if (!sameConnection(response, followUp.url())) {
            streamAllocation.release();
            streamAllocation = new StreamAllocation(client.connectionPool(),
                    createAddress(followUp.url()), call, eventListener, callStackTrace);
            this.streamAllocation = streamAllocation;
        } else if (streamAllocation.codec() != null) {
            throw new IllegalStateException(&quot;Closing the body of &quot; + response
                    + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;);
        }

        request = followUp;
        priorResponse = response;
    }
}
</code></pre><p>以上的代码主要用来根据错误的信息做一些处理，会根据服务器返回的信息判断这个请求是否可以重定向，或者是否有必要进行重试。如果值得去重试就会新建或者复用之前的连接在下一次循环中进行请求重试，否则就将得到的请求包装之后返回给用户。这里，我们提到了 <code>StreamAllocation</code> 对象，它相当于一个管理类，维护了服务器连接、并发流和请求之间的关系，该类还会初始化一个 <code>Socket</code> 连接对象，获取输入/输出流对象。同时，还要注意这里我们通过 <code>client.connectionPool()</code> 传入了一个连接池对象 <code>ConnectionPool</code>。这里我们只是初始化了这些类，但实际在当前的方法中并没有真正用到这些类，而是把它们传递到下面的拦截器里来从服务器中获取请求的响应。稍后，我们会说明这些类的用途，以及之间的关系。</p>
<h3 id="2-4-BridgeInterceptor"><a href="#2-4-BridgeInterceptor" class="headerlink" title="2.4 BridgeInterceptor"></a>2.4 BridgeInterceptor</h3><p>桥拦截器 <code>BridgeInterceptor</code> 用于从用户的请求中构建网络请求，然后使用该请求访问网络，最后从网络响应当中构建用户响应。相对来说这个拦截器的逻辑比较简单，只是用来对请求进行包装，并将服务器响应转换成用户友好的响应：</p>
<pre><code>public final class BridgeInterceptor implements Interceptor {
    @Override public Response intercept(Chain chain) throws IOException {
        Request userRequest = chain.request();
        // 从用户请求中获取网络请求构建者
        Request.Builder requestBuilder = userRequest.newBuilder();
        // ...
        // 执行网络请求
        Response networkResponse = chain.proceed(requestBuilder.build());
        // ...
        // 从网络响应中获取用户响应构建者
        Response.Builder responseBuilder = networkResponse.newBuilder().request(userRequest);
        // ...
        // 返回用户响应
        return responseBuilder.build();
    }
}
</code></pre><h3 id="2-5-使用缓存：CacheInterceptor"><a href="#2-5-使用缓存：CacheInterceptor" class="headerlink" title="2.5 使用缓存：CacheInterceptor"></a>2.5 使用缓存：CacheInterceptor</h3><p>缓存拦截器会根据请求的信息和缓存的响应的信息来判断是否存在缓存可用，如果有可以使用的缓存，那么就返回该缓存该用户，否则就继续责任链来从服务器中获取响应。当获取到响应的时候，又会把响应缓存到磁盘上面。以下是这部分的逻辑：</p>
<pre><code>public final class CacheInterceptor implements Interceptor {
    @Override public Response intercept(Chain chain) throws IOException {
        Response cacheCandidate = cache != null ? cache.get(chain.request()) : null;
        long now = System.currentTimeMillis();
        // 根据请求和缓存的响应中的信息来判断是否存在缓存可用
        CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();
        Request networkRequest = strategy.networkRequest; // 如果该请求没有使用网络就为空
        Response cacheResponse = strategy.cacheResponse; // 如果该请求没有使用缓存就为空
        if (cache != null) {
            cache.trackResponse(strategy);
        }
        if (cacheCandidate != null &amp;&amp; cacheResponse == null) {
            closeQuietly(cacheCandidate.body());
        }
        // 请求不使用网络并且不使用缓存，相当于在这里就拦截了，没必要交给下一级（网络请求拦截器）来执行
        if (networkRequest == null &amp;&amp; cacheResponse == null) {
            return new Response.Builder()
                    .request(chain.request())
                    .protocol(Protocol.HTTP_1_1)
                    .code(504)
                    .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)
                    .body(Util.EMPTY_RESPONSE)
                    .sentRequestAtMillis(-1L)
                    .receivedResponseAtMillis(System.currentTimeMillis())
                    .build();
        }
        // 该请求使用缓存，但是不使用网络：从缓存中拿结果，没必要交给下一级（网络请求拦截器）执行
        if (networkRequest == null) {
            return cacheResponse.newBuilder().cacheResponse(stripBody(cacheResponse)).build();
        }
        Response networkResponse = null;
        try {
            // 这里调用了执行链的处理方法，实际就是交给自己的下一级来执行了
            networkResponse = chain.proceed(networkRequest);
        } finally {
            if (networkResponse == null &amp;&amp; cacheCandidate != null) {
                closeQuietly(cacheCandidate.body());
            }
        }
        // 这里当拿到了网络请求之后调用，下一级执行完毕会交给它继续执行，如果使用了缓存就把请求结果更新到缓存里
        if (cacheResponse != null) {
            // 服务器返回的结果是304，返回缓存中的结果
            if (networkResponse.code() == HTTP_NOT_MODIFIED) {
                Response response = cacheResponse.newBuilder()
                        .headers(combine(cacheResponse.headers(), networkResponse.headers()))
                        .sentRequestAtMillis(networkResponse.sentRequestAtMillis())
                        .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())
                        .cacheResponse(stripBody(cacheResponse))
                        .networkResponse(stripBody(networkResponse))
                        .build();
                networkResponse.body().close();
                cache.trackConditionalCacheHit();
                // 更新缓存
                cache.update(cacheResponse, response);
                return response;
            } else {
                closeQuietly(cacheResponse.body());
            }
        }
        Response response = networkResponse.newBuilder()
                .cacheResponse(stripBody(cacheResponse))
                .networkResponse(stripBody(networkResponse))
                .build();
        // 把请求的结果放进缓存里
        if (cache != null) {
            if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) {
                CacheRequest cacheRequest = cache.put(response);
                return cacheWritingResponse(cacheRequest, response);
            }
            if (HttpMethod.invalidatesCache(networkRequest.method())) {
                try {
                    cache.remove(networkRequest);
                } catch (IOException ignored) {
                    // The cache cannot be written.
                }
            }
        }
        return response;
    }
}
</code></pre><p>对缓存，这里我们使用的是全局变量 <code>cache</code>，它是 <code>InternalCache</code> 类型的变量。<code>InternalCache</code> 是一个接口，在 OkHttp 中只有一个实现类 <code>Cache</code>。在 <code>Cache</code> 内部，使用了 <code>DiskLruCache</code> 来将缓存的数据存到磁盘上。<code>DiskLruCache</code> 以及 <code>LruCache</code> 是 Android 上常用的两种缓存策略。前者是基于磁盘来进行缓存的，后者是基于内存来进行缓存的，它们的核心思想都是 Least Recently Used，即最近最少使用算法。我们会在以后的文章中详细介绍这两种缓存框架，也请继续关注我们的文章。</p>
<p>另外，上面我们根据请求和缓存的响应中的信息来判断是否存在缓存可用的时候用到了 <code>CacheStrategy</code> 的两个字段，得到这两个字段的时候使用了非常多的判断，其中涉及 Http 缓存相关的知识，感兴趣的话可以自己参考源代码。</p>
<h3 id="2-6-连接复用：ConnectInterceptor"><a href="#2-6-连接复用：ConnectInterceptor" class="headerlink" title="2.6 连接复用：ConnectInterceptor"></a>2.6 连接复用：ConnectInterceptor</h3><p>连接拦截器 <code>ConnectInterceptor</code> 用来打开到指定服务器的网络连接，并交给下一个拦截器处理。这里我们只打开了一个网络连接，但是并没有发送请求到服务器。从服务器获取数据的逻辑交给下一级的拦截器来执行。虽然，这里并没有真正地从网络中获取数据，而仅仅是打开一个连接，但这里有不少的内容值得我们去关注。因为在获取连接对象的时候，使用了连接池 <code>ConnectionPool</code> 来复用连接。</p>
<pre><code>public final class ConnectInterceptor implements Interceptor {

    @Override public Response intercept(Chain chain) throws IOException {
        RealInterceptorChain realChain = (RealInterceptorChain) chain;
        Request request = realChain.request();
        StreamAllocation streamAllocation = realChain.streamAllocation();

        boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);
        HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);
        RealConnection connection = streamAllocation.connection();

        return realChain.proceed(request, streamAllocation, httpCodec, connection);
    }
}
</code></pre><p>这里的 <code>HttpCodec</code> 用来编码请求并解码响应，<code>RealConnection</code> 用来向服务器发起连接。它们会在下一个拦截器中被用来从服务器中获取响应信息。下一个拦截器的逻辑并不复杂，这里万事具备之后，只要它来从服务器中读取数据即可。可以说，OkHttp 中的核心部分大概就在这里，所以，我们就先好好分析一下，这里在创建连接的时候如何借助连接池来实现连接复用的。</p>
<p>根据上面的代码，当我们调用 <code>streamAllocation</code> 的 <code>newStream()</code> 方法的时候，最终会经过一系列的判断到达 <code>StreamAllocation</code> 中的 <code>findConnection()</code> 方法。</p>
<pre><code>private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
                                      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
    // ...
    synchronized (connectionPool) {
        // ...
        // 尝试使用已分配的连接，已经分配的连接可能已经被限制创建新的流
        releasedConnection = this.connection;
        // 释放当前连接的资源，如果该连接已经被限制创建新的流，就返回一个Socket以关闭连接
        toClose = releaseIfNoNewStreams();
        if (this.connection != null) {
            // 已分配连接，并且该连接可用
            result = this.connection;
            releasedConnection = null;
        }
        if (!reportedAcquired) {
            // 如果该连接从未被标记为获得，不要标记为发布状态，reportedAcquired 通过 acquire() 方法修改
            releasedConnection = null;
        }

        if (result == null) {
            // 尝试供连接池中获取一个连接
            Internal.instance.get(connectionPool, address, this, null);
            if (connection != null) {
                foundPooledConnection = true;
                result = connection;
            } else {
                selectedRoute = route;
            }
        }
    }
    // 关闭连接
    closeQuietly(toClose);

    if (releasedConnection != null) {
        eventListener.connectionReleased(call, releasedConnection);
    }
    if (foundPooledConnection) {
        eventListener.connectionAcquired(call, result);
    }
    if (result != null) {
        // 如果已经从连接池中获取到了一个连接，就将其返回
        return result;
    }

    boolean newRouteSelection = false;
    if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection.hasNext())) {
        newRouteSelection = true;
        routeSelection = routeSelector.next();
    }

    synchronized (connectionPool) {
        if (canceled) throw new IOException(&quot;Canceled&quot;);

        if (newRouteSelection) {
            // 根据一系列的 IP 地址从连接池中获取一个链接
            List&lt;Route&gt; routes = routeSelection.getAll();
            for (int i = 0, size = routes.size(); i &lt; size; i++) {
                Route route = routes.get(i);
                // 从连接池中获取一个连接
                Internal.instance.get(connectionPool, address, this, route);
                if (connection != null) {
                    foundPooledConnection = true;
                    result = connection;
                    this.route = route;
                    break;
                }
            }
        }

        if (!foundPooledConnection) {
            if (selectedRoute == null) {
                selectedRoute = routeSelection.next();
            }

            // 创建一个新的连接，并将其分配，这样我们就可以在握手之前进行终端
            route = selectedRoute;
            refusedStreamCount = 0;
            result = new RealConnection(connectionPool, selectedRoute);
            acquire(result, false);
        }
    }

    // 如果我们在第二次的时候发现了一个池连接，那么我们就将其返回
    if (foundPooledConnection) {
        eventListener.connectionAcquired(call, result);
        return result;
    }

    // 进行 TCP 和 TLS 握手
    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
            connectionRetryEnabled, call, eventListener);
    routeDatabase().connected(result.route());

    Socket socket = null;
    synchronized (connectionPool) {
        reportedAcquired = true;

        // 将该连接放进连接池中
        Internal.instance.put(connectionPool, result);

        // 如果同时创建了另一个到同一地址的多路复用连接，释放这个连接并获取那个连接
        if (result.isMultiplexed()) {
            socket = Internal.instance.deduplicate(connectionPool, address, this);
            result = connection;
        }
    }
    closeQuietly(socket);

    eventListener.connectionAcquired(call, result);
    return result;
}
</code></pre><p>该方法会被放置在一个循环当中被不停地调用以得到一个可用的连接。它优先使用当前已经存在的连接，不然就使用连接池中存在的连接，再不行的话，就创建一个新的连接。所以，上面的代码大致分成三个部分：</p>
<ol>
<li>判断当前的连接是否可以使用：流是否已经被关闭，并且已经被限制创建新的流；</li>
<li>如果当前的连接无法使用，就从连接池中获取一个连接；</li>
<li>连接池中也没有发现可用的连接，创建一个新的连接，并进行握手，然后将其放到连接池中。</li>
</ol>
<p>在从连接池中获取一个连接的时候，使用了 <code>Internal</code> 的 <code>get()</code> 方法。<code>Internal</code> 有一个静态的实例，会在 OkHttpClient 的静态代码快中被初始化。我们会在 <code>Internal</code> 的 <code>get()</code> 中调用连接池的 <code>get()</code> 方法来得到一个连接。</p>
<p>从上面的代码中我们也可以看出，实际上，我们使用连接复用的一个好处就是省去了进行 TCP 和 TLS 握手的一个过程。因为建立连接本身也是需要消耗一些时间的，连接被复用之后可以提升我们网络访问的效率。那么这些连接被放置在连接池之后是如何进行管理的呢？我们会在下文中分析 OkHttp 的 <code>ConnectionPool</code> 中是如何管理这些连接的。</p>
<h3 id="2-7-CallServerInterceptor"><a href="#2-7-CallServerInterceptor" class="headerlink" title="2.7 CallServerInterceptor"></a>2.7 CallServerInterceptor</h3><p>服务器请求拦截器 <code>CallServerInterceptor</code> 用来向服务器发起请求并获取数据。这是整个责任链的最后一个拦截器，这里没有再继续调用执行链的处理方法，而是把拿到的响应处理之后直接返回给了上一级的拦截器：</p>
<pre><code>public final class CallServerInterceptor implements Interceptor {

    @Override public Response intercept(Chain chain) throws IOException {
        RealInterceptorChain realChain = (RealInterceptorChain) chain;
        // 获取 ConnectInterceptor 中初始化的 HttpCodec
        HttpCodec httpCodec = realChain.httpStream();
        // 获取 RetryAndFollowUpInterceptor 中初始化的 StreamAllocation
        StreamAllocation streamAllocation = realChain.streamAllocation();
        // 获取 ConnectInterceptor 中初始化的 RealConnection
        RealConnection connection = (RealConnection) realChain.connection();
        Request request = realChain.request();

        long sentRequestMillis = System.currentTimeMillis();

        realChain.eventListener().requestHeadersStart(realChain.call());
        // 在这里写入请求头 
        httpCodec.writeRequestHeaders(request);
        realChain.eventListener().requestHeadersEnd(realChain.call(), request);

        Response.Builder responseBuilder = null;
        if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) {
            if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) {
                httpCodec.flushRequest();
                realChain.eventListener().responseHeadersStart(realChain.call());
                responseBuilder = httpCodec.readResponseHeaders(true);
            }
             // 在这里写入请求体
            if (responseBuilder == null) {
                realChain.eventListener().requestBodyStart(realChain.call());
                long contentLength = request.body().contentLength();
                CountingSink requestBodyOut =
                        new CountingSink(httpCodec.createRequestBody(request, contentLength));
                BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
                // 写入请求体
                request.body().writeTo(bufferedRequestBody);
                bufferedRequestBody.close();
                realChain.eventListener()
                        .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);
            } else if (!connection.isMultiplexed()) {
                streamAllocation.noNewStreams();
            }
        }
        httpCodec.finishRequest();
        if (responseBuilder == null) {
            realChain.eventListener().responseHeadersStart(realChain.call());
            // 读取响应头
            responseBuilder = httpCodec.readResponseHeaders(false);
        }
        Response response = responseBuilder
                .request(request)
                .handshake(streamAllocation.connection().handshake())
                .sentRequestAtMillis(sentRequestMillis)
                .receivedResponseAtMillis(System.currentTimeMillis())
                .build();
        // 读取响应体
        int code = response.code();
        if (code == 100) {
            responseBuilder = httpCodec.readResponseHeaders(false);
            response = responseBuilder
                    .request(request)
                    .handshake(streamAllocation.connection().handshake())
                    .sentRequestAtMillis(sentRequestMillis)
                    .receivedResponseAtMillis(System.currentTimeMillis())
                    .build();
            code = response.code();
        }
        realChain.eventListener().responseHeadersEnd(realChain.call(), response);
        if (forWebSocket &amp;&amp; code == 101) {
            response = response.newBuilder()
                    .body(Util.EMPTY_RESPONSE)
                    .build();
        } else {
            response = response.newBuilder()
                    .body(httpCodec.openResponseBody(response))
                    .build();
        }
        // ...
        return response;
    }
}
</code></pre><h3 id="2-8-连接管理：ConnectionPool"><a href="#2-8-连接管理：ConnectionPool" class="headerlink" title="2.8 连接管理：ConnectionPool"></a>2.8 连接管理：ConnectionPool</h3><p>与请求的缓存类似，OkHttp 的连接池也使用一个双端队列来缓存已经创建的连接：</p>
<pre><code>private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;();
</code></pre><p>OkHttp 的缓存管理分成两个步骤，一边当我们创建了一个新的连接的时候，我们要把它放进缓存里面；另一边，我们还要来对缓存进行清理。在 <code>ConnectionPool</code> 中，当我们向连接池中缓存一个连接的时候，只要调用双端队列的 <code>add()</code> 方法，将其加入到双端队列即可，而清理连接缓存的操作则交给线程池来定时执行。</p>
<p>在 <code>ConnectionPool</code> 中存在一个静态的线程池：</p>
<pre><code>private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,
    Integer.MAX_VALUE /* maximumPoolSize */, 
    60L /* keepAliveTime */,
    TimeUnit.SECONDS,
    new SynchronousQueue&lt;Runnable&gt;(), 
    Util.threadFactory(&quot;OkHttp ConnectionPool&quot;, true));
</code></pre><p>每当我们向连接池中插入一个连接的时候就会调用下面的方法，将连接插入到双端队列的同时，会调用上面的线程池来执行清理缓存的任务：</p>
<pre><code>void put(RealConnection connection) {
    assert (Thread.holdsLock(this));
    if (!cleanupRunning) {
        cleanupRunning = true;
        // 使用线程池执行清理任务
        executor.execute(cleanupRunnable);
    }
    // 将新建的连接插入到双端队列中
    connections.add(connection);
}
</code></pre><p>这里的清理任务是 <code>cleanupRunnable</code>，是一个 <code>Runnable</code> 类型的实例。它会在方法内部调用 <code>cleanup()</code> 方法来清理无效的连接：</p>
<pre><code>private final Runnable cleanupRunnable = new Runnable() {
    @Override public void run() {
        while (true) {
            long waitNanos = cleanup(System.nanoTime());
            if (waitNanos == -1) return;
            if (waitNanos &gt; 0) {
                long waitMillis = waitNanos / 1000000L;
                waitNanos -= (waitMillis * 1000000L);
                synchronized (ConnectionPool.this) {
                    try {
                        ConnectionPool.this.wait(waitMillis, (int) waitNanos);
                    } catch (InterruptedException ignored) {
                    }
                }
            }
        }
    }
};
</code></pre><p>下面是 <code>cleanup()</code> 方法：</p>
<pre><code>long cleanup(long now) {
    int inUseConnectionCount = 0;
    int idleConnectionCount = 0;
    RealConnection longestIdleConnection = null;
    long longestIdleDurationNs = Long.MIN_VALUE;

    synchronized (this) {
        // 遍历所有的连接
        for (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) {
            RealConnection connection = i.next();
            // 当前的连接正在使用中
            if (pruneAndGetAllocationCount(connection, now) &gt; 0) {
                inUseConnectionCount++;
                continue;
            }
            idleConnectionCount++;
            // 如果找到了一个可以被清理的连接，会尝试去寻找闲置时间最久的连接来释放
            long idleDurationNs = now - connection.idleAtNanos;
            if (idleDurationNs &gt; longestIdleDurationNs) {
                longestIdleDurationNs = idleDurationNs;
                longestIdleConnection = connection;
            }
        }

        if (longestIdleDurationNs &gt;= this.keepAliveDurationNs 
                || idleConnectionCount &gt; this.maxIdleConnections) {
            // 该连接的时长超出了最大的活跃时长或者闲置的连接数量超出了最大允许的范围，直接移除
            connections.remove(longestIdleConnection);
        } else if (idleConnectionCount &gt; 0) {
            // 闲置的连接的数量大于0，停顿指定的时间（等会儿会将其清理掉，现在还不是时候）
            return keepAliveDurationNs - longestIdleDurationNs;
        } else if (inUseConnectionCount &gt; 0) {
            // 所有的连接都在使用中，5分钟后再清理
            return keepAliveDurationNs;
        } else {
            // 没有连接
            cleanupRunning = false;
            return -1;
        }
    }

    closeQuietly(longestIdleConnection.socket());
    return 0;
}
</code></pre><p>在从缓存的连接中取出连接来判断是否应该将其释放的时候使用到了两个变量 <code>maxIdleConnections</code> 和 <code>keepAliveDurationNs</code>，分别表示最大允许的闲置的连接的数量和连接允许存活的最长的时间。默认空闲连接最大数目为5个，<code>keepalive</code> 时间最长为5分钟。</p>
<p>上面的方法会对缓存中的连接进行遍历，以寻找一个闲置时间最长的连接，然后根据该连接的闲置时长和最大允许的连接数量等参数来决定是否应该清理该连接。同时注意上面的方法的返回值是一个时间，如果闲置时间最长的连接仍然需要一段时间才能被清理的时候，会返回这段时间的时间差，然后会在这段时间之后再次对连接池进行清理。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>以上就是我们对 OkHttp 内部网络访问的源码的分析。当我们发起一个请求的时候会初始化一个 Call 的实例，然后根据同步和异步的不同，分别调用它的 <code>execute()</code> 和 <code>enqueue()</code> 方法。虽然，两个方法一个会在当前的线程中被立即执行，一个会在线程池当中执行，但是它们进行网络访问的逻辑都是一样的：通过拦截器组成的责任链，依次经过重试、桥接、缓存、连接和访问服务器等过程，来获取到一个响应并交给用户。其中，缓存和连接两部分内容是重点，因为前者涉及到了一些计算机网络方面的知识，后者则是 OkHttp 效率和框架的核心。</p>

      
    </div>
    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/uploads/wx.png" alt="WngShhng wechat" style="width: 200px; max-width: 100%;"/>
    <div>关注作者的微信公众号获取更多的学习内容</div>
</div>

      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>支持作者</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/mm_pay.png" alt="WngShhng 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/ali_pay.jpg" alt="WngShhng 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/计算机网络/" rel="tag"># 计算机网络</a>
          
            <a href="/tags/OkHttp/" rel="tag"># OkHttp</a>
          
            <a href="/tags/源码阅读/" rel="tag"># 源码阅读</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/14/View 体系详解：坐标系、滑动事件和分发机制/" rel="next" title="View 体系详解：坐标系、滑动事件和分发机制">
                <i class="fa fa-chevron-left"></i> View 体系详解：坐标系、滑动事件和分发机制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/20/动态代理在 Android 中的应用：Retrofit 源码解析/" rel="prev" title="动态代理在 Android 中的应用：Retrofit 源码解析">
                动态代理在 Android 中的应用：Retrofit 源码解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="WngShhng" />
            
              <p class="site-author-name" itemprop="name">WngShhng</p>
              <p class="site-description motion-element" itemprop="description">生命就是一种表达</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Shouheng88" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:shouheng2015@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/u/0/102173602321685428586" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://stackoverflow.com/users/5527475/shouheng-wang" target="_blank" title="SOF">
                      
                        <i class="fa fa-fw fa-stack-overflow"></i>SOF</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://juejin.im/user/585555e11b69e6006c907a2a" title="掘金博客" target="_blank">掘金博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/github_35186068" title="CSDN博客" target="_blank">CSDN博客</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、OkHttp-的基本使用"><span class="nav-number">1.</span> <span class="nav-text">1、OkHttp 的基本使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、OkHttp-源码分析"><span class="nav-number">2.</span> <span class="nav-text">2、OkHttp 源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-一个请求的大致流程"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 一个请求的大致流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-分发器-Dispatcher"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 分发器 Dispatcher</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-责任链的执行过程"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 责任链的执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-重试和重定向：RetryAndFollowUpInterceptor"><span class="nav-number">2.4.</span> <span class="nav-text">2.3 重试和重定向：RetryAndFollowUpInterceptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-BridgeInterceptor"><span class="nav-number">2.5.</span> <span class="nav-text">2.4 BridgeInterceptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-使用缓存：CacheInterceptor"><span class="nav-number">2.6.</span> <span class="nav-text">2.5 使用缓存：CacheInterceptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-连接复用：ConnectInterceptor"><span class="nav-number">2.7.</span> <span class="nav-text">2.6 连接复用：ConnectInterceptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-CallServerInterceptor"><span class="nav-number">2.8.</span> <span class="nav-text">2.7 CallServerInterceptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-连接管理：ConnectionPool"><span class="nav-number">2.9.</span> <span class="nav-text">2.8 连接管理：ConnectionPool</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结："><span class="nav-number">3.</span> <span class="nav-text">总结：</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WngShhng</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  








  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
