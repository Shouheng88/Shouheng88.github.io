<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[View 体系详解：坐标系、滑动事件和分发机制]]></title>
    <url>%2F2018%2F10%2F14%2FView%20%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E6%BB%91%E5%8A%A8%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1、位置1.1 坐标系下面是 Android 中的 View 坐标系的基本图。要获得一个 View 的位置，我们可以借助两个对象，一个是 View ，一个是 MotionEvent。以下是它们的一些方法的位置的含义： 在 View 中共有 mLeft, mRight, mTop 和 mBottom 四个变量包含 View 的坐标信息，你可以在源码中获取它们的含义： mLeft：指定控件的左边缘距离其父控件左边缘的位置，单位：像素； mRight：指定控件的右边缘距离其父控件左边缘的位置，单位：像素； mTop：指定控件的上边缘距离其父控件上边缘的位置，单位：像素； mBottom：指定控件的下边缘距离其父控件上边缘的位置，单位：像素。 此外，View 中还有几个方法用来获取控件的位置等信息，实际上就是上面四个变量的 getter 方法： getLeft()：即 mLeft； getRight()：即 mRight； getTop()：即 mTop； getBottom()：即 mBottom； 所以，我们可以得到两个获取 View 高度和宽度信息的方法： getHeight()：即 mBottom - mTop； getWidth()：即 mRight - mLeft； 另外，就是 View 中的 getX() 和 getY() 两个方法，你需要注意将其与 MotionEvent 中的同名方法进行区分。在没有对控件进行平移的时候，getX() 与 getLeft() 返回结果相同，只是前者会在后者的基础上加上平移的距离： getX()：即 mLeft + getTranslationX()，即控件的左边缘加上 X 方向平移的距离； getY()：即 mTop + getTranslationY()，即控件的上边缘加上 Y 方向平移的距离； 以上是我们对 View 中获取控件位置的方法的梳理，你可以到源码中查看它们更加相详尽的定义，那更有助于自己的理解。 1.2 MotionEvent通常当你对控件进行触摸监听的时候会用到 MotionEvent ，它封住了触摸的位置等信息。下面我们对 MotionEvent 中的获取点击事件的位置的方法进行梳理，它主要涉及下面四个方法： MotionEvent.getX()：获取点击事件距离控件左边缘的距离，单位：像素； MotionEvent.getY()：获取点击事件距离控件上边缘的距离，单位：像素； MotionEvent.getRawX()：获取点击事件距离屏幕左边缘的距离，单位：像素； MotionEvent.getRawY()：获取点击事件距离屏幕上边缘的距离，单位：像素。 另外是触摸事件中的三种典型的行为，按下、移动和抬起。接下来的代码示例中我们会用到它们来判断手指的行为，并对其做响应的处理： MotionEvent.ACTION_DOWN：按下的行为； MotionEvent.ACTION_MOVE：手指在屏幕上移动的行为； MotionEvent.ACTION_UP：手指抬起的行为。 2、滑动我们有几种方式实现 View 的滑动： 2.1 layout() 方法调用控件的 layout() 方法进行滑动，下面是该方法的定义： 1public void layout(int l, int t, int r, int b) &#123; /*...*/ &#125; 其中的四个参数 l, t, r, b分别表示控件相对于父控件的左、上、右、下的距离，分别对应于上面的 mLeft, mTop, mRight 和 mBottom。所以，调用该方法同时可以改变控件的高度和宽度，但有时候我们不需要改变控件的高度和宽度，只要移动其位置即可。所以，我们又有方法 offsetLeftAndRight() 和 offsetTopAndBottom() 可以使用，后者只会对控件的位置进行平移。因此，我们可以进行如下的代码测试： private int lastX, lastY; private void layoutMove(MotionEvent event) { int x = (int) event.getX(), y = (int) event.getY(); switch (event.getAction()) { case MotionEvent.ACTION_DOWN: lastX = x; lastY = y; break; case MotionEvent.ACTION_MOVE: int offsetX = x - lastX, offsetY = y - lastY; getBinding().v.layout(getBinding().v.getLeft() + offsetX, getBinding().v.getTop() + offsetY, getBinding().v.getRight() + offsetX, getBinding().v.getBottom() + offsetY); break; case MotionEvent.ACTION_UP: break; } } 上面的代码的效果是指定的控件会随着手指的移动而移动。这里我们先记录下按下的位置，然后手指移动的时候记录下平移的位置，最后调用 layout() 即可。 2.2 offsetLeftAndRight() 和 offsetTopAndBottom()上面已经提到过这两个方法，它们只改变控件的位置，无法改变大小。我们只需要对上述代码做少量修改就可以实现同样的效果： getBinding().v.offsetLeftAndRight(offsetX); getBinding().v.offsetTopAndBottom(offsetY); 2.3 改变布局参数通过获取并修改控件的 LayoutParams，我们一样可以达到修改控件的位置的目的。毕竟，本身这个对象就代表着控件的布局： FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) getBinding().v.getLayoutParams(); lp.leftMargin = getBinding().v.getLeft() + offsetX; lp.topMargin = getBinding().v.getTop() + offsetY; getBinding().v.setLayoutParams(lp); 2.4 动画使用动画我们也可以实现控件移动的效果，这里所谓的动画主要是操作 View 的 transitionX 和 transitionY 属性： getBinding().v.animate().translationX(5f); getBinding().v.animate().translationY(5f); 关于动画的内容，我们会在后面详细介绍。 2.5 scrollTo() 和 scrollBy()scrollBy() 方法内部调用了 scrollTo()，以下是这部分的源码。scrollBy() 表示在当前的位置上面进行平移，而 scrollTo() 表示平移到指定的位置： public void scrollBy(int x, int y) { scrollTo(mScrollX + x, mScrollY + y); } 同样对上述代码进行修改，我们也可以实现之前的效果： ((View) getBinding().v.getParent()).scrollBy(-offsetX, -offsetY); 或者 View parent = ((View) getBinding().v.getParent()); parent.scrollTo(parent.getScrollX()-offsetX, parent.getScrollY()-offsetY); 此外，还有一个需要注意的地方是：与上面的 offsetLeftAndRight() 和 offsetTopAndBottom() 不同的是，这里我们用了平移的值的相反数。原因很简单，因为我们要使用这两个方法的时候需要对指定的控件所在的父容器进行调用（正如上面是先获取父控件）。当我们希望控件相对于之前的位置向右下方向移动，就应该让父容器相对于之前的位置向左上方向移动。因为实际上该控件相对于父控件的位置没有发生变化，变化的是父控件的位置。（参考的坐标系不同） 2.6 Scroller上面，我们的测试代码是让指定的控件随着手指移动，但是假如我们希望控件从一个位置移动到另一个位置呢？当然，它们也可以实现，但是这几乎就是在瞬间完成了整个操作，实际的UI效果肯定不会好。所以，为了让滑动的过程看起来更加流畅，我们可以借助 Scroller 来实现。 在使用 Scroller 之前，我们需要先实例化一个 Scroller ： private Scroller scroller = new Scroller(getContext()); 然后，我们需要覆写自定义控件的 computeScroll() 方法，这个方法会在绘制 View 的时候被调用。所以，这里的含义就是，当 View 重绘的时候会调用 computeScroll() 方法，而 computeScroll() 方法会判断是否需要继续滚动，如果需要继续滚动的时候就调用 invalidate() 方法，该方法会导致 View 进一步重绘。所以，也就是靠着这种不断进行重绘的方式实现了滚动的效果。 滑动效果最终结束的判断是通过 Scroller 的 computeScrollOffset() 方法实现的，当滚动停止的时候，该方法就会返回 false，这样不会继续调用 invalidate() 方法，因而也就不会继续绘制了。下面是该方法典型的覆写方式： @Override public void computeScroll() { super.computeScroll(); if (scroller.computeScrollOffset()) { ((View) getParent()).scrollTo(scroller.getCurrX(), scroller.getCurrY()); invalidate(); } } 然后，我们再加入一个滚动到指定位置的方法，在该方法内部我们使用了 2000ms 来指定完成整个滑动所需要的时间： public void smoothScrollTo(int descX, int descY) { scroller.startScroll(getScrollX(), getScrollY(), descX - getScrollX(), descY - getScrollY(), 2000); invalidate(); } 这样定义了之后，我们只需要在需要滚动的时候调用自定义 View 的 smoothScrollTo() 方法即可。 3、手势3.1 ViewConfiguration在类 ViewConfiguration 中定义了一些列的常量用来标志指定的行为，比如，TouchSlop 就是滑动的最小的距离。你可以通过 ViewConfiguration.get(context) 来获取 ViewConfiguration 实例，然后通过它的 getter 方法来获取这些常量的定义。 3.2 VelocityTrackerVelocityTracker 用来检测手指滑动的速率，它的使用非常简单。在使用之前，我们先使用它的静态方法 obtain() 获取一个实例，然后在 onTouch() 方法中调用它的 addMovement(MotionEvent) 方法： velocityTracker = VelocityTracker.obtain(); 随后，当我们想要获得速率的时候，先调用 computeCurrentVelocity(int) 传入一个时间片段，单位是毫秒，然后调用 getXVelocity() 和 getYVelocity() 分别获得在水平和竖直方向上的速率即可： velocityTracker.computeCurrentVelocity((int) duration); getBinding().tvVelocity.setText(&quot;X:&quot; + velocityTracker.getXVelocity() + &quot;\n&quot; + &quot;Y:&quot; + velocityTracker.getYVelocity()); 本质上，计算速率的时候是用指定时间的长度变化除以我们传入的时间片。当我们使用完了 VelocityTracker 之后，需要回收资源： velocityTracker.clear(); velocityTracker.recycle(); 3.3 GestureDectectorGestureDectector 用来检测手指的手势。在使用它之前我们需要先获取一个 GestureDetector 的实例： mGestureDetector = new GestureDetector(getContext(), new MyOnGestureListener()); 这里我们用了 GestureDetector 的构造方法，需要传入一个 OnGestureListener 对象。这里我们用了 MyOnGestureListener 实例。 MyOnGestureListener 是一个自定义的类，实现了 OnGestureListener 接口： private class MyOnGestureListener extends GestureDetector.SimpleOnGestureListener { @Override public boolean onSingleTapUp(MotionEvent e) { ToastUtils.makeToast(&quot;Click detected&quot;); return false; } @Override public void onLongPress(MotionEvent e) { LogUtils.d(&quot;Long press detected&quot;); } @Override public boolean onDoubleTap(MotionEvent e) { LogUtils.d(&quot;Double tab detected&quot;); return true; } @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) { LogUtils.d(&quot;Fling detected&quot;); return true; } } 在 MyOnGestureListener 中，我们覆写了它的一些方法。比如，单击、双击和长按等等，当检测到相应的手势的时候这些方法就会被调用。 然后，我们可以这样使用 GestureDetector，只要在控件的触摸事件回调中调用即可： getBinding().vg.setOnTouchListener((v, event) -&gt; { mGestureDetector.onTouchEvent(event); return true; }); 4、事件分发机制4.1 事件传递的过程当讨论事件分发机制的时候，我们首先要了解 Android 中 View 的组成结构。在 Android 中，一个 Activity 包含一个 PhoneWindow，当我们在 Activity 中调用 setContentView() 方法的时候，会调用该 PhoneWindow 的 setContentView() 方法，并在这个方法中生成一个 DecorView 作为 Activity 的跟 View。 根据上面的分析，当一个点击事件被触发的时候，首先接收到该事件的是 Activity。因为，Activity 覆盖了整个屏幕，我们需要先让它接收事件，然后它把事件传递给根 View 之后，再由根 View 向下继续传递。这样不断缩小搜索的范围，直到最顶层的 View。当然，任何的父容器都可以决定这个事件是不是要继续向下传递，因此，我们可以大致得到下面这个事件传递的图： 左边的图是一个 Activity 内部的 View 和 Window 的组织结构。右面的图可以看作它的切面图，其中的黑色箭头表示事件的传递过程。这里事件传递的过程是先从下到上，然后再从上到下。也就是从大到小，不断定位到触摸的控件，其中每个父容器可以决定是否将事件传递下去。（需要注意的地方是，如果一个父容器有多个子元素的话，那么在这些子元素中进行遍历的时候，顺序是从上往下的，也就是按照展示的顺序）。 上面我们分析了 Android 事件传递的过程，相信你有了一个大致的了解。但是，想要了解整个事件传递过程具体涉及了哪些方法、如何作用等，还需要我们对源码进行分析。 4.2 事件传递的原理当触摸事件发生的时候，首先会被 Activity 接收到，然后该 Activity 会通过其内部的 dispatchTouchEvent(MotionEvent) 将事件传递给内部的 PhoneWindow；接着 PhoneWindow 会把事件交给 DecorView，再由 DecorView 交给根 ViewGroup。剩下的事件传递就只在 ViewGroup 和 View 之间进行。我们可以通过覆写 Activity 的 dispatchTouchEvent(MotionEvent) 来阻止把事件传递给 PhoneWindow。实际上，在我们开发的时候不会对 Window 的事件传递方法进行重写，一般是对 ViewGroup 或者 View。所以，下面我们的分析只在这两种控件之间进行。 当讨论 View 的事件分发机制的时候，无外乎下面三个方法： boolean onInterceptTouchEvent(MotionEvent ev)：用来对事件进行拦截，该方法只存在于 ViewGroup 中。一般我们会通过覆写该方法来拦截触摸事件，使其不再继续传递给子 View。 boolean dispatchTouchEvent(MotionEvent event)：用来分发触摸事件，一般我们不覆写该方法，返回 true 则表示事件被处理了。在 View 中，它负责根据手势的类型和控件的状态对事件进行处理，会回调我们的 OnTouchListener 或者 OnClickListener；在 ViewGroup 中，该方法被覆写，它的责任是对事件进行分发，会对所有的子 View 进行遍历，决定是否将事件分发给指定的 View。 boolean onTouchEvent(MotionEvent event)：用于处理触摸事件，返回 true 表示触摸事件被处理了。ViewGroup 没有覆写该方法，故在 ViewGroup 中与 View 中的功能是一样的。需要注意的是，如果我们为控件设置了 OnTouchListener 并且在或者中返回了 true，那么这个方法不会被调用，也就是 OnTouchListener 比该方法的优先级较高。对我们开发来说，就是 OnTouchListener 比 OnClickListener 和 OnLongClickListener 的优先级要高。 于是，我们可以得到如下的伪代码。这段代码是存在于 ViewGroup 中的，也就是事件分发机制的核心代码： boolean dispatchTouchEvent(MotionEvent e) { boolean result; if (onInterceptTouchEvent(e)) { result = super.dispatchTouchEvent(e); } else { result = child.dispatchTouchEvent(e); } return result; } 按照上述分析，触摸事件经过 Activity 传递给根 ViewGroup 之后： 如果 ViewGourp 覆写了 onInterceptTouchEvent() 并且返回了 true 就表示希望拦截该方法，于是就把触摸事件交给当前 ViewGroup 进行处理（触发 OnTouchListener 或者 OnClickListener 等）；否则，会交给子元素的继续分发。如果该子元素是 ViewGroup 的话，就会在该子 View 中执行一遍上述逻辑，否则会在当前的子元素中对事件进行处理（触发 OnTouchListener 或者 OnClickListener 等）……就这样一层层地遍历下去，本质上是一个深度优先的搜索算法。 这里我们对整个事件分发机制的整体做了一个素描，在接下来的文章中我们会对各个方法的细节进行源码分析，为了防止您在接下来的行文中迷路，我们先把这个整体逻辑按下图进行描述： 4.3 事件传递的源码分析上述我们分析了事件分发机制的原理，下面我们通过源代码来更具体地了解这块是如何设计的。同样，我们的焦点也只在那三个需要重点关注的方法。 4.3.1 决定是否拦截事件首先，我们来看 ViewGroup 中的 dispatchTouchEvent(MotionEvent) 方法，我们节选了其一部分： @Override public boolean dispatchTouchEvent(MotionEvent ev) { // ... boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; if (actionMasked == MotionEvent.ACTION_DOWN) { // 1 // 这里表示如果是一个新的触摸事件就要重置所有的状态，其中包括将 mFirstTouchTarget 置为 null cancelAndClearTouchTargets(ev); resetTouchState(); } // 在这里检查是否拦截了事件，mFirstTouchTarget 是之前处理触摸事件的 View 的封装 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { // 这里判断该 ViewGroup 是否禁用了拦截，由 requestDisallowInterceptTouchEvent 设置 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); } else { intercepted = false; } } else { // 非按下事件并且 mFirstTouchTarget 为 null，说明判断过拦截的逻辑并且启用了拦截 intercepted = true; } // ... } // ... return handled; } 上面代码是我们节选的 ViewGroup 拦截事件的部分代码，这里的逻辑显然比伪代码复杂的多。不过，尽管如此，这些代码确实必不可少的。因为，当我们要去判断是否拦截一个触摸事件的时候，此时触摸的事件仍然在继续，这意味着这个方法会被持续调用；抬起的时候再按下，又是另一次调用。考虑到这个连续性，我们需要多做一些逻辑。 这里我们首先在 1 处通过行为是否是“按下”的来判断是否是一次新的触摸事件，如果是的话我们需要重置当前的触摸状态。其次，我们需要根据事件的类型来决定是否应该调用 onInterceptTouchEvent()，因为对一次触摸事件，我们只需要在“按下”的时候判断一次就够了。所以，显然我们需要将 MotionEvent.ACTION_DOWN 作为一个判断条件。然后，我们使用 mFirstTouchTarget 这个全局的变量来记录上次拦截的结果——如果之前的事件交给过子元素处理，那么它就不为空。 除了 mFirstTouchTarget，我们还需要用 mGroupFlags 的 FLAG_DISALLOW_INTERCEPT 标志位来判断该 ViewGroup 是否禁用了拦截。这个标志位可以通过 ViewGroup 的 requestDisallowInterceptTouchEvent(boolean) 来设置。只有没有禁用拦截事件的时候我们才需要调用 onInterceptTouchEvent() 判断是否开启了拦截。 4.3.2 分发事件给子元素如果在上面的操作中事件没有被拦截并且没有被取消，那么就会进入下面的逻辑。这部分代码处在 dispatchTouchEvent() 中。在下面的逻辑中会根据子元素的状态将事件传递给子元素： // 对子元素进行倒序遍历，即从上到下进行遍历 final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); // ... // 判断子元素是否能接收触摸事件：能接收事件并且不是正在进行动画的状态 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } // ... // 在这里调用了 dispatchTransformedTouchEvent() 方法将事件传递给子元素 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // ... 记录一些状态信息 // 在这里完成对 mFirstTouchTarget 的赋值，表示触摸事件被子元素处理 newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; // 结束循环，完成子元素的遍历 break; } // 显然，如果到了这一步，那么子元素的遍历仍将继续 } 当判断了指定的 View 可以接收触摸事件之后会调用 dispatchTransformedTouchEvent() 方法分发事件。其定义的节选如下： private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; // ... if (child == null) { // 本质上逻辑与 View 的 dispatchTouchEvent() 一致 handled = super.dispatchTouchEvent(transformedEvent); } else { // ... // 交给子元素继续分发事件 handled = child.dispatchTouchEvent(transformedEvent); } return handled; } dispatchTransformedTouchEvent() 会根据传入的 child 是否为 null 分成两种调用的情形：事件没有被拦截的时候，让子元素继续分发事件；另一种是当事件被拦截的时候，调用当前的 ViewGroup 的 super.dispatchTouchEvent(transformedEvent) 处理事件。 4.3.3 View 中的 dispatchTouchEvent上面我们分析的 dispatchTouchEvent(MotionEvent) 是 ViewGroup 中重写之后的方法。但是，正如我们上面的分析，重写之前的方法总是会被调用，只是对象不同。这里我们就来分析以下这个方法的作用。 public boolean dispatchTouchEvent(MotionEvent event) { // ... boolean result = false; // .... if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) { result = true; } // 这里回调了 setOnTouchListener() 方法传入的 OnTouchListener ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } // 如果 OnTouchListener 没有被回调过或者返回了 false，就会调用 onTouchEvent() 进行处理 if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } // ... return result; } 根据上面的源码分析，我们知道，如果当前的 View 设置过 OnTouchListener, 并且在 onTouch() 回调方法中返回了 true，那么 onTouchEvent(MotionEvent) 将不会得到调用。那么，我们再来看一下 onTouchEvent() 方法： public boolean onTouchEvent(MotionEvent event) { // ... // 判断当前控件是否是可以点击的：实现了点击、长按或者设置了可点击属性 final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; // ... if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) { switch (action) { case MotionEvent.ACTION_UP: // ... if (!focusTaken) { if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClick(); } } // ... break; case MotionEvent.ACTION_DOWN: // ... if (!clickable) { checkForLongClick(0, x, y); break; } // ... break; // ... } return true; } return false; } 这里先判断指定的控件是否是可点击的，即是否设置过点击或者长按的事件。然后会在手势抬起的时候调用 performClick() 方法，并会在这个方法中尝试从 ListenerInfo 取 OnClickListener 进行回调；会在长按的时候进行监听以调用相应长按事件；其他的事件与之类似，可以自行分析。所以，我们可以得出结论：当为控件的触摸事件进行了赋值并且在其中返回了 true 就代表该事件被消费了，即使设置过单击和长按事件也不会被回调，触摸事件的优先级比后面两者要高。 经过上述分析，我们可以知道 View 中的 dispatchTouchEvent(MotionEvent) 方法就是用来对手势进行处理的，所以回到 4.3.2，那里的意思就是：如果 ViewGroup 拦截了触摸事件，那么它就自己来对事件进行处理；否则就把触摸事件传递给子元素，让它来进行处理。 4.4.4 总结以上就是我们对 Android 中事件分发机制的详解，你可以通过图片和代码结合来更透彻得了解这方面的内容。虽然这部分代码比较多、比较长，但是每个地方的设计都是合情合理的。 源代码你可以在Github获取以上程序的源代码： Android-references。]]></content>
      <categories>
        <category>Android控件详解</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>控件体系</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 体系详解：View 的工作流程]]></title>
    <url>%2F2018%2F10%2F14%2FView%20%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3%EF%BC%9AView%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、View 树的加载流程当我们调用 startActivity() 方法的时候，会调用到 ActivityThread 中的 performLaunchActivity() 获取一个 Activity 实例， 并在 Instrumentation 的 callActivityOnCreate() 方法中调用 Activity 的 onCreate() 完成 DecorView 的创建。这样我们就获取了一个 Activity 的实例，然后我们调用 handleResumeActivity() 来回调 Activity 的 onResume()： private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) { // .... WindowManagerGlobal.initialize(); // 创建 Activity 的实例，在这里完成对 Activity 的 onCreate() 方法的回调 Activity a = performLaunchActivity(r, customIntent); if (a != null) { // ... // 在这里回调 Activity 的 onResume() 方法 handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) { // 在这里完成对 Activity 的 onPause() 方法的回调 performPauseActivityIfNeeded(r, reason); // ... } } // ... } 然后，在 handleResumeActivity() 方法中的 performResumeActivity() 会回调 Activity 的 onResume() 方法。在该方法中，我们会从 Window 中获取之前添加进去的 DecorView，然后将其添加到 WindowManager 中： final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) { // 在这里会回调 Activity 的 onResume() r = performResumeActivity(token, clearHide, reason); if (r != null) { final Activity a = r.activity; // ... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) { r.window = r.activity.getWindow(); // 在这里获取 DecorView View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); // 获取 WindowManager 实例，实际是 WindowManagerImpl ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) { a.mWindowAdded = true; r.mPreserveWindow = false; // Activity 被重建，复用 DecorView，通知子元素 ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) { impl.notifyChildRebuilt(); } } if (a.mVisibleFromClient) { if (!a.mWindowAdded) { a.mWindowAdded = true; // 将 DecorView 添加到 WindowManager 中 wm.addView(decor, l); } else { a.onWindowAttributesChanged(l); } } } } } 这里的 WindowManager 是 WindowManagerImpl 的实例，而调用它的 addView() 方法的时候会使用 WindowManagerGlobal 的 addView() 方法。在该方法中会 new 出来一个 ViewRootImpl，然后调用它的 setView() 把传进来的 DecorView 添加到 Window 里。同时，会调用 requestLayout() 方法进行布局，然后，并最终调用 performTraversals() 完成对整个 View 树进行遍历： private void performTraversals() { // ... if (!mStopped || mReportNextDraw) { // ... performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); } // ... final boolean didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw); boolean triggerGlobalLayoutListener = didLayout || mAttachInfo.mRecomputeGlobalAttributes; if (didLayout) { performLayout(lp, mWidth, mHeight); // ... } // ... if (!cancelDraw &amp;&amp; !newSurface) { // ... performDraw(); } } 在该方法中会调用 performMeasure()、performLayout() 和 performDraw() 三个方法，它们分别会调用 DecorView 的 measure()、layout() 和 draw() 完成对整个 View 树的测量、布局和绘制，一个界面也就呈现给用户了。如果您做过自定义 View 的话，那么您对 onMeasure()、onLayout() 和 onDraw()三个方法一定不会陌生，前面的三个方法与后面的三个方法之间的关系就是：后面的三个方法会被前面的三个方法调用，本质上就是提供给用户用来自定义的方法。下面我们就看下这三个方法究竟各自做了什么操作，当然，我们尽可能从自定义控件的角度来分析，因为这对一个开发者可能帮助更大。 2、measure()View 的大小不仅由自身所决定，同时也会受到父控件的影响，为了我们的控件能更好的适应各种情况，一般会自己进行测量。在上面我们提到了 measure() 方法，它是用来测量 View 的大小的，但实际上测量的主要工作是交给 onMeasure() 方法的。在 View 中，onMeasure() 是一个 protected 的方法，显然它设计的目的就是：提供给子 View 按照父容器提供的限制条件，控制自身的大小，实现自己大小的测量逻辑。所以，当我们自定义一个控件的时候，只会去覆写 onMeasure() 而不去覆写 measure() 方法。 在 Android 中，我们的控件分成 View 和 ViewGroup 两种类型。根据上面的分析，对 View 的测量，我们可以得出如下结论：在 Android 中，ViewGroup 会根据其自身的布局特点，把限制条件封装成 widthMeasureSpec 和 heightMeasureSpec 两个参数传递给子元素；然后，在子元素中根据这两个参数来调整自身的大小。所以，ViewGroup 的 measure() 方法会根据其布局特性的不同而不同；而 View 的 measure()，不论其父容器是哪种类型，只根据 widthMeasureSpec 和 heightMeasureSpec 决定。 下面我们来看一下 onMeasure() 在 View 和 ViewGroup 中的不同表现形式。 2.1 View 的 onMeasure()下面是 View 类中的 onMeasure() 方法。这是一个默认的实现，调用了 setMeasuredDimension() 方法来存储测量之后的宽度和高度。当我们自定义 View 的时候，也需要调用 setMeasuredDimension() 方法把最终的测量结果存储起来： protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension( getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } 显然，我们的测量依据就是 widthMeasureSpec 和 heightMeasureSpec 两个参数。它们是整型的、32位变量，包含了测量模式和测量数值的信息（按位存储到整型变量上，包装成整型的目的是为了节约存储空间）。一般我们会像下面这样来分别获取高度和宽度的测量模式和测量数值（实际就是按位截取）： int widthsize = MeasureSpec.getSize(widthMeasureSpec); // 测量数值 int widthmode = MeasureSpec.getMode(widthMeasureSpec); // 测量模式 int heightsize = MeasureSpec.getSize(heightMeasureSpec); // 测量数值 int heightmode = MeasureSpec.getMode(heightMeasureSpec); // 测量模式 测量模式共有 MeasureSpec.UNSPECIFIED、MeasureSpec.AT_MOST 和 MeasureSpec.EXACTLY 三种，分别对应二进制数值 00、01 和 10，它们各自的含义如下： UNSPECIFIED：默认值，父控件没有给子 View 任何限制，子 View 可以设置为任意大小； EXACTLY：表示父控件已经确切的指定了子 View 的大小； AT_MOST：表示子 View 具体大小没有尺寸限制，但是存在上限，上限一般为父 View 大小。 这里，我不打算详细介绍 View 中默认测量逻辑的具体实现。它的大致逻辑是这样的：首先我们会用 getDefaultSize() 获取默认的宽度或者高度，这个方法接收两个参数，一个是默认的尺寸，一个测量模式。如果父控件没有给它任何限制，它就使用默认的尺寸，否则使用测量数值。这里的默认的尺寸通过 getSuggestedMinimumHeight()/getSuggestedMinimumWidth() 方法得到，它会根据背景图片高度/宽度和 mMinHeight/mMinWidth 的值，取一个最大的值作为控件的高度/宽度。 所以，View 的默认的测量逻辑的实际效果是：首先 View 的大小受父容器的影响，如果父容器没有给它限制的话，它会取背景图片和最小的高度或者宽度中取一个最大的值作为自己的大小。 2.2 ViewGroup 的 onMeasure()2.2.1 ViewGroup 中的方法由于 ViewGroup 本身没有布局的特点，所以它没有覆写 onMeasure()。有自身布局特点的，比如 LinearLayout 和 RelativeLayout 等都覆写并实现了这个方法。尽管如此，ViewGroup 提供了一些方法帮助我们进行测量，首先是 measureChildren() 方法： protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) { final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) { final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) { measureChild(child, widthMeasureSpec, heightMeasureSpec); } } } 这里的逻辑比较简单，就是对子元素进行遍历并判断如果指定的 View 是否位 GONE 的状态，如果不是就调用 measureChild() 方法： protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) { final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } 该方法也比较容易理解，就是将子元素的布局参数 LayoutParams 取出，获取它的宽度和高度之后，将所有信息传递给 getChildMeasureSpec()。这样就得到了用于子元素布局的 childWidthMeasureSpec 和 childHeightMeasureSpec 参数。然后，再调用子元素的 measure() 方法，从而依次完成对整个 View 树的遍历。下面我们看下 getChildMeasureSpec() 方法做了什么操作： public static int getChildMeasureSpec(int spec, int padding, int childDimension) { // 首先从 spec 中取出父控件的测量模式和测量数值 int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); // 这里需要保证 size 不能为负数，也就是预留给子元素的最大空间，由父元素的测量数值减去填充得到 int size = Math.max(0, specSize - padding); // 用于返回的值 int resultSize = 0; int resultMode = 0; // 根据父空间的测量模式 switch (specMode) { // 父控件的大小是固定的 case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) { // 子 View 指定了大小 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // 子元素希望大小与父控件相同（填满整个父控件） resultSize = size; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // 子元素希望有自己决定大小，但是不能比父控件大 resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // 父控件的具体大小没有尺寸限制，但是存在上限 case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) { // 子 View 指定了大小 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // 子控件希望与父控件大小一致，但是父控件的大小也是不确定的，故让子控件不要比父控件大 resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // 子控件希望自己决定大小，限制其不要比父控件大 resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // 父控件没有任何限制，可以设置为任意大小 case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) { // 子元素设置了大小 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // 子控件希望和父控件一样大，但是父控件多大都不确定；系统23以下返回true，以上返回size resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } else if (childDimension == LayoutParams.WRAP_CONTENT) { resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } break; } // 返回一个封装好的测量结果，就是把测量数值和测量模式封装成一个32位的整数 return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } 上面我们已经为这段代码作了非常详细的注释。只需要注意，这里在获取子元素的测量结果的时候是基于父控件的测量结果来的，需要根据父元素的测量模式和测量数值结合自身的布局特点分成上面九种情况。或者可以按照下面的写法将其划分成下面几种情况： public static int getChildMeasureSpec(int spec, int padding, int childDimension) { int specMode = MeasureSpec.getMode(spec), specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0, resultMode = 0; if (childDimension &gt;= 0) { // 子元素指定了具体的大小，就用子元素的大小 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) { // 子元素希望和父控件一样大，需要设置其上限，然后测量模式与父控件一致即可 if (specMode == MeasureSpec.EXACTLY || specMode == MeasureSpec.AT_MOST) { resultSize = size; resultMode = specMode; } else if (specMode == MeasureSpec.UNSPECIFIED) { // API23一下就是0，父控件没有指定大小的时候，子控件只能是0；以上是size resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) { // 子元素希望自己决定大小，设置其大小的上限是父控件的大小即可 if (specMode == MeasureSpec.EXACTLY || specMode == MeasureSpec.AT_MOST) { resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (specMode == MeasureSpec.UNSPECIFIED) { // API23一下就是0，父控件没有指定大小的时候，子控件只能是0；以上是size resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } } return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } 这两种方式只是划分的角度不一样，后面的这种方法是从子元素的布局参数上面来考虑的。另外，这里有个 sUseZeroUnspecifiedMeasureSpec 布尔参数需要提及一下，会根据系统的版本来进行赋值： sUseZeroUnspecifiedMeasureSpec = targetSdkVersion &lt; Build.VERSION_CODES.M; 也就是当系统是 API23 以下的时候的为 true. 加入这个参数的原因是，API23 之后，当父控件的测量模式是 UNSPECIFIED 的时候，子元素可以给父控件提供一个可能的大小。下面是注释的原话 ;-) // In M and newer, our widgets can pass a &quot;hint&quot; value in the size // for UNSPECIFIED MeasureSpecs. This lets child views of scrolling containers // know what the expected parent size is going to be, so e.g. list items can size // themselves at 1/3 the size of their container. It breaks older apps though, // specifically apps that use some popular open source libraries. 2.2.2 LinearLayout 的 onMeasure()上面我们分析的是 ViewGroup 中提供的一些方法，下面我们以 LinearLayout 为例，看一下一个标准的容器类型的控件是如何实现其测量的逻辑的。 下面是其 onMeasure() 方法，显然在进行测量的时候会根据其布局的方向分别实现测量的逻辑： protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { if (mOrientation == VERTICAL) { measureVertical(widthMeasureSpec, heightMeasureSpec); } else { measureHorizontal(widthMeasureSpec, heightMeasureSpec); } } 然后，我们以 measureVertical() 为例，来看一下 LinearLayout 在垂直方向上面是如何进行测量的。这段代码比较长，我们只截取其中的一部分来进行分析： void measureVertical(int widthMeasureSpec, int heightMeasureSpec) { // ... // 获取LinearLayout的测量模式 final int widthMode = MeasureSpec.getMode(widthMeasureSpec); final int heightMode = MeasureSpec.getMode(heightMeasureSpec); // ... mTotalLength += mPaddingTop + mPaddingBottom; int heightSize = mTotalLength; heightSize = Math.max(heightSize, getSuggestedMinimumHeight()); // ... for (int i = 0; i &lt; count; ++i) { final View child = getVirtualChildAt(i); if (child == null || child.getVisibility() == View.GONE) { continue; } final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final float childWeight = lp.weight; if (childWeight &gt; 0) { // ... // 获取一个测量的数值和测量模式 final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( Math.max(0, childHeight), MeasureSpec.EXACTLY); final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width); // 调用子元素进行测量 child.measure(childWidthMeasureSpec, childHeightMeasureSpec); childState = combineMeasuredStates(childState, child.getMeasuredState() &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT)); } final int margin = lp.leftMargin + lp.rightMargin; final int measuredWidth = child.getMeasuredWidth() + margin; maxWidth = Math.max(maxWidth, measuredWidth); boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT; alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth); allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT; final int totalLength = mTotalLength; // 将宽度增加到 mTotalLength 上 mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child)); } mTotalLength += mPaddingTop + mPaddingBottom; // ... maxWidth += mPaddingLeft + mPaddingRight; maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); // 最终确定测量的大小 setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState); // ... } 上面是 LinearLayout 在垂直方向上面的测量的过程，在测量的时候会根据子元素的布局将子元素的测量高度添加到 mTotalLength 上，然后再加上填充的大小，作为最终的测量结果。 3、layout() layout() 用于确定控件的位置，它提供了 onLayout() 来交给字类实现，同样我们在自定义控件的时候只要实现 onLayout() 方法即可。在我们自定义 View 的时候，如果定义的是非 ViewGroup 类型的控件，一般是不需要覆写 onLayout() 方法的。 下面我们先看一下 layout() 方法在 View 中的实现： public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { onLayout(changed, l, t, r, b); // ... } // ... } 这里会调用 setFrame() 方法，它的主要作用是根据新的布局参数和老的布局参数做一个对比，以判断控件的大小是否发生了变化，如果变化了的话就调用 invalidate() 方法并传入参数 true，以表明绘图的缓存也发生了变化。这里就不给出这个方法的具体实现了。然后注意到，在 layout() 方法中会回调 onLayout() 方法来完成各个控件的位置的确定。 对于 ViewGroup，它重写了 layout() 并在其中调用了 View 中的 layout() 方法，不过整体并没有做太多的逻辑。与测量过程类似，ViewGroup 并没有实现 onLayout 方法。同样，对于 ViewGroup 类型的控件，我们还是以 LinearLayout 为例说明一下 onLayout() 的实现逻辑： 与测量过程类似，LinearLayout 在 layout 的时候也根据布局的方向分成两种情形： protected void onLayout(boolean changed, int l, int t, int r, int b) { if (mOrientation == VERTICAL) { layoutVertical(l, t, r, b); } else { layoutHorizontal(l, t, r, b); } } 这里我们仍以垂直方向的方法为例。与测量的过程相比，layout 的过程的显得简单、清晰得多： void layoutVertical(int left, int top, int right, int bottom) { // ... // 根据控件的 gravity 特点得到顶部的位置 switch (majorGravity) { case Gravity.BOTTOM: childTop = mPaddingTop + bottom - top - mTotalLength; break; case Gravity.CENTER_VERTICAL: childTop = mPaddingTop + (bottom - top - mTotalLength) / 2; break; case Gravity.TOP: default: childTop = mPaddingTop; break; } // 遍历子控件 for (int i = 0; i &lt; count; i++) { final View child = getVirtualChildAt(i); if (child == null) { childTop += measureNullChild(i); } else if (child.getVisibility() != GONE) { final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); int gravity = lp.gravity; if (gravity &lt; 0) { gravity = minorGravity; } final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); // 得到子控件的左边的位置 switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) { case Gravity.CENTER_HORIZONTAL: childLeft = paddingLeft + ((childSpace - childWidth) / 2) + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: childLeft = childRight - childWidth - lp.rightMargin; break; case Gravity.LEFT: default: childLeft = paddingLeft + lp.leftMargin; break; } if (hasDividerBeforeChildAt(i)) { childTop += mDividerHeight; } childTop += lp.topMargin; // 本质上调用子控件的 layout() 方法 setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child, i); } } } 因为布局方向是垂直方向的，所以在对子元素进行遍历之前，先对自身的顶部的位置进行计算，然后再依次遍历子元素，并对顶部的高度不断叠加，最后调用 setChildFrame() 方法: private void setChildFrame(View child, int left, int top, int width, int height) { child.layout(left, top, left + width, top + height); } 这样就完成了对整个 View 树的 layout() 方法的调用。 4、draw()View 的 draw() 方法实现的逻辑也很清晰。在绘制的过程会按照如下的步骤进行： 绘制背景 保存 canvas 绘制自身的内容 绘制子控件 绘制 View 的褪色边缘，比如阴影效果之类的 绘制装饰，比如滚动条之类的 View 中提供了 onDraw() 方法用来完成对自身的内容的绘制，所以，我们自定义 View 的时候只要重写这个方法就可以了。当我们要自定义一个 ViewGroup 类型的控件的时候，一般是不需要重写 onDraw() 方法的，因为它只需要遍历子控件并依次调用它们的 draw() 方法就可以了。（当然，如果非要实现的话，也是可以的。） 下面是这部分代码，代码的注释中也详细注释了每个步骤的逻辑： public void draw(Canvas canvas) { final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) { drawBackground(canvas); } // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) { // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); drawAutofilledHighlight(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) { mOverlay.getOverlayView().dispatchDraw(canvas); } // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // Step 7, draw the default focus highlight drawDefaultFocusHighlight(canvas); if (debugDraw()) { debugDrawFocus(canvas); } // we&apos;re done... return; } // ... } 注意到在上面的方法中会调用 dispatchDraw(canvas) 方法来分发绘制事件给子控件来完成整个 View 树的绘制。在 View 中，这是一个空的方法，ViewGroup 覆写了这个方法，并在其中调用 drawChild() 来完成对指定的 View 的 draw() 方法的调用： protected boolean drawChild(Canvas canvas, View child, long drawingTime) { return child.draw(canvas, this, drawingTime); } 而对于 LinearLayout 这样本身没有绘制需求的控件，没有覆写 onDraw() 和 dispatchDraw(canvas) 等方法，因为 View 和 ViewGroup 中提供的功能已经足够使用。 总结：上文中，我们介绍了在 Android 系统中整个 View 树的工作的流程，从 DecorView 被加载到窗口中，到测量、布局和绘制三个方法的实现。本质上整个工作的流程就是对 View 树的一个深度优先的遍历过程。]]></content>
      <categories>
        <category>Android控件详解</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>控件体系</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
</search>
