<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Andriod 网络框架 OkHttp 源码解析]]></title>
    <url>%2F2018%2F10%2F17%2FAndriod%20%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%20OkHttp%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1、OkHttp 的基本使用OkHttp 是 Square 的一款应用于 Android 和 Java 的 Http 和 Http/2 客户端。使用的时候只需要在 Gradle 里面加入下面一行依赖即可引入： implementation &apos;com.squareup.okhttp3:okhttp:3.11.0&apos; 我们知道，Http 请求有多种类型，常用的分为 Get 和 Post，而 POST 又分为 Form 和 Multiple 等。下面我们以 Form 类型的请求为例来看下 OkHttp 的 API 设计逻辑： OkHttpClient internalHttpClient = new OkHttpClient(); FormBody.Builder formBodyBuilder = new FormBody.Builder(); RequestBody body = formBodyBuilder.build(); Request.Builder builder = new Request.Builder().url(&quot;host:port/url&quot;).post(body); Request request = builder.build(); Response response = internalHttpClient.newCall(request).execute(); String retJson = response.body().string(); 这里我们先用了 FormBody 的构建者模式创建 Form 类型请求的请求体，然后使用 Request 的构建者创建完整的 Form 请求。之后，我们用创建好的 OkHttp 客户端 internalHttpClient 来获取一个请求，并从请求的请求体中获取 Json 数据。 根据 OkHttp 的 API，如果我们希望发送一个 Multipart 类型的请求的时候就需要使用 MultipartBody 的构建者创建 Multipart 请求的请求体。然后同样使用 Request 的构建者创建完整的 Multipart 请求，剩下的逻辑相同。 除了使用上面的直接实例化一个 OkHttp 客户端的方式，我们也可以使用 OkHttpClient 的构建者 OkHttpClient.Builder 来创建 OkHttp 客户端。 所以，我们可以总结： OkHttp 为不同的请求类型都提供了一个构建者方法用来创建请求体 RequestBody； 因为请求体只是整个请求的一部分，所以，又要用 Request.Builder 构建一个请求对象 Request； 这样我们得到了一个完整的 Http 请求，然后使用 OkHttpClient 对象进行网络访问得到响应对象 Response。 OkHttp 本身的设计比较友好，思路非常清晰，按照上面的思路搞懂了人家的 API 设计逻辑，自己再基于 OkHttp 封装一个库自然问题不大。 2、OkHttp 源码分析上面我们提到的一些是基础的 API 类，是提供给用户使用的。这些类的设计只是基于构建者模式，非常容易理解。这里我们关注点也不在这些 API 类上面，而是 OkHttp 内部的请求执行相关的类。下面我们就开始对 OkHttp 的请求过程进行源码分析（源码版本：3.10.0）。 2.1 一个请求的大致流程参考之前的示例程序，抛弃构建请求的过程不讲，单从请求的发送过程来看，我们的线索应该从 OkHttpClient.newCall(Request) 开始。下面是这个方法的定义，它会创建一个 RealCall 对象，并把 OkHttpClient 对象和 Request 对象作为参数传入进去： @Override public Call newCall(Request request) { return RealCall.newRealCall(this, request, false /* for web socket */); } 然后，RealCall 调用内部的静态方法 newRealCall 在其中创建一个 RealCall 实例并将其返回： static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { RealCall call = new RealCall(client, originalRequest, forWebSocket); call.eventListener = client.eventListenerFactory().create(call); return call; } 然后，当返回了 RealCall 之后，我们又会调用它的 execute() 方法来获取响应结果，下面是这个方法的定义： @Override public Response execute() throws IOException { synchronized (this) { if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; } captureCallStackTrace(); eventListener.callStart(this); try { // 加入到一个双端队列中 client.dispatcher().executed(this); // 从这里拿的响应Response Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(&quot;Canceled&quot;); return result; } catch (IOException e) { eventListener.callFailed(this, e); throw e; } finally { client.dispatcher().finished(this); } } 这里我们会用 client 对象（实际也就是上面创建 RealCall 的时候传入的 OkHttpClient）的 dispatcher() 方法来获取一个 Dispatcher 对象，并调用它的 executed() 方法来将当前的 RealCall 加入到一个双端队列中，下面是 executed(RealCall) 方法的定义，这里的 runningSyncCalls 的类型是 Deque&lt;RealCall&gt;： synchronized void executed(RealCall call) { runningSyncCalls.add(call); } 让我们回到上面的 execute() 方法，在把 RealCall 加入到双端队列之后，我们又调用了 getResponseWithInterceptorChain() 方法，下面就是该方法的定义。 Response getResponseWithInterceptorChain() throws IOException { // 添加一系列拦截器，注意添加的顺序 List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); // 桥拦截器 interceptors.add(new BridgeInterceptor(client.cookieJar())); // 缓存拦截器：从缓存中拿数据 interceptors.add(new CacheInterceptor(client.internalCache())); // 网络连接拦截器：建立网络连接 interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) { interceptors.addAll(client.networkInterceptors()); } // 服务器请求拦截器：向服务器发起请求获取数据 interceptors.add(new CallServerInterceptor(forWebSocket)); // 构建一条责任链 Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); // 处理责任链 return chain.proceed(originalRequest); } 这里，我们创建了一个列表对象之后把 client 中的拦截器、重连拦截器、桥拦截器、缓存拦截器、网络连接拦截器和服务器请求拦截器等依次加入到列表中。然后，我们用这个列表创建了一个拦截器链。这里使用了责任链设计模式，每当一个拦截器执行完毕之后会调用下一个拦截器或者不调用并返回结果。显然，我们最终拿到的响应就是这个链条执行之后返回的结果。当我们自定义一个拦截器的时候，也会被加入到这个拦截器链条里。 这里我们遇到了很多的新类，比如 RealCall、Dispatcher 以及责任链等。下文中，我们会对这些类之间的关系以及责任链中的环节做一个分析，而这里我们先对整个请求的流程做一个大致的梳理。 2.2 分发器 Dispatcher上面我们提到了 Dispatcher 这个类，它的作用是对请求进行分发。以最开始的示例代码为例，在使用 OkHttp 的时候，我们会创建一个 RealCall 并将其加入到双端队列中。但是请注意这里的双端队列的名称是 runningSyncCalls，也就是说这种请求是同步请求，会在当前的线程中立即被执行。所以，下面的 getResponseWithInterceptorChain() 就是这个同步的执行过程。而当我们执行完毕的时候，又会调用 Dispatcher 的 finished(RealCall) 方法把该请求从队列中移除。所以，这种同步的请求无法体现分发器的“分发”功能。 除了同步的请求，还有异步类型的请求：当我们拿到了 RealCall 的时候，调用它的 enqueue(Callback responseCallback) 方法并设置一个回调即可。该方法会执行下面这行代码： client.dispatcher().enqueue(new AsyncCall(responseCallback)); 即使用上面的回调创建一个 AsyncCall 并调用 enqueue(AsyncCall)。这里的 AsyncCall 间接继承自 Runnable，是一个可执行的对象，并且会在 Runnable 的 run() 方法里面调用 AsyncCall 的 execute() 方法。AsyncCall 的 execute() 方法与 RealCall 的 execute() 方法类似，都使用责任链来完成一个网络请求。只是后者可以放在一个异步的线程中进行执行。 当我们调用了 Dispatcher 的 enqueue(AsyncCall) 方法的时候也会将 AsyncCall 加入到一个队列中，并会在请求执行完毕的时候从该队列中移除，只是这里的队列是 runningAsyncCalls 或者 readyAsyncCalls。它们都是一个双端队列，并用来存储异步类型的请求。它们的区别是，runningAsyncCalls 是正在执行的队列，当正在执行的队列达到了限制的时候，就会将其放置到就绪队列 readyAsyncCalls 中： synchronized void enqueue(AsyncCall call) { if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) { runningAsyncCalls.add(call); executorService().execute(call); } else { readyAsyncCalls.add(call); } } 当把该请求加入到了正在执行的队列之后，我们会立即使用一个线程池来执行该 AsyncCall。这样这个请求的责任链就会在一个线程池当中被异步地执行了。这里的线程池由 executorService() 方法返回： public synchronized ExecutorService executorService() { if (executorService == null) { executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false)); } return executorService; } 显然，当线程池不存在的时候会去创建一个线程池。除了上面的这种方式，我们还可以在构建 OkHttpClient 的时候，自定义一个 Dispacher，并在其构造方法中为其指定一个线程池。 以上就是分发器 Dispacher 的逻辑，看上去并没有那么复杂。并且从上面的分析中，我们可以看出实际请求的执行过程并不是在这里完成的，这里只能决定在哪个线程当中执行请求并把请求用双端队列缓存下来，而实际的请求执行过程是在责任链中完成的。下面我们就来分析一下 OkHttp 里的责任链的执行过程。 2.3 责任链的执行过程在典型的责任链设计模式里，很多对象由每一个对象对其下级的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。责任链在现实生活中的一种场景就是面试，当某轮面试官觉得你没有资格进入下一轮的时候可以否定你，不然会让下一轮的面试官继续面试。 在 OkHttp 里面，责任链的执行模式与之稍有不同。这里我们主要来分析一下在 OkHttp 里面，责任链是如何执行的，至于每个链条里面的具体逻辑，我们会在随后一一说明。 回到 2.1 的代码，有两个地方需要我们注意： 是当创建一个责任链 RealInterceptorChain 的时候，我们传入的第 5 个参数是 0。该参数名为 index，会被赋值给 RealInterceptorChain 实例内部的同名全局变量。 当启用责任链的时候，会调用它的 proceed(Request) 方法。 下面是 proceed(Request) 方法的定义： @Override public Response proceed(Request request) throws IOException { return proceed(request, streamAllocation, httpCodec, connection); } 这里又调用了内部的重载的 proceed() 方法。下面我们对该方法进行了简化： public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException { if (index &gt;= interceptors.size()) throw new AssertionError(); // ... // 调用责任链的下一个拦截器 RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); // ... return response; } 注意到这里使用责任链进行处理的时候，会新建下一个责任链并把 index+! 作为下一个责任链的 index。然后，我们使用 index 从拦截器列表中取出一个拦截器，调用它的 intercept() 方法，并把下一个执行链作为参数传递进去。 这样，当下一个拦截器希望自己的下一级继续处理这个请求的时候，可以调用传入的责任链的 proceed() 方法；如果自己处理完毕之后，下一级不需要继续处理，那么就直接返回一个 Response 实例即可。因为，每次都是在当前的 index 基础上面加 1，所以能在调用 proceed() 的时候准确地从拦截器列表中取出下一个拦截器进行处理。 我们还要注意的地方是之前提到过重试拦截器，这种拦截器会在内部启动一个 while 循环，并在循环体中调用执行链的 proceed() 方法来实现请求的不断重试。这是因为在它那里的拦截器链的 index 是固定的，所以能够每次调用 proceed() 的时候，都能够从自己的下一级执行一遍链条。 清楚了 OkHttp 的拦截器链的执行过程之后，我们来看一下各个拦截器做了什么逻辑。 2.3 重试和重定向：RetryAndFollowUpInterceptorRetryAndFollowUpInterceptor 主要用来当请求失败的时候进行重试，以及在需要的情况下进行重定向。我们上面说，责任链会在进行处理的时候调用第一个拦截器的 intercept() 方法。如果我们在创建 OkHttp 客户端的时候没有加入自定义拦截器，那么RetryAndFollowUpInterceptor 就是我们的责任链中最先被调用的拦截器。 @Override public Response intercept(Chain chain) throws IOException { // ... // 注意这里我们初始化了一个 StreamAllocation 并赋值给全局变量，它的作用我们后面会提到 StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; // 用来记录重定向的次数 int followUpCount = 0; Response priorResponse = null; while (true) { if (canceled) { streamAllocation.release(); throw new IOException(&quot;Canceled&quot;); } Response response; boolean releaseConnection = true; try { // 这里从当前的责任链开始执行一遍责任链，是一种重试的逻辑 response = realChain.proceed(request, streamAllocation, null, null); releaseConnection = false; } catch (RouteException e) { // 调用 recover 方法从失败中进行恢复，如果可以恢复就返回true，否则返回false if (!recover(e.getLastConnectException(), streamAllocation, false, request)) { throw e.getLastConnectException(); } releaseConnection = false; continue; } catch (IOException e) { // 重试与服务器进行连接 boolean requestSendStarted = !(e instanceof ConnectionShutdownException); if (!recover(e, streamAllocation, requestSendStarted, request)) throw e; releaseConnection = false; continue; } finally { // 如果 releaseConnection 为 true 则表明中间出现了异常，需要释放资源 if (releaseConnection) { streamAllocation.streamFailed(null); streamAllocation.release(); } } // 使用之前的响应 priorResponse 构建一个响应，这种响应的响应体 body 为空 if (priorResponse != null) { response = response.newBuilder() .priorResponse(priorResponse.newBuilder().body(null).build()) .build(); } // 根据得到的响应进行处理，可能会增加一些认证信息、重定向或者处理超时请求 // 如果该请求无法继续被处理或者出现的错误不需要继续处理，将会返回 null Request followUp = followUpRequest(response, streamAllocation.route()); // 无法重定向，直接返回之前的响应 if (followUp == null) { if (!forWebSocket) { streamAllocation.release(); } return response; } // 关闭资源 closeQuietly(response.body()); // 达到了重定向的最大次数，就抛出一个异常 if (++followUpCount &gt; MAX_FOLLOW_UPS) { streamAllocation.release(); throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount); } if (followUp.body() instanceof UnrepeatableRequestBody) { streamAllocation.release(); throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code()); } // 这里判断新的请求是否能够复用之前的连接，如果无法复用，则创建一个新的连接 if (!sameConnection(response, followUp.url())) { streamAllocation.release(); streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(followUp.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; } else if (streamAllocation.codec() != null) { throw new IllegalStateException(&quot;Closing the body of &quot; + response + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;); } request = followUp; priorResponse = response; } } 以上的代码主要用来根据错误的信息做一些处理，会根据服务器返回的信息判断这个请求是否可以重定向，或者是否有必要进行重试。如果值得去重试就会新建或者复用之前的连接在下一次循环中进行请求重试，否则就将得到的请求包装之后返回给用户。这里，我们提到了 StreamAllocation 对象，它相当于一个管理类，维护了服务器连接、并发流和请求之间的关系，该类还会初始化一个 Socket 连接对象，获取输入/输出流对象。同时，还要注意这里我们通过 client.connectionPool() 传入了一个连接池对象 ConnectionPool。这里我们只是初始化了这些类，但实际在当前的方法中并没有真正用到这些类，而是把它们传递到下面的拦截器里来从服务器中获取请求的响应。稍后，我们会说明这些类的用途，以及之间的关系。 2.4 BridgeInterceptor桥拦截器 BridgeInterceptor 用于从用户的请求中构建网络请求，然后使用该请求访问网络，最后从网络响应当中构建用户响应。相对来说这个拦截器的逻辑比较简单，只是用来对请求进行包装，并将服务器响应转换成用户友好的响应： public final class BridgeInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request userRequest = chain.request(); // 从用户请求中获取网络请求构建者 Request.Builder requestBuilder = userRequest.newBuilder(); // ... // 执行网络请求 Response networkResponse = chain.proceed(requestBuilder.build()); // ... // 从网络响应中获取用户响应构建者 Response.Builder responseBuilder = networkResponse.newBuilder().request(userRequest); // ... // 返回用户响应 return responseBuilder.build(); } } 2.5 使用缓存：CacheInterceptor缓存拦截器会根据请求的信息和缓存的响应的信息来判断是否存在缓存可用，如果有可以使用的缓存，那么就返回该缓存该用户，否则就继续责任链来从服务器中获取响应。当获取到响应的时候，又会把响应缓存到磁盘上面。以下是这部分的逻辑： public final class CacheInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); // 根据请求和缓存的响应中的信息来判断是否存在缓存可用 CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; // 如果该请求没有使用网络就为空 Response cacheResponse = strategy.cacheResponse; // 如果该请求没有使用缓存就为空 if (cache != null) { cache.trackResponse(strategy); } if (cacheCandidate != null &amp;&amp; cacheResponse == null) { closeQuietly(cacheCandidate.body()); } // 请求不使用网络并且不使用缓存，相当于在这里就拦截了，没必要交给下一级（网络请求拦截器）来执行 if (networkRequest == null &amp;&amp; cacheResponse == null) { return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message(&quot;Unsatisfiable Request (only-if-cached)&quot;) .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); } // 该请求使用缓存，但是不使用网络：从缓存中拿结果，没必要交给下一级（网络请求拦截器）执行 if (networkRequest == null) { return cacheResponse.newBuilder().cacheResponse(stripBody(cacheResponse)).build(); } Response networkResponse = null; try { // 这里调用了执行链的处理方法，实际就是交给自己的下一级来执行了 networkResponse = chain.proceed(networkRequest); } finally { if (networkResponse == null &amp;&amp; cacheCandidate != null) { closeQuietly(cacheCandidate.body()); } } // 这里当拿到了网络请求之后调用，下一级执行完毕会交给它继续执行，如果使用了缓存就把请求结果更新到缓存里 if (cacheResponse != null) { // 服务器返回的结果是304，返回缓存中的结果 if (networkResponse.code() == HTTP_NOT_MODIFIED) { Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); cache.trackConditionalCacheHit(); // 更新缓存 cache.update(cacheResponse, response); return response; } else { closeQuietly(cacheResponse.body()); } } Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); // 把请求的结果放进缓存里 if (cache != null) { if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) { CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); } if (HttpMethod.invalidatesCache(networkRequest.method())) { try { cache.remove(networkRequest); } catch (IOException ignored) { // The cache cannot be written. } } } return response; } } 对缓存，这里我们使用的是全局变量 cache，它是 InternalCache 类型的变量。InternalCache 是一个接口，在 OkHttp 中只有一个实现类 Cache。在 Cache 内部，使用了 DiskLruCache 来将缓存的数据存到磁盘上。DiskLruCache 以及 LruCache 是 Android 上常用的两种缓存策略。前者是基于磁盘来进行缓存的，后者是基于内存来进行缓存的，它们的核心思想都是 Least Recently Used，即最近最少使用算法。我们会在以后的文章中详细介绍这两种缓存框架，也请继续关注我们的文章。 另外，上面我们根据请求和缓存的响应中的信息来判断是否存在缓存可用的时候用到了 CacheStrategy 的两个字段，得到这两个字段的时候使用了非常多的判断，其中涉及 Http 缓存相关的知识，感兴趣的话可以自己参考源代码。 2.6 连接复用：ConnectInterceptor连接拦截器 ConnectInterceptor 用来打开到指定服务器的网络连接，并交给下一个拦截器处理。这里我们只打开了一个网络连接，但是并没有发送请求到服务器。从服务器获取数据的逻辑交给下一级的拦截器来执行。虽然，这里并没有真正地从网络中获取数据，而仅仅是打开一个连接，但这里有不少的内容值得我们去关注。因为在获取连接对象的时候，使用了连接池 ConnectionPool 来复用连接。 public final class ConnectInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;); HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection); } } 这里的 HttpCodec 用来编码请求并解码响应，RealConnection 用来向服务器发起连接。它们会在下一个拦截器中被用来从服务器中获取响应信息。下一个拦截器的逻辑并不复杂，这里万事具备之后，只要它来从服务器中读取数据即可。可以说，OkHttp 中的核心部分大概就在这里，所以，我们就先好好分析一下，这里在创建连接的时候如何借助连接池来实现连接复用的。 根据上面的代码，当我们调用 streamAllocation 的 newStream() 方法的时候，最终会经过一系列的判断到达 StreamAllocation 中的 findConnection() 方法。 private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException { // ... synchronized (connectionPool) { // ... // 尝试使用已分配的连接，已经分配的连接可能已经被限制创建新的流 releasedConnection = this.connection; // 释放当前连接的资源，如果该连接已经被限制创建新的流，就返回一个Socket以关闭连接 toClose = releaseIfNoNewStreams(); if (this.connection != null) { // 已分配连接，并且该连接可用 result = this.connection; releasedConnection = null; } if (!reportedAcquired) { // 如果该连接从未被标记为获得，不要标记为发布状态，reportedAcquired 通过 acquire() 方法修改 releasedConnection = null; } if (result == null) { // 尝试供连接池中获取一个连接 Internal.instance.get(connectionPool, address, this, null); if (connection != null) { foundPooledConnection = true; result = connection; } else { selectedRoute = route; } } } // 关闭连接 closeQuietly(toClose); if (releasedConnection != null) { eventListener.connectionReleased(call, releasedConnection); } if (foundPooledConnection) { eventListener.connectionAcquired(call, result); } if (result != null) { // 如果已经从连接池中获取到了一个连接，就将其返回 return result; } boolean newRouteSelection = false; if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection.hasNext())) { newRouteSelection = true; routeSelection = routeSelector.next(); } synchronized (connectionPool) { if (canceled) throw new IOException(&quot;Canceled&quot;); if (newRouteSelection) { // 根据一系列的 IP 地址从连接池中获取一个链接 List&lt;Route&gt; routes = routeSelection.getAll(); for (int i = 0, size = routes.size(); i &lt; size; i++) { Route route = routes.get(i); // 从连接池中获取一个连接 Internal.instance.get(connectionPool, address, this, route); if (connection != null) { foundPooledConnection = true; result = connection; this.route = route; break; } } } if (!foundPooledConnection) { if (selectedRoute == null) { selectedRoute = routeSelection.next(); } // 创建一个新的连接，并将其分配，这样我们就可以在握手之前进行终端 route = selectedRoute; refusedStreamCount = 0; result = new RealConnection(connectionPool, selectedRoute); acquire(result, false); } } // 如果我们在第二次的时候发现了一个池连接，那么我们就将其返回 if (foundPooledConnection) { eventListener.connectionAcquired(call, result); return result; } // 进行 TCP 和 TLS 握手 result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, call, eventListener); routeDatabase().connected(result.route()); Socket socket = null; synchronized (connectionPool) { reportedAcquired = true; // 将该连接放进连接池中 Internal.instance.put(connectionPool, result); // 如果同时创建了另一个到同一地址的多路复用连接，释放这个连接并获取那个连接 if (result.isMultiplexed()) { socket = Internal.instance.deduplicate(connectionPool, address, this); result = connection; } } closeQuietly(socket); eventListener.connectionAcquired(call, result); return result; } 该方法会被放置在一个循环当中被不停地调用以得到一个可用的连接。它优先使用当前已经存在的连接，不然就使用连接池中存在的连接，再不行的话，就创建一个新的连接。所以，上面的代码大致分成三个部分： 判断当前的连接是否可以使用：流是否已经被关闭，并且已经被限制创建新的流； 如果当前的连接无法使用，就从连接池中获取一个连接； 连接池中也没有发现可用的连接，创建一个新的连接，并进行握手，然后将其放到连接池中。 在从连接池中获取一个连接的时候，使用了 Internal 的 get() 方法。Internal 有一个静态的实例，会在 OkHttpClient 的静态代码快中被初始化。我们会在 Internal 的 get() 中调用连接池的 get() 方法来得到一个连接。 从上面的代码中我们也可以看出，实际上，我们使用连接复用的一个好处就是省去了进行 TCP 和 TLS 握手的一个过程。因为建立连接本身也是需要消耗一些时间的，连接被复用之后可以提升我们网络访问的效率。那么这些连接被放置在连接池之后是如何进行管理的呢？我们会在下文中分析 OkHttp 的 ConnectionPool 中是如何管理这些连接的。 2.7 CallServerInterceptor服务器请求拦截器 CallServerInterceptor 用来向服务器发起请求并获取数据。这是整个责任链的最后一个拦截器，这里没有再继续调用执行链的处理方法，而是把拿到的响应处理之后直接返回给了上一级的拦截器： public final class CallServerInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { RealInterceptorChain realChain = (RealInterceptorChain) chain; // 获取 ConnectInterceptor 中初始化的 HttpCodec HttpCodec httpCodec = realChain.httpStream(); // 获取 RetryAndFollowUpInterceptor 中初始化的 StreamAllocation StreamAllocation streamAllocation = realChain.streamAllocation(); // 获取 ConnectInterceptor 中初始化的 RealConnection RealConnection connection = (RealConnection) realChain.connection(); Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); realChain.eventListener().requestHeadersStart(realChain.call()); // 在这里写入请求头 httpCodec.writeRequestHeaders(request); realChain.eventListener().requestHeadersEnd(realChain.call(), request); Response.Builder responseBuilder = null; if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) { if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) { httpCodec.flushRequest(); realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(true); } // 在这里写入请求体 if (responseBuilder == null) { realChain.eventListener().requestBodyStart(realChain.call()); long contentLength = request.body().contentLength(); CountingSink requestBodyOut = new CountingSink(httpCodec.createRequestBody(request, contentLength)); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); // 写入请求体 request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); realChain.eventListener() .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount); } else if (!connection.isMultiplexed()) { streamAllocation.noNewStreams(); } } httpCodec.finishRequest(); if (responseBuilder == null) { realChain.eventListener().responseHeadersStart(realChain.call()); // 读取响应头 responseBuilder = httpCodec.readResponseHeaders(false); } Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); // 读取响应体 int code = response.code(); if (code == 100) { responseBuilder = httpCodec.readResponseHeaders(false); response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); code = response.code(); } realChain.eventListener().responseHeadersEnd(realChain.call(), response); if (forWebSocket &amp;&amp; code == 101) { response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); } else { response = response.newBuilder() .body(httpCodec.openResponseBody(response)) .build(); } // ... return response; } } 2.8 连接管理：ConnectionPool与请求的缓存类似，OkHttp 的连接池也使用一个双端队列来缓存已经创建的连接： private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;(); OkHttp 的缓存管理分成两个步骤，一边当我们创建了一个新的连接的时候，我们要把它放进缓存里面；另一边，我们还要来对缓存进行清理。在 ConnectionPool 中，当我们向连接池中缓存一个连接的时候，只要调用双端队列的 add() 方法，将其加入到双端队列即可，而清理连接缓存的操作则交给线程池来定时执行。 在 ConnectionPool 中存在一个静态的线程池： private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */, Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp ConnectionPool&quot;, true)); 每当我们向连接池中插入一个连接的时候就会调用下面的方法，将连接插入到双端队列的同时，会调用上面的线程池来执行清理缓存的任务： void put(RealConnection connection) { assert (Thread.holdsLock(this)); if (!cleanupRunning) { cleanupRunning = true; // 使用线程池执行清理任务 executor.execute(cleanupRunnable); } // 将新建的连接插入到双端队列中 connections.add(connection); } 这里的清理任务是 cleanupRunnable，是一个 Runnable 类型的实例。它会在方法内部调用 cleanup() 方法来清理无效的连接： private final Runnable cleanupRunnable = new Runnable() { @Override public void run() { while (true) { long waitNanos = cleanup(System.nanoTime()); if (waitNanos == -1) return; if (waitNanos &gt; 0) { long waitMillis = waitNanos / 1000000L; waitNanos -= (waitMillis * 1000000L); synchronized (ConnectionPool.this) { try { ConnectionPool.this.wait(waitMillis, (int) waitNanos); } catch (InterruptedException ignored) { } } } } } }; 下面是 cleanup() 方法： long cleanup(long now) { int inUseConnectionCount = 0; int idleConnectionCount = 0; RealConnection longestIdleConnection = null; long longestIdleDurationNs = Long.MIN_VALUE; synchronized (this) { // 遍历所有的连接 for (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) { RealConnection connection = i.next(); // 当前的连接正在使用中 if (pruneAndGetAllocationCount(connection, now) &gt; 0) { inUseConnectionCount++; continue; } idleConnectionCount++; // 如果找到了一个可以被清理的连接，会尝试去寻找闲置时间最久的连接来释放 long idleDurationNs = now - connection.idleAtNanos; if (idleDurationNs &gt; longestIdleDurationNs) { longestIdleDurationNs = idleDurationNs; longestIdleConnection = connection; } } if (longestIdleDurationNs &gt;= this.keepAliveDurationNs || idleConnectionCount &gt; this.maxIdleConnections) { // 该连接的时长超出了最大的活跃时长或者闲置的连接数量超出了最大允许的范围，直接移除 connections.remove(longestIdleConnection); } else if (idleConnectionCount &gt; 0) { // 闲置的连接的数量大于0，停顿指定的时间（等会儿会将其清理掉，现在还不是时候） return keepAliveDurationNs - longestIdleDurationNs; } else if (inUseConnectionCount &gt; 0) { // 所有的连接都在使用中，5分钟后再清理 return keepAliveDurationNs; } else { // 没有连接 cleanupRunning = false; return -1; } } closeQuietly(longestIdleConnection.socket()); return 0; } 在从缓存的连接中取出连接来判断是否应该将其释放的时候使用到了两个变量 maxIdleConnections 和 keepAliveDurationNs，分别表示最大允许的闲置的连接的数量和连接允许存活的最长的时间。默认空闲连接最大数目为5个，keepalive 时间最长为5分钟。 上面的方法会对缓存中的连接进行遍历，以寻找一个闲置时间最长的连接，然后根据该连接的闲置时长和最大允许的连接数量等参数来决定是否应该清理该连接。同时注意上面的方法的返回值是一个时间，如果闲置时间最长的连接仍然需要一段时间才能被清理的时候，会返回这段时间的时间差，然后会在这段时间之后再次对连接池进行清理。 总结：以上就是我们对 OkHttp 内部网络访问的源码的分析。当我们发起一个请求的时候会初始化一个 Call 的实例，然后根据同步和异步的不同，分别调用它的 execute() 和 enqueue() 方法。虽然，两个方法一个会在当前的线程中被立即执行，一个会在线程池当中执行，但是它们进行网络访问的逻辑都是一样的：通过拦截器组成的责任链，依次经过重试、桥接、缓存、连接和访问服务器等过程，来获取到一个响应并交给用户。其中，缓存和连接两部分内容是重点，因为前者涉及到了一些计算机网络方面的知识，后者则是 OkHttp 效率和框架的核心。]]></content>
      <categories>
        <category>Android网络访问</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>计算机网络</tag>
        <tag>OkHttp</tag>
        <tag>源码阅读</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 体系详解：坐标系、滑动事件和分发机制]]></title>
    <url>%2F2018%2F10%2F14%2FView%20%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E6%BB%91%E5%8A%A8%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1、位置1.1 坐标系下面是 Android 中的 View 坐标系的基本图。要获得一个 View 的位置，我们可以借助两个对象，一个是 View ，一个是 MotionEvent。以下是它们的一些方法的位置的含义： 在 View 中共有 mLeft, mRight, mTop 和 mBottom 四个变量包含 View 的坐标信息，你可以在源码中获取它们的含义： mLeft：指定控件的左边缘距离其父控件左边缘的位置，单位：像素； mRight：指定控件的右边缘距离其父控件左边缘的位置，单位：像素； mTop：指定控件的上边缘距离其父控件上边缘的位置，单位：像素； mBottom：指定控件的下边缘距离其父控件上边缘的位置，单位：像素。 此外，View 中还有几个方法用来获取控件的位置等信息，实际上就是上面四个变量的 getter 方法： getLeft()：即 mLeft； getRight()：即 mRight； getTop()：即 mTop； getBottom()：即 mBottom； 所以，我们可以得到两个获取 View 高度和宽度信息的方法： getHeight()：即 mBottom - mTop； getWidth()：即 mRight - mLeft； 另外，就是 View 中的 getX() 和 getY() 两个方法，你需要注意将其与 MotionEvent 中的同名方法进行区分。在没有对控件进行平移的时候，getX() 与 getLeft() 返回结果相同，只是前者会在后者的基础上加上平移的距离： getX()：即 mLeft + getTranslationX()，即控件的左边缘加上 X 方向平移的距离； getY()：即 mTop + getTranslationY()，即控件的上边缘加上 Y 方向平移的距离； 以上是我们对 View 中获取控件位置的方法的梳理，你可以到源码中查看它们更加相详尽的定义，那更有助于自己的理解。 1.2 MotionEvent通常当你对控件进行触摸监听的时候会用到 MotionEvent ，它封住了触摸的位置等信息。下面我们对 MotionEvent 中的获取点击事件的位置的方法进行梳理，它主要涉及下面四个方法： MotionEvent.getX()：获取点击事件距离控件左边缘的距离，单位：像素； MotionEvent.getY()：获取点击事件距离控件上边缘的距离，单位：像素； MotionEvent.getRawX()：获取点击事件距离屏幕左边缘的距离，单位：像素； MotionEvent.getRawY()：获取点击事件距离屏幕上边缘的距离，单位：像素。 另外是触摸事件中的三种典型的行为，按下、移动和抬起。接下来的代码示例中我们会用到它们来判断手指的行为，并对其做响应的处理： MotionEvent.ACTION_DOWN：按下的行为； MotionEvent.ACTION_MOVE：手指在屏幕上移动的行为； MotionEvent.ACTION_UP：手指抬起的行为。 2、滑动我们有几种方式实现 View 的滑动： 2.1 layout() 方法调用控件的 layout() 方法进行滑动，下面是该方法的定义： 1public void layout(int l, int t, int r, int b) &#123; /*...*/ &#125; 其中的四个参数 l, t, r, b分别表示控件相对于父控件的左、上、右、下的距离，分别对应于上面的 mLeft, mTop, mRight 和 mBottom。所以，调用该方法同时可以改变控件的高度和宽度，但有时候我们不需要改变控件的高度和宽度，只要移动其位置即可。所以，我们又有方法 offsetLeftAndRight() 和 offsetTopAndBottom() 可以使用，后者只会对控件的位置进行平移。因此，我们可以进行如下的代码测试： private int lastX, lastY; private void layoutMove(MotionEvent event) { int x = (int) event.getX(), y = (int) event.getY(); switch (event.getAction()) { case MotionEvent.ACTION_DOWN: lastX = x; lastY = y; break; case MotionEvent.ACTION_MOVE: int offsetX = x - lastX, offsetY = y - lastY; getBinding().v.layout(getBinding().v.getLeft() + offsetX, getBinding().v.getTop() + offsetY, getBinding().v.getRight() + offsetX, getBinding().v.getBottom() + offsetY); break; case MotionEvent.ACTION_UP: break; } } 上面的代码的效果是指定的控件会随着手指的移动而移动。这里我们先记录下按下的位置，然后手指移动的时候记录下平移的位置，最后调用 layout() 即可。 2.2 offsetLeftAndRight() 和 offsetTopAndBottom()上面已经提到过这两个方法，它们只改变控件的位置，无法改变大小。我们只需要对上述代码做少量修改就可以实现同样的效果： getBinding().v.offsetLeftAndRight(offsetX); getBinding().v.offsetTopAndBottom(offsetY); 2.3 改变布局参数通过获取并修改控件的 LayoutParams，我们一样可以达到修改控件的位置的目的。毕竟，本身这个对象就代表着控件的布局： FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) getBinding().v.getLayoutParams(); lp.leftMargin = getBinding().v.getLeft() + offsetX; lp.topMargin = getBinding().v.getTop() + offsetY; getBinding().v.setLayoutParams(lp); 2.4 动画使用动画我们也可以实现控件移动的效果，这里所谓的动画主要是操作 View 的 transitionX 和 transitionY 属性： getBinding().v.animate().translationX(5f); getBinding().v.animate().translationY(5f); 关于动画的内容，我们会在后面详细介绍。 2.5 scrollTo() 和 scrollBy()scrollBy() 方法内部调用了 scrollTo()，以下是这部分的源码。scrollBy() 表示在当前的位置上面进行平移，而 scrollTo() 表示平移到指定的位置： public void scrollBy(int x, int y) { scrollTo(mScrollX + x, mScrollY + y); } 同样对上述代码进行修改，我们也可以实现之前的效果： ((View) getBinding().v.getParent()).scrollBy(-offsetX, -offsetY); 或者 View parent = ((View) getBinding().v.getParent()); parent.scrollTo(parent.getScrollX()-offsetX, parent.getScrollY()-offsetY); 此外，还有一个需要注意的地方是：与上面的 offsetLeftAndRight() 和 offsetTopAndBottom() 不同的是，这里我们用了平移的值的相反数。原因很简单，因为我们要使用这两个方法的时候需要对指定的控件所在的父容器进行调用（正如上面是先获取父控件）。当我们希望控件相对于之前的位置向右下方向移动，就应该让父容器相对于之前的位置向左上方向移动。因为实际上该控件相对于父控件的位置没有发生变化，变化的是父控件的位置。（参考的坐标系不同） 2.6 Scroller上面，我们的测试代码是让指定的控件随着手指移动，但是假如我们希望控件从一个位置移动到另一个位置呢？当然，它们也可以实现，但是这几乎就是在瞬间完成了整个操作，实际的UI效果肯定不会好。所以，为了让滑动的过程看起来更加流畅，我们可以借助 Scroller 来实现。 在使用 Scroller 之前，我们需要先实例化一个 Scroller ： private Scroller scroller = new Scroller(getContext()); 然后，我们需要覆写自定义控件的 computeScroll() 方法，这个方法会在绘制 View 的时候被调用。所以，这里的含义就是，当 View 重绘的时候会调用 computeScroll() 方法，而 computeScroll() 方法会判断是否需要继续滚动，如果需要继续滚动的时候就调用 invalidate() 方法，该方法会导致 View 进一步重绘。所以，也就是靠着这种不断进行重绘的方式实现了滚动的效果。 滑动效果最终结束的判断是通过 Scroller 的 computeScrollOffset() 方法实现的，当滚动停止的时候，该方法就会返回 false，这样不会继续调用 invalidate() 方法，因而也就不会继续绘制了。下面是该方法典型的覆写方式： @Override public void computeScroll() { super.computeScroll(); if (scroller.computeScrollOffset()) { ((View) getParent()).scrollTo(scroller.getCurrX(), scroller.getCurrY()); invalidate(); } } 然后，我们再加入一个滚动到指定位置的方法，在该方法内部我们使用了 2000ms 来指定完成整个滑动所需要的时间： public void smoothScrollTo(int descX, int descY) { scroller.startScroll(getScrollX(), getScrollY(), descX - getScrollX(), descY - getScrollY(), 2000); invalidate(); } 这样定义了之后，我们只需要在需要滚动的时候调用自定义 View 的 smoothScrollTo() 方法即可。 3、手势3.1 ViewConfiguration在类 ViewConfiguration 中定义了一些列的常量用来标志指定的行为，比如，TouchSlop 就是滑动的最小的距离。你可以通过 ViewConfiguration.get(context) 来获取 ViewConfiguration 实例，然后通过它的 getter 方法来获取这些常量的定义。 3.2 VelocityTrackerVelocityTracker 用来检测手指滑动的速率，它的使用非常简单。在使用之前，我们先使用它的静态方法 obtain() 获取一个实例，然后在 onTouch() 方法中调用它的 addMovement(MotionEvent) 方法： velocityTracker = VelocityTracker.obtain(); 随后，当我们想要获得速率的时候，先调用 computeCurrentVelocity(int) 传入一个时间片段，单位是毫秒，然后调用 getXVelocity() 和 getYVelocity() 分别获得在水平和竖直方向上的速率即可： velocityTracker.computeCurrentVelocity((int) duration); getBinding().tvVelocity.setText(&quot;X:&quot; + velocityTracker.getXVelocity() + &quot;\n&quot; + &quot;Y:&quot; + velocityTracker.getYVelocity()); 本质上，计算速率的时候是用指定时间的长度变化除以我们传入的时间片。当我们使用完了 VelocityTracker 之后，需要回收资源： velocityTracker.clear(); velocityTracker.recycle(); 3.3 GestureDectectorGestureDectector 用来检测手指的手势。在使用它之前我们需要先获取一个 GestureDetector 的实例： mGestureDetector = new GestureDetector(getContext(), new MyOnGestureListener()); 这里我们用了 GestureDetector 的构造方法，需要传入一个 OnGestureListener 对象。这里我们用了 MyOnGestureListener 实例。 MyOnGestureListener 是一个自定义的类，实现了 OnGestureListener 接口： private class MyOnGestureListener extends GestureDetector.SimpleOnGestureListener { @Override public boolean onSingleTapUp(MotionEvent e) { ToastUtils.makeToast(&quot;Click detected&quot;); return false; } @Override public void onLongPress(MotionEvent e) { LogUtils.d(&quot;Long press detected&quot;); } @Override public boolean onDoubleTap(MotionEvent e) { LogUtils.d(&quot;Double tab detected&quot;); return true; } @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) { LogUtils.d(&quot;Fling detected&quot;); return true; } } 在 MyOnGestureListener 中，我们覆写了它的一些方法。比如，单击、双击和长按等等，当检测到相应的手势的时候这些方法就会被调用。 然后，我们可以这样使用 GestureDetector，只要在控件的触摸事件回调中调用即可： getBinding().vg.setOnTouchListener((v, event) -&gt; { mGestureDetector.onTouchEvent(event); return true; }); 4、事件分发机制4.1 事件传递的过程当讨论事件分发机制的时候，我们首先要了解 Android 中 View 的组成结构。在 Android 中，一个 Activity 包含一个 PhoneWindow，当我们在 Activity 中调用 setContentView() 方法的时候，会调用该 PhoneWindow 的 setContentView() 方法，并在这个方法中生成一个 DecorView 作为 Activity 的跟 View。 根据上面的分析，当一个点击事件被触发的时候，首先接收到该事件的是 Activity。因为，Activity 覆盖了整个屏幕，我们需要先让它接收事件，然后它把事件传递给根 View 之后，再由根 View 向下继续传递。这样不断缩小搜索的范围，直到最顶层的 View。当然，任何的父容器都可以决定这个事件是不是要继续向下传递，因此，我们可以大致得到下面这个事件传递的图： 左边的图是一个 Activity 内部的 View 和 Window 的组织结构。右面的图可以看作它的切面图，其中的黑色箭头表示事件的传递过程。这里事件传递的过程是先从下到上，然后再从上到下。也就是从大到小，不断定位到触摸的控件，其中每个父容器可以决定是否将事件传递下去。（需要注意的地方是，如果一个父容器有多个子元素的话，那么在这些子元素中进行遍历的时候，顺序是从上往下的，也就是按照展示的顺序）。 上面我们分析了 Android 事件传递的过程，相信你有了一个大致的了解。但是，想要了解整个事件传递过程具体涉及了哪些方法、如何作用等，还需要我们对源码进行分析。 4.2 事件传递的原理当触摸事件发生的时候，首先会被 Activity 接收到，然后该 Activity 会通过其内部的 dispatchTouchEvent(MotionEvent) 将事件传递给内部的 PhoneWindow；接着 PhoneWindow 会把事件交给 DecorView，再由 DecorView 交给根 ViewGroup。剩下的事件传递就只在 ViewGroup 和 View 之间进行。我们可以通过覆写 Activity 的 dispatchTouchEvent(MotionEvent) 来阻止把事件传递给 PhoneWindow。实际上，在我们开发的时候不会对 Window 的事件传递方法进行重写，一般是对 ViewGroup 或者 View。所以，下面我们的分析只在这两种控件之间进行。 当讨论 View 的事件分发机制的时候，无外乎下面三个方法： boolean onInterceptTouchEvent(MotionEvent ev)：用来对事件进行拦截，该方法只存在于 ViewGroup 中。一般我们会通过覆写该方法来拦截触摸事件，使其不再继续传递给子 View。 boolean dispatchTouchEvent(MotionEvent event)：用来分发触摸事件，一般我们不覆写该方法，返回 true 则表示事件被处理了。在 View 中，它负责根据手势的类型和控件的状态对事件进行处理，会回调我们的 OnTouchListener 或者 OnClickListener；在 ViewGroup 中，该方法被覆写，它的责任是对事件进行分发，会对所有的子 View 进行遍历，决定是否将事件分发给指定的 View。 boolean onTouchEvent(MotionEvent event)：用于处理触摸事件，返回 true 表示触摸事件被处理了。ViewGroup 没有覆写该方法，故在 ViewGroup 中与 View 中的功能是一样的。需要注意的是，如果我们为控件设置了 OnTouchListener 并且在或者中返回了 true，那么这个方法不会被调用，也就是 OnTouchListener 比该方法的优先级较高。对我们开发来说，就是 OnTouchListener 比 OnClickListener 和 OnLongClickListener 的优先级要高。 于是，我们可以得到如下的伪代码。这段代码是存在于 ViewGroup 中的，也就是事件分发机制的核心代码： boolean dispatchTouchEvent(MotionEvent e) { boolean result; if (onInterceptTouchEvent(e)) { result = super.dispatchTouchEvent(e); } else { result = child.dispatchTouchEvent(e); } return result; } 按照上述分析，触摸事件经过 Activity 传递给根 ViewGroup 之后： 如果 ViewGourp 覆写了 onInterceptTouchEvent() 并且返回了 true 就表示希望拦截该方法，于是就把触摸事件交给当前 ViewGroup 进行处理（触发 OnTouchListener 或者 OnClickListener 等）；否则，会交给子元素的继续分发。如果该子元素是 ViewGroup 的话，就会在该子 View 中执行一遍上述逻辑，否则会在当前的子元素中对事件进行处理（触发 OnTouchListener 或者 OnClickListener 等）……就这样一层层地遍历下去，本质上是一个深度优先的搜索算法。 这里我们对整个事件分发机制的整体做了一个素描，在接下来的文章中我们会对各个方法的细节进行源码分析，为了防止您在接下来的行文中迷路，我们先把这个整体逻辑按下图进行描述： 4.3 事件传递的源码分析上述我们分析了事件分发机制的原理，下面我们通过源代码来更具体地了解这块是如何设计的。同样，我们的焦点也只在那三个需要重点关注的方法。 4.3.1 决定是否拦截事件首先，我们来看 ViewGroup 中的 dispatchTouchEvent(MotionEvent) 方法，我们节选了其一部分： @Override public boolean dispatchTouchEvent(MotionEvent ev) { // ... boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; if (actionMasked == MotionEvent.ACTION_DOWN) { // 1 // 这里表示如果是一个新的触摸事件就要重置所有的状态，其中包括将 mFirstTouchTarget 置为 null cancelAndClearTouchTargets(ev); resetTouchState(); } // 在这里检查是否拦截了事件，mFirstTouchTarget 是之前处理触摸事件的 View 的封装 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { // 这里判断该 ViewGroup 是否禁用了拦截，由 requestDisallowInterceptTouchEvent 设置 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); } else { intercepted = false; } } else { // 非按下事件并且 mFirstTouchTarget 为 null，说明判断过拦截的逻辑并且启用了拦截 intercepted = true; } // ... } // ... return handled; } 上面代码是我们节选的 ViewGroup 拦截事件的部分代码，这里的逻辑显然比伪代码复杂的多。不过，尽管如此，这些代码确实必不可少的。因为，当我们要去判断是否拦截一个触摸事件的时候，此时触摸的事件仍然在继续，这意味着这个方法会被持续调用；抬起的时候再按下，又是另一次调用。考虑到这个连续性，我们需要多做一些逻辑。 这里我们首先在 1 处通过行为是否是“按下”的来判断是否是一次新的触摸事件，如果是的话我们需要重置当前的触摸状态。其次，我们需要根据事件的类型来决定是否应该调用 onInterceptTouchEvent()，因为对一次触摸事件，我们只需要在“按下”的时候判断一次就够了。所以，显然我们需要将 MotionEvent.ACTION_DOWN 作为一个判断条件。然后，我们使用 mFirstTouchTarget 这个全局的变量来记录上次拦截的结果——如果之前的事件交给过子元素处理，那么它就不为空。 除了 mFirstTouchTarget，我们还需要用 mGroupFlags 的 FLAG_DISALLOW_INTERCEPT 标志位来判断该 ViewGroup 是否禁用了拦截。这个标志位可以通过 ViewGroup 的 requestDisallowInterceptTouchEvent(boolean) 来设置。只有没有禁用拦截事件的时候我们才需要调用 onInterceptTouchEvent() 判断是否开启了拦截。 4.3.2 分发事件给子元素如果在上面的操作中事件没有被拦截并且没有被取消，那么就会进入下面的逻辑。这部分代码处在 dispatchTouchEvent() 中。在下面的逻辑中会根据子元素的状态将事件传递给子元素： // 对子元素进行倒序遍历，即从上到下进行遍历 final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); // ... // 判断子元素是否能接收触摸事件：能接收事件并且不是正在进行动画的状态 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } // ... // 在这里调用了 dispatchTransformedTouchEvent() 方法将事件传递给子元素 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // ... 记录一些状态信息 // 在这里完成对 mFirstTouchTarget 的赋值，表示触摸事件被子元素处理 newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; // 结束循环，完成子元素的遍历 break; } // 显然，如果到了这一步，那么子元素的遍历仍将继续 } 当判断了指定的 View 可以接收触摸事件之后会调用 dispatchTransformedTouchEvent() 方法分发事件。其定义的节选如下： private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; // ... if (child == null) { // 本质上逻辑与 View 的 dispatchTouchEvent() 一致 handled = super.dispatchTouchEvent(transformedEvent); } else { // ... // 交给子元素继续分发事件 handled = child.dispatchTouchEvent(transformedEvent); } return handled; } dispatchTransformedTouchEvent() 会根据传入的 child 是否为 null 分成两种调用的情形：事件没有被拦截的时候，让子元素继续分发事件；另一种是当事件被拦截的时候，调用当前的 ViewGroup 的 super.dispatchTouchEvent(transformedEvent) 处理事件。 4.3.3 View 中的 dispatchTouchEvent上面我们分析的 dispatchTouchEvent(MotionEvent) 是 ViewGroup 中重写之后的方法。但是，正如我们上面的分析，重写之前的方法总是会被调用，只是对象不同。这里我们就来分析以下这个方法的作用。 public boolean dispatchTouchEvent(MotionEvent event) { // ... boolean result = false; // .... if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) { result = true; } // 这里回调了 setOnTouchListener() 方法传入的 OnTouchListener ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } // 如果 OnTouchListener 没有被回调过或者返回了 false，就会调用 onTouchEvent() 进行处理 if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } // ... return result; } 根据上面的源码分析，我们知道，如果当前的 View 设置过 OnTouchListener, 并且在 onTouch() 回调方法中返回了 true，那么 onTouchEvent(MotionEvent) 将不会得到调用。那么，我们再来看一下 onTouchEvent() 方法： public boolean onTouchEvent(MotionEvent event) { // ... // 判断当前控件是否是可以点击的：实现了点击、长按或者设置了可点击属性 final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; // ... if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) { switch (action) { case MotionEvent.ACTION_UP: // ... if (!focusTaken) { if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClick(); } } // ... break; case MotionEvent.ACTION_DOWN: // ... if (!clickable) { checkForLongClick(0, x, y); break; } // ... break; // ... } return true; } return false; } 这里先判断指定的控件是否是可点击的，即是否设置过点击或者长按的事件。然后会在手势抬起的时候调用 performClick() 方法，并会在这个方法中尝试从 ListenerInfo 取 OnClickListener 进行回调；会在长按的时候进行监听以调用相应长按事件；其他的事件与之类似，可以自行分析。所以，我们可以得出结论：当为控件的触摸事件进行了赋值并且在其中返回了 true 就代表该事件被消费了，即使设置过单击和长按事件也不会被回调，触摸事件的优先级比后面两者要高。 经过上述分析，我们可以知道 View 中的 dispatchTouchEvent(MotionEvent) 方法就是用来对手势进行处理的，所以回到 4.3.2，那里的意思就是：如果 ViewGroup 拦截了触摸事件，那么它就自己来对事件进行处理；否则就把触摸事件传递给子元素，让它来进行处理。 4.4.4 总结以上就是我们对 Android 中事件分发机制的详解，你可以通过图片和代码结合来更透彻得了解这方面的内容。虽然这部分代码比较多、比较长，但是每个地方的设计都是合情合理的。 源代码你可以在Github获取以上程序的源代码： Android-references。]]></content>
      <categories>
        <category>Android控件详解</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>控件体系</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 体系详解：View 的工作流程]]></title>
    <url>%2F2018%2F10%2F14%2FView%20%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3%EF%BC%9AView%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、View 树的加载流程当我们调用 startActivity() 方法的时候，会调用到 ActivityThread 中的 performLaunchActivity() 获取一个 Activity 实例， 并在 Instrumentation 的 callActivityOnCreate() 方法中调用 Activity 的 onCreate() 完成 DecorView 的创建。这样我们就获取了一个 Activity 的实例，然后我们调用 handleResumeActivity() 来回调 Activity 的 onResume()： private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) { // .... WindowManagerGlobal.initialize(); // 创建 Activity 的实例，在这里完成对 Activity 的 onCreate() 方法的回调 Activity a = performLaunchActivity(r, customIntent); if (a != null) { // ... // 在这里回调 Activity 的 onResume() 方法 handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) { // 在这里完成对 Activity 的 onPause() 方法的回调 performPauseActivityIfNeeded(r, reason); // ... } } // ... } 然后，在 handleResumeActivity() 方法中的 performResumeActivity() 会回调 Activity 的 onResume() 方法。在该方法中，我们会从 Window 中获取之前添加进去的 DecorView，然后将其添加到 WindowManager 中： final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) { // 在这里会回调 Activity 的 onResume() r = performResumeActivity(token, clearHide, reason); if (r != null) { final Activity a = r.activity; // ... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) { r.window = r.activity.getWindow(); // 在这里获取 DecorView View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); // 获取 WindowManager 实例，实际是 WindowManagerImpl ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) { a.mWindowAdded = true; r.mPreserveWindow = false; // Activity 被重建，复用 DecorView，通知子元素 ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) { impl.notifyChildRebuilt(); } } if (a.mVisibleFromClient) { if (!a.mWindowAdded) { a.mWindowAdded = true; // 将 DecorView 添加到 WindowManager 中 wm.addView(decor, l); } else { a.onWindowAttributesChanged(l); } } } } } 这里的 WindowManager 是 WindowManagerImpl 的实例，而调用它的 addView() 方法的时候会使用 WindowManagerGlobal 的 addView() 方法。在该方法中会 new 出来一个 ViewRootImpl，然后调用它的 setView() 把传进来的 DecorView 添加到 Window 里。同时，会调用 requestLayout() 方法进行布局，然后，并最终调用 performTraversals() 完成对整个 View 树进行遍历： private void performTraversals() { // ... if (!mStopped || mReportNextDraw) { // ... performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); } // ... final boolean didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw); boolean triggerGlobalLayoutListener = didLayout || mAttachInfo.mRecomputeGlobalAttributes; if (didLayout) { performLayout(lp, mWidth, mHeight); // ... } // ... if (!cancelDraw &amp;&amp; !newSurface) { // ... performDraw(); } } 在该方法中会调用 performMeasure()、performLayout() 和 performDraw() 三个方法，它们分别会调用 DecorView 的 measure()、layout() 和 draw() 完成对整个 View 树的测量、布局和绘制，一个界面也就呈现给用户了。如果您做过自定义 View 的话，那么您对 onMeasure()、onLayout() 和 onDraw()三个方法一定不会陌生，前面的三个方法与后面的三个方法之间的关系就是：后面的三个方法会被前面的三个方法调用，本质上就是提供给用户用来自定义的方法。下面我们就看下这三个方法究竟各自做了什么操作，当然，我们尽可能从自定义控件的角度来分析，因为这对一个开发者可能帮助更大。 2、measure()View 的大小不仅由自身所决定，同时也会受到父控件的影响，为了我们的控件能更好的适应各种情况，一般会自己进行测量。在上面我们提到了 measure() 方法，它是用来测量 View 的大小的，但实际上测量的主要工作是交给 onMeasure() 方法的。在 View 中，onMeasure() 是一个 protected 的方法，显然它设计的目的就是：提供给子 View 按照父容器提供的限制条件，控制自身的大小，实现自己大小的测量逻辑。所以，当我们自定义一个控件的时候，只会去覆写 onMeasure() 而不去覆写 measure() 方法。 在 Android 中，我们的控件分成 View 和 ViewGroup 两种类型。根据上面的分析，对 View 的测量，我们可以得出如下结论：在 Android 中，ViewGroup 会根据其自身的布局特点，把限制条件封装成 widthMeasureSpec 和 heightMeasureSpec 两个参数传递给子元素；然后，在子元素中根据这两个参数来调整自身的大小。所以，ViewGroup 的 measure() 方法会根据其布局特性的不同而不同；而 View 的 measure()，不论其父容器是哪种类型，只根据 widthMeasureSpec 和 heightMeasureSpec 决定。 下面我们来看一下 onMeasure() 在 View 和 ViewGroup 中的不同表现形式。 2.1 View 的 onMeasure()下面是 View 类中的 onMeasure() 方法。这是一个默认的实现，调用了 setMeasuredDimension() 方法来存储测量之后的宽度和高度。当我们自定义 View 的时候，也需要调用 setMeasuredDimension() 方法把最终的测量结果存储起来： protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension( getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } 显然，我们的测量依据就是 widthMeasureSpec 和 heightMeasureSpec 两个参数。它们是整型的、32位变量，包含了测量模式和测量数值的信息（按位存储到整型变量上，包装成整型的目的是为了节约存储空间）。一般我们会像下面这样来分别获取高度和宽度的测量模式和测量数值（实际就是按位截取）： int widthsize = MeasureSpec.getSize(widthMeasureSpec); // 测量数值 int widthmode = MeasureSpec.getMode(widthMeasureSpec); // 测量模式 int heightsize = MeasureSpec.getSize(heightMeasureSpec); // 测量数值 int heightmode = MeasureSpec.getMode(heightMeasureSpec); // 测量模式 测量模式共有 MeasureSpec.UNSPECIFIED、MeasureSpec.AT_MOST 和 MeasureSpec.EXACTLY 三种，分别对应二进制数值 00、01 和 10，它们各自的含义如下： UNSPECIFIED：默认值，父控件没有给子 View 任何限制，子 View 可以设置为任意大小； EXACTLY：表示父控件已经确切的指定了子 View 的大小； AT_MOST：表示子 View 具体大小没有尺寸限制，但是存在上限，上限一般为父 View 大小。 这里，我不打算详细介绍 View 中默认测量逻辑的具体实现。它的大致逻辑是这样的：首先我们会用 getDefaultSize() 获取默认的宽度或者高度，这个方法接收两个参数，一个是默认的尺寸，一个测量模式。如果父控件没有给它任何限制，它就使用默认的尺寸，否则使用测量数值。这里的默认的尺寸通过 getSuggestedMinimumHeight()/getSuggestedMinimumWidth() 方法得到，它会根据背景图片高度/宽度和 mMinHeight/mMinWidth 的值，取一个最大的值作为控件的高度/宽度。 所以，View 的默认的测量逻辑的实际效果是：首先 View 的大小受父容器的影响，如果父容器没有给它限制的话，它会取背景图片和最小的高度或者宽度中取一个最大的值作为自己的大小。 2.2 ViewGroup 的 onMeasure()2.2.1 ViewGroup 中的方法由于 ViewGroup 本身没有布局的特点，所以它没有覆写 onMeasure()。有自身布局特点的，比如 LinearLayout 和 RelativeLayout 等都覆写并实现了这个方法。尽管如此，ViewGroup 提供了一些方法帮助我们进行测量，首先是 measureChildren() 方法： protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) { final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) { final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) { measureChild(child, widthMeasureSpec, heightMeasureSpec); } } } 这里的逻辑比较简单，就是对子元素进行遍历并判断如果指定的 View 是否位 GONE 的状态，如果不是就调用 measureChild() 方法： protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) { final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } 该方法也比较容易理解，就是将子元素的布局参数 LayoutParams 取出，获取它的宽度和高度之后，将所有信息传递给 getChildMeasureSpec()。这样就得到了用于子元素布局的 childWidthMeasureSpec 和 childHeightMeasureSpec 参数。然后，再调用子元素的 measure() 方法，从而依次完成对整个 View 树的遍历。下面我们看下 getChildMeasureSpec() 方法做了什么操作： public static int getChildMeasureSpec(int spec, int padding, int childDimension) { // 首先从 spec 中取出父控件的测量模式和测量数值 int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); // 这里需要保证 size 不能为负数，也就是预留给子元素的最大空间，由父元素的测量数值减去填充得到 int size = Math.max(0, specSize - padding); // 用于返回的值 int resultSize = 0; int resultMode = 0; // 根据父空间的测量模式 switch (specMode) { // 父控件的大小是固定的 case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) { // 子 View 指定了大小 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // 子元素希望大小与父控件相同（填满整个父控件） resultSize = size; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // 子元素希望有自己决定大小，但是不能比父控件大 resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // 父控件的具体大小没有尺寸限制，但是存在上限 case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) { // 子 View 指定了大小 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // 子控件希望与父控件大小一致，但是父控件的大小也是不确定的，故让子控件不要比父控件大 resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // 子控件希望自己决定大小，限制其不要比父控件大 resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // 父控件没有任何限制，可以设置为任意大小 case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) { // 子元素设置了大小 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // 子控件希望和父控件一样大，但是父控件多大都不确定；系统23以下返回true，以上返回size resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } else if (childDimension == LayoutParams.WRAP_CONTENT) { resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } break; } // 返回一个封装好的测量结果，就是把测量数值和测量模式封装成一个32位的整数 return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } 上面我们已经为这段代码作了非常详细的注释。只需要注意，这里在获取子元素的测量结果的时候是基于父控件的测量结果来的，需要根据父元素的测量模式和测量数值结合自身的布局特点分成上面九种情况。或者可以按照下面的写法将其划分成下面几种情况： public static int getChildMeasureSpec(int spec, int padding, int childDimension) { int specMode = MeasureSpec.getMode(spec), specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0, resultMode = 0; if (childDimension &gt;= 0) { // 子元素指定了具体的大小，就用子元素的大小 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) { // 子元素希望和父控件一样大，需要设置其上限，然后测量模式与父控件一致即可 if (specMode == MeasureSpec.EXACTLY || specMode == MeasureSpec.AT_MOST) { resultSize = size; resultMode = specMode; } else if (specMode == MeasureSpec.UNSPECIFIED) { // API23一下就是0，父控件没有指定大小的时候，子控件只能是0；以上是size resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) { // 子元素希望自己决定大小，设置其大小的上限是父控件的大小即可 if (specMode == MeasureSpec.EXACTLY || specMode == MeasureSpec.AT_MOST) { resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (specMode == MeasureSpec.UNSPECIFIED) { // API23一下就是0，父控件没有指定大小的时候，子控件只能是0；以上是size resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } } return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } 这两种方式只是划分的角度不一样，后面的这种方法是从子元素的布局参数上面来考虑的。另外，这里有个 sUseZeroUnspecifiedMeasureSpec 布尔参数需要提及一下，会根据系统的版本来进行赋值： sUseZeroUnspecifiedMeasureSpec = targetSdkVersion &lt; Build.VERSION_CODES.M; 也就是当系统是 API23 以下的时候的为 true. 加入这个参数的原因是，API23 之后，当父控件的测量模式是 UNSPECIFIED 的时候，子元素可以给父控件提供一个可能的大小。下面是注释的原话 ;-) // In M and newer, our widgets can pass a &quot;hint&quot; value in the size // for UNSPECIFIED MeasureSpecs. This lets child views of scrolling containers // know what the expected parent size is going to be, so e.g. list items can size // themselves at 1/3 the size of their container. It breaks older apps though, // specifically apps that use some popular open source libraries. 2.2.2 LinearLayout 的 onMeasure()上面我们分析的是 ViewGroup 中提供的一些方法，下面我们以 LinearLayout 为例，看一下一个标准的容器类型的控件是如何实现其测量的逻辑的。 下面是其 onMeasure() 方法，显然在进行测量的时候会根据其布局的方向分别实现测量的逻辑： protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { if (mOrientation == VERTICAL) { measureVertical(widthMeasureSpec, heightMeasureSpec); } else { measureHorizontal(widthMeasureSpec, heightMeasureSpec); } } 然后，我们以 measureVertical() 为例，来看一下 LinearLayout 在垂直方向上面是如何进行测量的。这段代码比较长，我们只截取其中的一部分来进行分析： void measureVertical(int widthMeasureSpec, int heightMeasureSpec) { // ... // 获取LinearLayout的测量模式 final int widthMode = MeasureSpec.getMode(widthMeasureSpec); final int heightMode = MeasureSpec.getMode(heightMeasureSpec); // ... mTotalLength += mPaddingTop + mPaddingBottom; int heightSize = mTotalLength; heightSize = Math.max(heightSize, getSuggestedMinimumHeight()); // ... for (int i = 0; i &lt; count; ++i) { final View child = getVirtualChildAt(i); if (child == null || child.getVisibility() == View.GONE) { continue; } final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final float childWeight = lp.weight; if (childWeight &gt; 0) { // ... // 获取一个测量的数值和测量模式 final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( Math.max(0, childHeight), MeasureSpec.EXACTLY); final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width); // 调用子元素进行测量 child.measure(childWidthMeasureSpec, childHeightMeasureSpec); childState = combineMeasuredStates(childState, child.getMeasuredState() &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT)); } final int margin = lp.leftMargin + lp.rightMargin; final int measuredWidth = child.getMeasuredWidth() + margin; maxWidth = Math.max(maxWidth, measuredWidth); boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT; alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth); allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT; final int totalLength = mTotalLength; // 将宽度增加到 mTotalLength 上 mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child)); } mTotalLength += mPaddingTop + mPaddingBottom; // ... maxWidth += mPaddingLeft + mPaddingRight; maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); // 最终确定测量的大小 setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState); // ... } 上面是 LinearLayout 在垂直方向上面的测量的过程，在测量的时候会根据子元素的布局将子元素的测量高度添加到 mTotalLength 上，然后再加上填充的大小，作为最终的测量结果。 3、layout() layout() 用于确定控件的位置，它提供了 onLayout() 来交给字类实现，同样我们在自定义控件的时候只要实现 onLayout() 方法即可。在我们自定义 View 的时候，如果定义的是非 ViewGroup 类型的控件，一般是不需要覆写 onLayout() 方法的。 下面我们先看一下 layout() 方法在 View 中的实现： public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { onLayout(changed, l, t, r, b); // ... } // ... } 这里会调用 setFrame() 方法，它的主要作用是根据新的布局参数和老的布局参数做一个对比，以判断控件的大小是否发生了变化，如果变化了的话就调用 invalidate() 方法并传入参数 true，以表明绘图的缓存也发生了变化。这里就不给出这个方法的具体实现了。然后注意到，在 layout() 方法中会回调 onLayout() 方法来完成各个控件的位置的确定。 对于 ViewGroup，它重写了 layout() 并在其中调用了 View 中的 layout() 方法，不过整体并没有做太多的逻辑。与测量过程类似，ViewGroup 并没有实现 onLayout 方法。同样，对于 ViewGroup 类型的控件，我们还是以 LinearLayout 为例说明一下 onLayout() 的实现逻辑： 与测量过程类似，LinearLayout 在 layout 的时候也根据布局的方向分成两种情形： protected void onLayout(boolean changed, int l, int t, int r, int b) { if (mOrientation == VERTICAL) { layoutVertical(l, t, r, b); } else { layoutHorizontal(l, t, r, b); } } 这里我们仍以垂直方向的方法为例。与测量的过程相比，layout 的过程的显得简单、清晰得多： void layoutVertical(int left, int top, int right, int bottom) { // ... // 根据控件的 gravity 特点得到顶部的位置 switch (majorGravity) { case Gravity.BOTTOM: childTop = mPaddingTop + bottom - top - mTotalLength; break; case Gravity.CENTER_VERTICAL: childTop = mPaddingTop + (bottom - top - mTotalLength) / 2; break; case Gravity.TOP: default: childTop = mPaddingTop; break; } // 遍历子控件 for (int i = 0; i &lt; count; i++) { final View child = getVirtualChildAt(i); if (child == null) { childTop += measureNullChild(i); } else if (child.getVisibility() != GONE) { final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); int gravity = lp.gravity; if (gravity &lt; 0) { gravity = minorGravity; } final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); // 得到子控件的左边的位置 switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) { case Gravity.CENTER_HORIZONTAL: childLeft = paddingLeft + ((childSpace - childWidth) / 2) + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: childLeft = childRight - childWidth - lp.rightMargin; break; case Gravity.LEFT: default: childLeft = paddingLeft + lp.leftMargin; break; } if (hasDividerBeforeChildAt(i)) { childTop += mDividerHeight; } childTop += lp.topMargin; // 本质上调用子控件的 layout() 方法 setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child, i); } } } 因为布局方向是垂直方向的，所以在对子元素进行遍历之前，先对自身的顶部的位置进行计算，然后再依次遍历子元素，并对顶部的高度不断叠加，最后调用 setChildFrame() 方法: private void setChildFrame(View child, int left, int top, int width, int height) { child.layout(left, top, left + width, top + height); } 这样就完成了对整个 View 树的 layout() 方法的调用。 4、draw()View 的 draw() 方法实现的逻辑也很清晰。在绘制的过程会按照如下的步骤进行： 绘制背景 保存 canvas 绘制自身的内容 绘制子控件 绘制 View 的褪色边缘，比如阴影效果之类的 绘制装饰，比如滚动条之类的 View 中提供了 onDraw() 方法用来完成对自身的内容的绘制，所以，我们自定义 View 的时候只要重写这个方法就可以了。当我们要自定义一个 ViewGroup 类型的控件的时候，一般是不需要重写 onDraw() 方法的，因为它只需要遍历子控件并依次调用它们的 draw() 方法就可以了。（当然，如果非要实现的话，也是可以的。） 下面是这部分代码，代码的注释中也详细注释了每个步骤的逻辑： public void draw(Canvas canvas) { final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) { drawBackground(canvas); } // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) { // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); drawAutofilledHighlight(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) { mOverlay.getOverlayView().dispatchDraw(canvas); } // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // Step 7, draw the default focus highlight drawDefaultFocusHighlight(canvas); if (debugDraw()) { debugDrawFocus(canvas); } // we&apos;re done... return; } // ... } 注意到在上面的方法中会调用 dispatchDraw(canvas) 方法来分发绘制事件给子控件来完成整个 View 树的绘制。在 View 中，这是一个空的方法，ViewGroup 覆写了这个方法，并在其中调用 drawChild() 来完成对指定的 View 的 draw() 方法的调用： protected boolean drawChild(Canvas canvas, View child, long drawingTime) { return child.draw(canvas, this, drawingTime); } 而对于 LinearLayout 这样本身没有绘制需求的控件，没有覆写 onDraw() 和 dispatchDraw(canvas) 等方法，因为 View 和 ViewGroup 中提供的功能已经足够使用。 总结：上文中，我们介绍了在 Android 系统中整个 View 树的工作的流程，从 DecorView 被加载到窗口中，到测量、布局和绘制三个方法的实现。本质上整个工作的流程就是对 View 树的一个深度优先的遍历过程。]]></content>
      <categories>
        <category>Android控件详解</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>控件体系</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
</search>
