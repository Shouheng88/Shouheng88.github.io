<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android 消息机制：Handler、MessageQueue 和 Looper]]></title>
    <url>%2F2018%2F11%2F04%2FAndroid-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%EF%BC%9AHandler%E3%80%81MessageQueue-%E5%92%8C-Looper%2F</url>
    <content type="text"><![CDATA[在这篇文章中，我们将会讨论 Android 的消息机制。提到 Handler，有过一些 Android 开发经验的都应该很清楚它的作用，通常我们使用它来通知主线程更新 UI。但是 Handler 需要底层的 MessageQueue 和 Looper 来支持才能运作。这篇文章中，我们将会讨论它们三个之间的关系以及实现原理。 在这篇文章中，因为涉及线程方面的东西，所以就避不开 ThreadLocal。笔者在之前的文章中有分析过该 API 的作用，你可以参考笔者的这篇文章来学习下它的作用和原理，本文中我们就不再专门讲解：《Java 并发编程：ThreadLocal 的使用及其源码实现》。 1、Handler 的作用通常，当我们在非主线程当中做了异步的操作之后使用 Handler 来在主线程当中更新 UI。之所以这么设计无非就是因为 Android 中的 View 不是线程安全的。之所以将 View 设计成非线程安全的，是因为：1).对 View 进行加锁之后会增加控件使用的复杂度；2).加锁之后会降低控件执行的效率。但 Handler 并非只能用来在主线程当中更新 UI，确切来说它有两个作用： 任务调度：即通过 post() 和 send() 等方法来指定某个任务在某个时间执行； 线程切换：你也许用过 RxJava，但如果在 Android 中使用的话还要配合 RxAndroid，而这里的 RxAndroid 内部就使用 Handler 来实现线程切换。 下文中，我们就来分别看一下它的这两个功能的作用和原理。 1.1 任务调度使用 Hanlder 可以让一个任务在某个时间点执行或者等待某段时间之后执行。Handler 为此提供了许多方法，从方法的命名上，我们可以将其分成 post() 和 sned() 两类方法。post() 类的用来指定某个 Runnable 在某个时间点执行，send() 类的用来指定某个 Message 在某个时间点执行。 这里的 Message 是 Android 中定义的一个类。它内部有多个字段，比如 what、arg1、arg2、replyTo 和 sendingUid 来帮助我们指定该消息的内容和对象。同时， Message 还实现了 Parcelable 接口，这表明它可以被用来跨进程传输。此外，它内部还定义了一个 Message 类型的 next 字段，这表明 Message 可以被用作链表的结点。实际上 MessageQueue 里面只存放了一个 mMessage，即链表的头结点。所以，MessageQueue 内部的消息队列，本质上是一个单链表，每个链表的结点就是 Message。 当调用 post() 类型的方法来调度某个 Runnable 的时候，首先会将其包装成一个 Message，然后再使用 send() 类的方法进行任务分发。所以，不论是 post() 类的方法还是 send() 类的方法，最终都会使用 Handler 的 sendMessageAtTime() 方法来将其加入到队列中： public boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { // ... 无关代码 return false; } return enqueueMessage(queue, msg, uptimeMillis); } 使用 Handler 进行任务调度是非常简单的。下面的代码就实现了让一个 Runnable 在 500ms 之后执行的逻辑： new Handler().postDelayed(new Runnable() { @Override public void run() { // do something } }, 500); 上面的任务执行方式在主线程中执行不会出现任何问题，如果你在非主线程中执行的话就可能会出现异常。原因我们后面会讲解。 既然每个 Runnable 被 post() 发送之后还要被包装成 Message，那么 Message 的意义何在呢？ Runnable 被包装的过程依赖于 Handler 内部的 getPostMessage() 方法。下面是该方法的定义： private static Message getPostMessage(Runnable r) { Message m = Message.obtain(); m.callback = r; return m; } 可见，我们的 Runnable 会被赋值给 Message 的 callback。这种类型的消息无法做更详细的处理。就是说，我们无法利用消息的 what、arg1 等字段（本身我们也没有设置这些字段）。如果我们希望使用 Message 的这些字段信息，就需要： 首先，要使用 send() 类型的方法来传递我们的 Message 给 Handler； 然后，我们的 Handler 要覆写 handleMessage() 方法，并在该方法中获取每个 Message 并根据其内部的信息依次处理。 下面的一个例子用来演示 send() 类型的方法。首先，我们要定义 Handler 并覆写其 handleMessage() 方法来处理消息： private final static int SAY_HELLO = 1; private static Handler handler = new Handler() { @Override public void handleMessage(Message msg) { switch (msg.what) { case SAY_HELLO: LogUtils.d(&quot;Hello!&quot;); break; } } }; 然后，我们向该 Handler 发送消息： Message message = Message.obtain(handler); message.what = SAY_HELLO; message.sendToTarget(); 这样，我们的 Handler 接收到了消息并根据其 what 得知要 SAY_HELLO，于是就打印出了日志信息。除了调用 Message 的 sendToTarget() 方法，我们还可以直接调用 handler 的 sendMessage() 方法（sendToTarget() 内部调用了 handler 的 sendMessage()）。 1.2 线程切换下面我们用了一份示例代码，它会先在主线程当中实例化一个 Handler，然后在某个方法中，我们开启了一个线程，并执行了某个任务。2 秒之后任务结束，我们来更新 UI。 // 在主线程中获取 Handler private static Handler handler = new Handler(); // 更新UI，会将消息发送到主线程当中 new Thread(() -&gt; { try { Thread.sleep(2000); handler.post(() -&gt; getBinding().tv.setText(&quot;主线程更新UI&quot;)); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); 上面之所以能够在主线程当中更新 UI，主要是因为我们的 Handler 是在主线程当中进行获取的。随后，我们调用 handler 的 post() 方法之后，传入的 Runnable 会被包装成 Message，然后加入到主线程对应的消息队列中去，并由主线程对应的 Looper 获取到并执行。所以，就使得该 Runnable 的操作最终在主线程中完成。 也许你会觉得先在主线程当中获取到 Handler 然后再使用比较麻烦。别担心，我们还有另一种方式来解决这个问题。我们可以直接使用 Looper 的 getMainLooper() 方法来获取主线程对应的 Looper，然后使用它来实例化一个 Handler 并使用该 Handler 来处理消息： new Handler(Looper.getMainLooper()) .post(() -&gt; getBinding().tv.setText(&quot;主线程更新UI&quot;)); 本质上，当我们调用 Handler 的无参构造方法，或者说不指定 Looper 的构造方法的时候，会直接使用当前线程对应的 Looper 来实例化 Handler。每个线程对应的 Looper 存储在该线程的局部变量 ThreadLocal 里。当某个线程的局部变量里面没有 Looper 的时候就会抛出一个异常。所以，我们之前说直接使用 new 来实例化一个 Handler 的时候可能出错就是这个原因。 主线程对应的 Looper 会在 ActivityThread 的静态方法 main() 中被创建，它会调用 Looper 的 prepareMainLooper() 静态方法来创建主线程对应的 Looper。然后会调用 Looper 的 loop() 静态方法来开启 Looper 循环以不断处理消息。这里的 ActivityThread 用来处理应用进程中的活动和广播的请求，会在应用启动的时候调用。ActivityThread 内部定义了一个内部类 H，它继承自 Handler，同样运行在主线程中，用来处理接收到的来自各个活动、广播和服务的请求。 除了使用主线程对应的 Looper，我们也可以开启我们自定义线程的 Looper。下面的代码中，我们开启了一个线程，并在线程中先调用 Looper 的 prepare() 静态方法，此时 Looper 会为我们当前的线程创建 Looper，然后将其加入到当前线程的局部变量里面。随后，当我们调用 Looper 的 loop() 方法的时候就开启了 Looper 循环来不断处理消息： new Thread(() -&gt; { LogUtils.d(&quot;+++++++++&quot; + Thread.currentThread()); Looper.prepare(); new Handler().post(() -&gt; LogUtils.d(&quot;+++++++++&quot; + Thread.currentThread())); Looper.loop(); }).start(); 从以上的内容我们可以看出，Handler 之所以能够实现线程切换，主要的原因是其内部的消息队列是对应于每一个线程的。发送的任务会在该线程对应的消息队列中被执行。而成功获取到该线程对应的消息队列就依靠 ThreadLocal 来对每个线程对应的消息队列进行存储。 2、源码解析以上，我们分析了 Handler 的主要的两种主要用途，并且在这个过程中，我们提及了许多 Handler、MessageQueue 和 Looper 的底层设计。在上面的文章中，我们只是使用了文字来进行描述。在下文中，我们来通过源码来验证我们上面提到的一些内容。 2.1 实例化 HandlerHandler 了提供了多个重载的构造方法，我们可以将其分成两种主要的类型。一种在构造方法中需要明确指定一个 Looper，另一种在构造方法中不需要指定任何 Looper，在构造方法内部会获取当前线程对应的 Looper 来初始化 Handler。 第一种初始化的方式最终都会调用下面的方法来完成初始化。这个方法比较简单，是基本的赋值操作： public Handler(Looper looper, Callback callback, boolean async) { mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; } 第二种初始化的方式最终会调用下面的方法。这里使用 Looper 的静态方法 myLooper() 来获取当前线程对应的 Looper。如果当前线程不存在任何 Looper 就会抛出一个异常。 public Handler(Callback callback, boolean async) { // 潜在内存泄漏的检查 if (FIND_POTENTIAL_LEAKS) { final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) { Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); } } // 使用 Looper 的静态方法 myLooper() 来获取当前线程的 Looper mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException(); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; } 而 Looper 的静态方法 myLooper() 会使用线程局部变量 sThreadLocal 来获取之前存储到该线程内部的 Looper： public static @Nullable Looper myLooper() { return sThreadLocal.get(); } 2.2 Looper 的初始化前面我们也说过 Looper 的创建过程。对于主线程的 Looper 会在 ActivityThread 的 main() 方法中被调用： public static void main(String[] args) { // ... 无关代码 Looper.prepareMainLooper(); // ... 无关代码 // 开启 Looper 循环 Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); } 这里调用了 Looper 的静态方法 prepareMainLooper() 来初始化主线程的 Looper： public static void prepareMainLooper() { prepare(false); synchronized (Looper.class) { if (sMainLooper != null) { throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); } sMainLooper = myLooper(); } } 其内部先调用了 prepare(boolean) 方法来初始化一个 Looper 并将其放在线程局部变量 sThreadLocal 中，然后判断 sMainLooper 是否之前存在过。这是一种基本的单例校验，显然，我们只允许主线程的 Looper 被实例化一次。 同样，非主线程的 Looper 也只允许被实例化一次。当我们在非主线程实例化一个 Looper 的时候会调用它的 prepare() 静态方法。它同样调用了 prepare(boolean) 方法来初始化一个 Looper 并将其放在线程局部变量 sThreadLocal 中。所以，主线程和非主线程的 Looper 实例化的时候本质上是调用同样的方法，只是它们实现的时机不同，并且，都只能被实例化一次。 public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); } sThreadLocal.set(new Looper(quitAllowed)); } 经过上述分析，我们可以得知，对于一个线程只能实例化一个 Looper，所以当我们在同一个线程中多次创建 Handler 实例，它们是共享一个 Looper 的。或者说是一个 Looper 对应多个 Handler 也是可以的。 2.3 MessageQueue 的实例化相比于 Looper 和 Handler，MessageQueue 就显得相对复杂一些。因为内部用到了 JNI 编程。初始化、销毁和入队等事件都用到了 native 的方法。你可以在 android_os_MessageQueue 查看其源码的定义。 每当我们实例化一个 Looper 的时候会调用它的构造方法，并在其中实例化一个 MessageQueue： private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } 在实例化 Handler 的小节中可以看出，每次实例化一个 Handler 的时候，会从当前线程对应的 Looper 中取出 MessageQueue。所以，这里我们又可以得出结论一个 Handler 对应一个 MessageQueue。 当我们实例化一个 MessageQueue 的时候会使用它的构造方法。这里会调用 native 层的 nativeInit() 方法来完成 MessageQueue 的初始化： MessageQueue(boolean quitAllowed) { mQuitAllowed = quitAllowed; mPtr = nativeInit(); } 在 native 层，nativeInit() 方法的定义如下： static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) { NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); if (!nativeMessageQueue) { jniThrowRuntimeException(env, &quot;Unable to allocate native queue&quot;); return 0; } nativeMessageQueue-&gt;incStrong(env); return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue); } 从上面我们可以看出，在该方法中实例化了一个 NativeMessageQueue 之后返回了 mPtr 作为是 Java 层 MessageQueue 与NativeMessesageQueue 的桥梁。这个 long 类型的成员保存了 native 实例，这是 jni 开发中常用到的方式。因此 MessageQueue 同样使用 mPtr 来表示 native 层的消息队列。NativeMessageQueue 在 native 层的部分定义和其构造方法的定义如下。 class NativeMessageQueue : public MessageQueue, public LooperCallback { // ... 无关代码 NativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) { mLooper = Looper::getForThread(); if (mLooper == NULL) { mLooper = new Looper(false); Looper::setForThread(mLooper); } } 从上面我们可以看出，NativeMessageQueue 继承自 MessageQueue。并且在其内部实例化了一个 native 层的 Looper（其源码在 Looper）。 在 Android 的 native 层存在着一个于 Java 层类似的 Looper，它的主要作用是用来与 Java 层的 Looper 相互配合完成 Android 中最主要的线程通信。当消息队列中有消息存入时，会唤醒 Natvice 层的 Looper。当消息队列中没有消息时或者消息尚未到处理时间时， Natvice 层的 Looper 会 block 住整个线程。所以，创建了 Java Looper 的线程只有在有消息待处理时才处于活跃状态，无消息时 block 在等待消息写入的状态。既然如此，当我们在主线程中开启了 Looper 循环的话，为什么不会 block 住整个线程而导致 ANR 呢？这是因为，我们的主线程的消息都会发送给主线程对应的 Looper 来处理，所以，本质上，我们主线程中的许多事件也都是以消息的形式发送给主线程的 Handler 来进行处理的。只有当某个消息被执行的时间过长的时候才会出现 ANR。 上面我们实例化了一个 Native 层的 Looper。在其中主要做到的逻辑如下： void Looper::rebuildEpollLocked() { // 如果之前存在的话就关闭之前的 epoll 实例 if (mEpollFd &gt;= 0) { mEpollFd.reset(); // 关闭旧的epoll实例 } // 申请新的 epoll 实例，并且注册 “Wake管道” mEpollFd.reset(epoll_create(EPOLL_SIZE_HINT)); LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance: %s&quot;, strerror(errno)); struct epoll_event eventItem; // 把未使用的数据区域进行置0操作 memset(&amp; eventItem, 0, sizeof(epoll_event)); eventItem.events = EPOLLIN; eventItem.data.fd = mWakeEventFd.get(); // 将唤醒事件 (mWakeEventFd) 添加到 epoll 实例 (mEpollFd) int result = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, mWakeEventFd.get(), &amp;eventItem); LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not add wake event fd to epoll instance: %s&quot;, strerror(errno)); // 这里主要添加的是Input事件如键盘，传感器输入，这里基本上由系统负责，很少主动去添加 for (size_t i = 0; i &lt; mRequests.size(); i++) { const Request&amp; request = mRequests.valueAt(i); struct epoll_event eventItem; request.initEventItem(&amp;eventItem); // 将 request 队列的事件，分别添加到 epoll 实例 int epollResult = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, request.fd, &amp;eventItem); } } 这里涉及了 epoll 相关的知识。epoll 是一个可扩展的 Linux I/O 事件通知机制，用来实现多路复用 (Multiplexing)。它将唤醒事件按对应的 fd 注册进 epoll，然后 epoll 帮你监听哪些唤醒事件上有消息到达。此时的唤醒事件应该采用非阻塞模式。这样，整个过程只在调用 epoll 的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的响应模式。 上面的代码中使用了 epoll_ctl 方法来将被监听的描述符添加到 epoll 句柄。关于 epoll 的指令，可以参考这篇博文 《epoll机制:epoll_create、epoll_ctl、epoll_wait、close》。这部分代码的主要作用是创建一个 epoll 实例并用它来监听 event 触发。 2.4 消息的执行过程2.4.1 消息入队的过程在介绍 Handler 的使用的时候，我们也说过不论是 Runnable 还是 Message 最终都会被封装成 Meseage 并加入到队列中。那么，加入队列之后又是怎么被执行的呢？ 首先，我们先看下入队的过程。以下是 Handler 中定义的方法，每当我们将一个消息入队的时候，都会调用它来完成。 private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis); } 从上面可以看出，入队的时候实际上是使用了 MessageQueue 的 enqueueMessage() 方法。所以，我们再来看下该方法的定义： boolean enqueueMessage(Message msg, long when) { // ... 无关代码，校验 synchronized (this) { // ... 无关代码 Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { msg.next = p; mMessages = msg; needWake = mBlocked; } else { needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; prev.next = msg; } if (needWake) { nativeWake(mPtr); } } return true; } 从上面的方法可以看出，所谓的入队操作本质上就是一个将新的消息加入到队列中的逻辑。当然，这里加入的时候要根据消息的触发时间对消息进行排序。然后，会根据 needWake 来决定是否调用 native 层的方法进行唤醒。只有当当前的头结点消息之前存在栅栏 (barrier) 并且新插入的消息是最先要被触发的异步消息就进行唤醒。当一般情况下是无需进行唤醒的。 这里的 nativeWake() 方法会最终调用 native 层的 Looper 的 awake() 方法： void Looper::wake() { uint64_t inc = 1; ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd.get(), &amp;inc, sizeof(uint64_t))); if (nWrite != sizeof(uint64_t)) { if (errno != EAGAIN) { LOG_ALWAYS_FATAL(&quot;Could not write wake signal to fd %d: %s&quot;, mWakeEventFd.get(), strerror(errno)); } } } 此方法向 mWakeEventFd 写入了一个字节的内容。到底是什么内容并不重要，重要的是 fd 存在内容了，换句话说就是 mWakeEventFd 可读了，也就是 Native 层的 Looper 的线程从 block 状态中醒了过来。之所以需要进行唤醒，是因为，每次我们处理了消息之后会根据下个消息执行的时间进行唤醒。如果新插入的消息是最新的消息，那么显然，我们需要把唤醒的时间重置。（Native 层的 Looper 会在我们调用 Java 层的 MessageQueue 的时候执行 epoll_wait 时进入 block 状态。） 2.4.2 消息执行的过程在上文中，我们分析了 MessageQueue 将消息入队的过程。那么这些消息要在什么时候被执行呢？在介绍 Handler 的使用的时候，我们也提到过当我们实例化了 Looper 之后都应该调用它的 loop() 静态方法来处理消息。下面我们来看下这个方法的定义。 public static void loop() { final Looper me = myLooper(); // .. 无关代码 final MessageQueue queue = me.mQueue; // .. 无关代码 for (;;) { Message msg = queue.next(); // 可能会 bolck if (msg == null) { return; } // ... 无关代码 final long dispatchEnd; try { msg.target.dispatchMessage(msg); dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; } finally { if (traceTag != 0) { Trace.traceEnd(traceTag); } } // ... 无关代码 msg.recycleUnchecked(); } } 从上面我们可以看出，当该方法被调用的时候，它会先开启一个无限循环，并在该循环中使用 MessageQueue 的 next() 方法来取出下一个消息并进行分发。这里我们先不看 next() 方法的定义。我们先把这个方法中涉及的部分分析一下。 当获取到了下一个消息之后，会调用它的target 也就是发送该消息的 Handler 的 dispatchMessage() 方法来进行处理。该方法的定义如下： public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } 从上面可以看出，如果该消息是通过包装 Runnable 得到的话，会直接调用它的 handleCallback() 方法进行处理。在该方法内部会直接调用 Runnable 的 run() 方法。因为比较见到那，我们就补贴出代码了。 然后，会根据 mCallback 是否为空来决定是交给 mCallback 进行处理还是内部的 handleMessage() 方法。这里的 mCallback 是一个接口，可以在创建 Handler 的时候通过构造方法指定，也比较简单。而这里的 handleMessage() 方法，我们就再熟悉不过了，它就是我们创建 Handler 的时候重写的、用来处理消息的方法。这样，消息就被发送到了我们的 Handler 中进行处理了。 以上就是消息被处理的过程，代码的逻辑还是比较清晰的。下面我们就来看下 MessageQueue 是如何获取 “下一个” 消息的。 2.4.3 MessageQueue 的消息管理上面我们已经分析完了 Handler 发送的消息执行的过程。这里我们在来分析一下其中的获取 “下一个” 消息的逻辑： Message next() { // 如果消息循环已经停止就直接返回。如果应用尝试重启已经停止的Looper就会可能发生这种情况。 final long ptr = mPtr; if (ptr == 0) { return null; } int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } // 调用 native 的方法，可能会这个函数发生 block nativePollOnce(ptr, nextPollTimeoutMillis); // ... 无关代码 } } 从上面可以看出 Java 层的 MessageQueue 的 next() 方法是一个循环。除了获取消息队列之外，还要监听 Natvie 层 Looper 的事件触发。通过调用 native 层的 nativePollOnce() 方法来实现。该方法内部又会调用 NativeMessageQueue 的 pollOnce() 方法。而且注意下，在下面的方法中，nativeMessageQueue 是从 Java 层的 mPtr 中获取到的。所以我们说，在初始化 MessageQueue 的时候得到的 mPtr 起到了桥梁的作用： static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) { NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis); } 在 NativeMessageQueue 的 pollOnce() 方法中会调用 native 层的 Looper 的 pollOnce()，并最终调用 native 层 Looper 的 pollInner() 方法： int Looper::pollInner(int timeoutMillis) { // ... 根据下一个消息的事件调整超时时间 int result = POLL_WAKE; mResponses.clear(); mResponseIndex = 0; mPolling = true; // 将要空闲 struct epoll_event eventItems[EPOLL_MAX_EVENTS]; // 待已注册之事件被触发或计时终了 int eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis); mPolling = false; // 不再空闲 mLock.lock(); // 请求锁 if (mEpollRebuildRequired) { mEpollRebuildRequired = false; rebuildEpollLocked(); // 根据需要重建 epoll goto Done; } // 进行检查 if (eventCount &lt; 0) { if (errno == EINTR) { goto Done; } result = POLL_ERROR; // 错误 goto Done; } if (eventCount == 0) { result = POLL_TIMEOUT; // 超时 goto Done; } // 处理所有消息 for (int i = 0; i &lt; eventCount; i++) { int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeEventFd.get()) { // 唤醒 fd 有反应 if (epollEvents &amp; EPOLLIN) { awoken(); // 已经唤醒了，则读取并清空管道数据 } } else { // 其他 input fd 处理，其实就是将活动 fd 放入到 responses 队列中，等待处理 ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &gt;= 0) { int events = 0; if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT; if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT; if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR; if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP; // 将消息放进 mResponses 中 pushResponse(events, mRequests.valueAt(requestIndex)); } } } Done: ; // 触发所有的消息回调，处理 Native 层的Message mNextMessageUptime = LLONG_MAX; while (mMessageEnvelopes.size() != 0) { nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0); if (messageEnvelope.uptime &lt;= now) { { // 获取 handler sp&lt;MessageHandler&gt; handler = messageEnvelope.handler; Message message = messageEnvelope.message; mMessageEnvelopes.removeAt(0); mSendingMessage = true; mLock.unlock(); handler-&gt;handleMessage(message); } // 释放 handler mLock.lock(); mSendingMessage = false; result = POLL_CALLBACK; } else { // 队列头部的消息决定了下个唤醒的时间 mNextMessageUptime = messageEnvelope.uptime; break; } } mLock.unlock(); // 释放锁 // 触发所有的响应回调 for (size_t i = 0; i &lt; mResponses.size(); i++) { Response&amp; response = mResponses.editItemAt(i); if (response.request.ident == POLL_CALLBACK) { int fd = response.request.fd; int events = response.events; void* data = response.request.data; int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data); if (callbackResult == 0) { removeFd(fd, response.request.seq); // 移除文件描述符 } response.request.callback.clear(); result = POLL_CALLBACK; } } return result; } 从上面我们可以看出 Native 层的 pollInner() 方法首先会根据 Java 层传入的 timeoutMillis 调用 epoll_wait 方法来让线程进入等待状态。如果 timeoutMillis 不为 0，那么线程将进入等待状态。如果有事件触发发生，wake 或者其他复用 Looper 的 event，处理event，这样整个 Native 层的 Looper 将从 block 状态中解脱出来了。这样回到 Java 层就将继续执行 MessageQueue 中下一条语句。至于 Native 层的 Looper 何时从 block 状态中醒过来，就需要根据我们入队的消息来定。也就用到了 MessageQueue 的 enqueueMessage() 方法的最后几行代码： if (needWake) { nativeWake(mPtr); } 即：只有当当前的头结点消息之前存在栅栏 (barrier) 并且新插入的消息是最先要被触发的异步消息就进行唤醒。 上面主要是 Native 层的 Looper 线程 block 的相关的逻辑。即当我们获取消息队列的下一条消息的时候会根据下一个消息的时间来决定线程 block 的时长。当我们将一个消息加入到队列的时候会根据新的消息的时间重新调整线程 block 的时长，如果需要的话还需要唤起 block 的线程。当线程从 block 状态恢复出来的时候，Java 层的 Looper 就拿到了一个消息，对该消息进行处理即可。 3、总结在上文中，我们从 Java 层到 Native 层分析了 Handler 的作用的原理。这里我们对这部分内容做一个总结。 3.1 Handler、MessageQueue 和 Looper 之间的关系首先是 Handler、MessageQueue 和 Looper 之间的关系。我们用下面的这个图来表示： 也就是说，一个线程中可以定义多个 Handler 实例，但是每个 Handler 实际上引用的是同一个 Looper。当然，我们要在创建 Handler 之前先创建 Looper。而每个 Looper 又只对应一个 MessageQueue。该 MessageQueue 会在创建 Looper 的时候被创建。在 MessageQueue 中使用 Message 对象来拼接一个单向的链表结构，依次来构成一个消息队列。每个 Message 是链表的一个结点，封装了我们发送的信息。 3.2 Handler 的消息发送过程然后，我们再来分析下 Handler 中的消息是如何被发送的。同样，我们使用一个图来进行分析： 根据上文的内容我们将 Handler 发送消息的方法分成 post 和 send 两种类型。post 的用来发送 Runnable 类型的数据，send 类型的用来发送 Message 类型的数据。但不论哪种类型最终都会调用 Handler 的 sendMessageAtTime() 方法来加入到 MessageQueue 的队列中。区别在于，post 类型的方法需要经过 Handler 的 getPostMessage() 包装成 Message 之后再发送。 3.3 Looper 的执行过程当消息被添加到队列之后需要执行消息，这部分内容在 Looper 的 loop() 方法中。但是这部分内容稍显复杂，因为涉及 Native 层的一些东西。我们这里仍然使用图来进行描述： 当我们调用 Looper 的 loop() 方法之后整个 Looper 循环就开始不断地处理消息了。在上图中就是我们用绿色标记的一个循环。当我们在循环中调用 MessageQueue 的 next() 方法来获取下一个消息的时候，会调用 nativePollOnce() 方法，该方法可能会造成线程阻塞和非阻塞，当线程为非阻塞的时候就会从 Native 层回到 Java 层，从 MessageQueuue 中取得一个消息之后给 Looper 进行处理。如果获取的时候造成线程阻塞，那么有两种情况会唤醒阻塞的线程，一个是当一个新的消息被加入到队列中，并且将会早于之前队列的所有消息被触发，那么此时将会重新设置超时时间。如果达到了超时时间同样可以从睡眠状态中返回，也就回到了 Java 层继续处理。所以，Native 层的 Looper 的作用就是通过阻塞消息队列获取消息的过程阻塞 Looper。 3.4 最后因为本文中不仅分析了 Java 层的代码，同时分析了 framework 层的代码，所以最好能够结合两边的源码一起看，这样更有助于自己的理解。在上面的文章中，我们给出了一些类的在线的代码链接，在 Google Source 上面，需要 VPN 才能浏览。另外，因为笔者水平有限，难免存在有误和不足的地方，欢迎批评指正。 我是 WngShhng. 如果您喜欢我的文章，可以在以下平台关注我： 个人主页：https://shouheng88.github.io/ 掘金：https://juejin.im/user/585555e11b69e6006c907a2a Github：https://github.com/Shouheng88 CSDN：https://blog.csdn.net/github_35186068 微博：https://weibo.com/u/5401152113]]></content>
      <categories>
        <category>Android消息机制</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码阅读</tag>
        <tag>Framework</tag>
        <tag>Handler</tag>
        <tag>Looper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理在 Android 中的应用：Retrofit 源码解析]]></title>
    <url>%2F2018%2F10%2F20%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%9C%A8%20Android%20%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9ARetrofit%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在之前的文章 《Andriod 网络框架 OkHttp 源码解析》 中我们分析了 OkHttp 的源代码。现在我们就来分析一下 OkHttp 的兄弟框架 Retrofit。关于 Retrofit 的注解的使用，可以参考其官方文档：https://square.github.io/retrofit/。 Retrofit 也是 Square 发布的一个开源的库，它是一个类型安全的 Http 客户端，适用于 Android 和 Java。本质上，Retrofit 使用了 Java 的动态代理，内部使用 OkHttp 来进行网络访问，并且可以通过指定 “请求适配器” 和 “类型转换器” 来完成方法参数到 OkHttp 的请求的转换，以及 OkHttp 响应到用户指定的实体类型的转换。 1、基本使用Retrofit 设计的一个好的地方就是它把我们上面提到的 “请求适配器” 和 “类型转换器” 使用策略模式解耦出来。用户可以根据自己的需求通过实现指定的接口来自定义自己的类型转换器。所以，当我们使用 Gson 和 RxJava2 转换器的时候，就需要指定下面三个依赖： api &apos;com.squareup.retrofit2:retrofit:2.4.0&apos; api &apos;com.squareup.retrofit2:converter-gson:2.4.0&apos; api &apos;com.squareup.retrofit2:adapter-rxjava2:2.4.0&apos; 然后，我们需要根据自己的 API 接口的信息，在代码里用一个接口来对该 API 接口进行声明： public interface WXInfoService { @GET(&quot;/sns/userinfo&quot;) Observable&lt;WXUserInfo&gt; getWXUserInfo( @Query(&quot;access_token&quot;) String accessToken, @Query(&quot;openid&quot;) String openId); } 这里的 WXUserInfo 是由该 API 接口返回的 Json 生成的 Java 对象。然后，我们可以像下面这样获取一个该接口的代理对象： WXInfoService wXInfoService = new Retrofit.Builder() .baseUrl(&quot;https://api.weixin.qq.com/&quot;) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .client(okHttpClient) .build().create(WXInfoService.class); 然后，我们就可以使用该对象并调用其方法来获取接口返回的信息了： Disposable disposable = wxInfoService.getWXUserInfo(accessToken, openId) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(wxUserInfo -&gt; { /*...拿到结果之后进行处理...*/ }); 上面我们只是使用了 Retrofit 的最基础的 GET 接口。当然，Retrofit 本身的功能远比这要丰富得多，关于其更多的使用，可以参考其官方的文档。 2、动态代理：魔力发生的地方上面我们使用 Retrofit 进行网络请求，实际其内部使用 OkHttp 来完成网络请求的，然后，使用我们传入的 “类型转换器” 把响应转换成我们指定的类型。定义了一个接口并调用了该接口的方法，然后就拿到了请求的结果，这看上去非常简洁，而这其中的最功不可没的就是动态代理。 当我们使用 Retrofit.Builder 的 create() 方法获取一个 WXInfoService 实例的时候，实际返回的是经过代理之后的对象。该方法内部会调用 Proxy 的静态方法 newProxyInstance() 来得到一个代理之后的实例。为了说明这个方法的作用，我们写了一个例子： public static void main(String...args) { Service service = getProxy(Service.class); String aJson = service.getAInfo(); System.out.println(aJson); String bJson = service.getBInfo(); System.out.println(bJson); } private static &lt;T&gt; T getProxy(final Class&lt;T&gt; service) { InvocationHandler h = (proxy, method, args) -&gt; { String json = &quot;{}&quot;; if (method.getName().equals(&quot;getAInfo&quot;)) { json = &quot;{A请求的结果}&quot;; } else if (method.getName().equals(&quot;getBInfo&quot;)) { json = &quot;{B请求的结果}&quot;; } return json; }; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[]{service}, h); } 该程序的输出结果是： {A请求的结果} {B请求的结果} 在上面的这个例子中，我们先使用 getProxy() 获取一个代理之后的实例，然后依次调用它的 getAInfo() 和 getBInfo() 方法，来模拟调用 A 接口和 B 接口的情形，并依次得到了 A 请求的结果和 B 请求的结果。上面的效果近似于我们使用 Retrofit 访问接口的过程。为了说明这个过程中发生了什么，我们需要先了解一下这里的 newProxyInstance() 方法： public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) { // ... } 该方法接收三个参数：第一个是类加载器；第二个是接口的 Class 类型；第三个是一个处理器，你可以将其看作一个用于回调的接口。当我们的代理实例触发了某个方法的时候，会调用该回调接口的方法进行处理。InvocationHandler 是一个接口，它内部定义了一个方法如下： public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; 该方法也接收三个参数：第一个是触发该方法的代理实例；第二个是代理类触发的方法；第三个是触发的方法的参数。invoke() 方法的返回结果会作为代理类的方法执行的结果。 所以，当了解了 newProxyInstance() 方法的定义之后，我们可以做如下总结：当我们使用 newProxyInstance() 方法获取了一个代理实例 service 并调用其 getAInfo() 方法之后，该方法的信息和参数信息会分别通过 method 和 args 传入到 h 的 invoke() 中。所以，最终的效果就是，当我们调用 service 的 getAInfo() 时候会触发 h 的 invoke()。然后，在该方法中我们根据 method 得知触发的方法是 getAInfo。于是，我们把它对应的请求从 invoke() 方法中返回，并作为 service.getAInfo() 的返回结果。 所以，我们可以总结 Retrofit 的大致工作流程：当我们获取了接口的代理实例，并调用它的 getWXUserInfo() 方法之后，该 API 的请求参数会传递到代理类的 InvocationHandler.invoke() 方法中。然后在该方法中，我们将其转换成 OkHttp 的 Request，然后使用 OkHttp 进行访问。当拿到结果之后，我们使用传入的 “转换器” 将响应转换成接口指定的 Java 类型。 上面是 Retrofit 请求处理的基本流程，下面我们看一下 Retrofit 的代理方法内部究竟发生了什么。 3、Retrofit 的源码解析3.1 创建 Retrofit根据上面的例子，当使用 Retrofit 的时候，首先我们需要使用 Retrofit 的构建者来创建 Retrofit 的实例。这里有几个重要的方法需要提及一下： 3.1.1 addConverterFactory 方法该方法用来向 Retrofit 中添加一个 Converter.Factory。Converter.Factory，顾名思义是一种工厂模式，它是一个接口需要实现两个重要的方法。每个方法需要返回一个转换器：一个是某种数据类型到请求体的转换器，另一个是响应体到我们需要的数据类型的转换器。当我们使用 Gson 来完成这个转换，那么我们就需要使用 GsonConverterFactory.create() 来得到一个适用于 Gson 的 Converter.Factory。 public Builder addConverterFactory(Converter.Factory factory) { converterFactories.add(checkNotNull(factory, &quot;factory == null&quot;)); return this; } 3.1.2 addCallAdapterFactory 方法CallAdapter.Factory 用于获取 CallAdapter 对象， CallAdapter 对象用于把原生的 OkHttp 的 Call 转换成我们指定的请求类型。比如，转换成 RxJava2 的 Observable 类型。下面是该方法的定义： public Builder addCallAdapterFactory(CallAdapter.Factory factory) { callAdapterFactories.add(checkNotNull(factory, &quot;factory == null&quot;)); return this; } 3.1.3 build 方法当根据用户的自定义设置完了参数之后，就可以调用 build() 方法，来获取一个 Retrofit 的实例。在该方法中会将上述的工厂实例添加到一个列表中，然后根据请求、响应的类型来获取工厂实例，然后分别获取一个转换器或者适配器。 3.1.4 小结为了说明适配器 CallAdapter 和转换器 Converter 的作用，我们绘制了下图： 从上面我们看出，CallAdapter 主要用来将某个请求转换成我们指定的类型。比如，在我们最开始的例子中，要将请求转换成 Observable&lt;WXUserInfo&gt;。如果转换之后的请求是 Observable 类型的，那么当我们对转换后的请求进行订阅的时候，就启动了 OkHttp 的网络请求过程。 在进行网络请求之前会先使用 Converter 将请求的参数转换成一个 RequestBody。这里将其作为一个接口的好处是便于解耦。比如，上面我们用 Gson 来完成转换过程，你也可以通过自定义转换器来使用其他的框架，比如 Moshi 等。当拿到了响应之后，我们又会再次使用 Converter 来将响应体 ResponseBody 转换成我们要求的类型。比如，上面的例子中应该转换为 WXUserInfo。 最后，OkHttp 那里得到的响应会在 CallAdapter 方法内部被包装成 Observable&lt;WXUserInfo&gt; 并返回给观察者。这样，我们就拿到了这个请求的结果。 从上面我们看出，Retrofit 设计的非常妙的地方就在于上面的两个过程的解耦（策略模式+工厂模式）。一次是将请求转换成 Observable 的过程，一次是将请求体和响应体转换成 OkHttp 要求的 RequestBody 和 ResponseBody 的过程。对于前者，不论我们使用的是 RxJava 1 还是 RxJava 2，只要传入一个 CallAdapter 即可。对于后者，不论我们使用哪种 Json 转换框架，只要实现了 Converter 接口皆可。 3.2 获取代理实例3.2.1 划分平台：Platform创建了 Retrofit 的实例之后，我们就可以使用它的 create() 方法来获取代理之后的服务实例。下面是这个方法的定义。在这里，我们会先根据 validateEagerly 变量来判断是否立即对传入的服务接口的方法进行解析。然后，我们使用 Proxy 的静态方法获取一个代理实例。 public &lt;T&gt; T create(final Class&lt;T&gt; service) { Utils.validateServiceInterface(service); // 这里的 validateEagerly 在 Retrofit 构建的时候设置 if (validateEagerly) { // 是否立即对 Service 方法的内容进行解析 eagerlyValidateMethods(service); } // 获取代理实例 return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service }, new InvocationHandler() { private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable { // 该方法是 Object 的方法，直接触发该方法 if (method.getDeclaringClass() == Object.class) { return method.invoke(this, args); } // 如果是 default 方法，那么使用该 Java8 平台的方法执行 if (platform.isDefaultMethod(method)) { return platform.invokeDefaultMethod(method, service, proxy, args); } // 获取服务方法的信息，并将其包装成 ServiceMethod ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.adapt(okHttpCall); } }); } 这里的 eagerlyValidateMethods() 方法定义如下： private void eagerlyValidateMethods(Class&lt;?&gt; service) { // 获取程序当前运行的平台 Platform platform = Platform.get(); for (Method method : service.getDeclaredMethods()) { // 判断该方法是否是 default 方法 if (!platform.isDefaultMethod(method)) { loadServiceMethod(method); } } } 它的作用是立即对服务接口的方法进行解析，并将解析之后的结果放进一个缓存中。这样，当这个服务方法被触发的时候，直接从缓存当中获取解析之后的 ServiceMethod 来使用即可。该方法会先会根据当前程序运行的平台来决定是否应该加载服务的方法。因为，Java 8 之后，我们可以为接口增加 default 类型的方法，所以，如果是 default 类型的话，我们不会调用 loadServiceMethod() 进行解析，而是调用 Java8 平台的 invokeDefaultMethod() 来处理。在 invokeDefaultMethod() 中，会根据传入的信息创建一个实例并使用反射触发它的方法。此时，就间接地触发了该 default 方法。 判断平台的时候，使用了如下这段代码： platform.isDefaultMethod(Method) 这里的 platform 是调用 Platform.get() 的时候得到的。它会在 get() 方法中尝试使用反射去获取一个只有 Java8 平台才具有的类，以此来判断是否是 Java8 的环境。在 Retrofit 中，提供了 Java8 和 Android 两个类来区分所在的平台，并会根据运行环境来决定返回哪个实例。 从上面我们看出，Platform 算是一种策略的设计模式，以根据平台的不同做不同的处理。但在当前的版本中，它的主要作用是对 default 类型的方法进行处理。 3.2.2 解析服务方法：ServiceMethod上面我们提到过 loadServiceMethod() 方法，它的主要作用：首先会尝试从缓存当中获取该方法对应的 ServiceMethod 实例，如果取到的话，就将其返回；否则，就使用构建者模式创建一个并放进缓存中，然后将其返回。 ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) { // 从缓存中进行获取 ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method); if (result != null) return result; synchronized (serviceMethodCache) { result = serviceMethodCache.get(method); if (result == null) { // 创建ServiceMethod实例 result = new ServiceMethod.Builder&lt;&gt;(this, method).build(); serviceMethodCache.put(method, result); } } return result; } ServiceMethod 的构建过程比较简单，只需要把当前的 Retrofit 实例和服务方法 method 传入进去，然后调用它的 build() 方法就完成了整个创建过程。在 build() 方法中，会完成对 method 的解析，比如根据注解判断是什么类型的请求，根据方法的参数来解析请求的请求体等等。ServiceMethod 内部的变量主要是与请求的相关的信息，同时它也提供了一些方法，用于获取 OkHttp 的请求和响应。 所以，ServiceMethod 的作用是缓存服务方法对应的请求信息，这样下次我们就不需要再次解析了。同时，它提供了以下几个方法，它们的主要作用是用来从 ServiceMethod 中获取请求相关的信息。 toCall() 用来获取用于 OkHttp 请求的 Call 对象： okhttp3.Call toCall(@Nullable Object... args) throws IOException { RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody, isFormEncoded, isMultipart); // ... return callFactory.newCall(requestBuilder.build()); } toResponse(ResponseBody) 用来把 OkHttp 得到的响应体转换成 Java 对象等（在示例中是WXUserInfo）： R toResponse(ResponseBody body) throws IOException { return responseConverter.convert(body); } adapt(Call&lt;R&gt;) 用来将 OkHttp 的请求转换成我们的服务方法的返回类型（在示例中是Observable&lt;WXUserInfo&gt;）： T adapt(Call&lt;R&gt; call) { return callAdapter.adapt(call); } 3.2.3 请求封装：OkHttpCall解析完毕服务方法之后，我们得到了 ServiceMethod 实例。然后，我们使用它来创建 OkHttpCall 实例。这里的 OkHttpCall 实现了 Retrofit 中定义的 Call 接口，会在方法内调用 ServiceMethod 的 toCall() 方法来获取 OkHttp 中的 Call 对象，然后使用它进行网络访问。当拿到了请求的结果之后又使用 ServiceMethod 的 toResponse() 把响应转换成我们指定的类型。下面是该类中的几个比较重要的方法： execute() 方法，用来同步执行网络请求： 1234567891011121314151617181920212223@Overridepublic Response&lt;T&gt; execute() throws IOException &#123; okhttp3.Call call; synchronized (this) &#123; // ... call = rawCall; if (call == null) &#123; try &#123; // 创建 OkHttp 的 Call 实例 call = rawCall = createRawCall(); &#125; catch (IOException | RuntimeException | Error e) &#123; throwIfFatal(e); creationFailure = e; throw e; &#125; &#125; &#125; if (canceled) &#123; call.cancel(); &#125; // 同步执行请求，并解析结果 return parseResponse(call.execute());&#125; createRawCall() 用来创建 OkHttp 的 Call 实例： 12345678// 使用 serviceMethod 的 toCall 方法获取 OkHttp 的 Call 实例private okhttp3.Call createRawCall() throws IOException &#123; okhttp3.Call call = serviceMethod.toCall(args); if (call == null) &#123; throw new NullPointerException(&quot;Call.Factory returned null.&quot;); &#125; return call;&#125; parseResponse() 用来将 OkHttp 的响应转换成我们接口中定义的类型。比如，在我们的例子中，返回的是 Observable&lt;WXUserInfo&gt;: 1234567891011121314151617// 使用 serviceMethod 的 toResponse 方法获取 OkHttp 的 Response 实例Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; ResponseBody rawBody = rawResponse.body(); rawResponse = rawResponse.newBuilder() .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())) .build(); // ... ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody); try &#123; // 使用 serviceMethod 的 toResponse 方法获取 OkHttp 的 Response 实例 T body = serviceMethod.toResponse(catchingBody); return Response.success(body, rawResponse); &#125; catch (RuntimeException e) &#123; catchingBody.throwIfCaught(); throw e; &#125;&#125; 3.3 Retrofit 的工作过程上面是 Retrofit 框架设计中几个关键的部分的功能的解析。下面，我们再来具体看一下，从触发代理类的方法到拿到响应的结果，这一整个过程中，都有哪些类的哪些方法参与，以及它们在什么时候，扮演什么样的角色。这里我们仍然使用最初的示例： 上图中，我们将 Retrofit 的请求的过程分成三个过程来进行说明： 创建代理实例的过程：在这个过程中主要是调用 Proxy.newProxyInstance() 来获取一个代理实例。相关的主要参数是 validateEagerly，我们会使用它来决定是否立即对传入的接口的方法进行解析。不论我们什么时候进行解析，都会把解析的结果缓存起来。 触发代理方法的过程：触发代理方法是整个请求的第二过程，这个时候，我们调用了 WXInfoService 代理实例的 getWXUserInfo() 方法。此时，会触发 InvocationHandler 的 invoke() 方法。在该方法内部会调用 ServiceMethod 的构建者模式来创建 ServiceMethod 实例。当调用构建者模式的 build() 方法的时候，会对方法 getWXUserInfo() 的信息进行解析。然后，使用 ServiceMethod 实例创建 OkHttpCall。最后，使用 ServiceMethod 实例的 adapt() 方法将 OkHttpCall 实例转换成 Observable&lt;WXUserInfo&gt;。此时，会使用 CallAdapter 的 adapt() 方法来完成适配过程。 执行网络请求的过程：拿到了 Observable&lt;WXUserInfo&gt; 之后，需要对其进行订阅才能触发网络请求。相关的逻辑在 CallAdapter 中完成。首先，它会根据你使用同步还是异步的来决定使用哪个执行器。这里存在两个执行器，它们的区别是一个会在内部调用 OkHttpCall 的 enqueue()，另一个会在执行器中调用 OkHttpCall 的 execute() 方法。不论调用 enqueue() 还是 execute()，都会先使用 OkHttpCall 的 toCall() 方法获取一个 Call 请求。获取请求的过程中会使用 Converter 来将某个实例转换成请求体。拿到了请求之后，使用该请求来进行网络访问。当从网络中拿到了响应之后，会使用 Converter 来将响应体转换成对象。这样，拿到了实际的结果之后，就会调用 Observer 的 onNext() 方法把结果通知给观察者。 4、总结在这篇文章中，我们先简单介绍了 Retrofit 的使用，然后，因为 Retrofit 内部使用动态代理来实现的，所以，我们对动态代理相关内容进行了介绍。最后，我们对 Retrofit 的源码进行了分析，先从设计思路，后从各个环节的执行过程进行了说明。最后的最后，我们将两者结合起来用一个时序图做了说明。 从上文中可以看出来，Retrofit 设计的几个值得我们借鉴的地方： 使用运行时注解和反射简化请求描述，但是考虑到反射的效率比较低，所以将一次反射之后的结果缓存起来，以便于下次使用。 动态代理：使用接口描述请求的好处是它简洁，而且 “描述” 本来就是它的责任。但是，一般我们需要去实现接口才能使用。而这里告诉我们，使用动态代理一样可以使用接。 解耦：从我们上面的图中也可以看出来，Retrofit 的设计的思路是比较清晰的。它将一个请求的几个过程解耦出来。首先是我们 Observable 到请求的转换，这里使用适配器来完成；然后是请求体和响应体的转换，基本就是 Json 的转换，使用转换器来完成。这样，不论你使用 RxJava 1 还是 RxJava 2，不论是 Gson 还是 FastXml 都可以和 Retrifut 配合使用。 以上就是我们对 Retrofit 的源码的分析。]]></content>
      <categories>
        <category>Android网络访问</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>计算机网络</tag>
        <tag>OkHttp</tag>
        <tag>源码阅读</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Andriod 网络框架 OkHttp 源码解析]]></title>
    <url>%2F2018%2F10%2F17%2FAndriod%20%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%20OkHttp%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1、OkHttp 的基本使用OkHttp 是 Square 的一款应用于 Android 和 Java 的 Http 和 Http/2 客户端。使用的时候只需要在 Gradle 里面加入下面一行依赖即可引入： implementation &apos;com.squareup.okhttp3:okhttp:3.11.0&apos; 我们知道，Http 请求有多种类型，常用的分为 Get 和 Post，而 POST 又分为 Form 和 Multiple 等。下面我们以 Form 类型的请求为例来看下 OkHttp 的 API 设计逻辑： OkHttpClient internalHttpClient = new OkHttpClient(); FormBody.Builder formBodyBuilder = new FormBody.Builder(); RequestBody body = formBodyBuilder.build(); Request.Builder builder = new Request.Builder().url(&quot;host:port/url&quot;).post(body); Request request = builder.build(); Response response = internalHttpClient.newCall(request).execute(); String retJson = response.body().string(); 这里我们先用了 FormBody 的构建者模式创建 Form 类型请求的请求体，然后使用 Request 的构建者创建完整的 Form 请求。之后，我们用创建好的 OkHttp 客户端 internalHttpClient 来获取一个请求，并从请求的请求体中获取 Json 数据。 根据 OkHttp 的 API，如果我们希望发送一个 Multipart 类型的请求的时候就需要使用 MultipartBody 的构建者创建 Multipart 请求的请求体。然后同样使用 Request 的构建者创建完整的 Multipart 请求，剩下的逻辑相同。 除了使用上面的直接实例化一个 OkHttp 客户端的方式，我们也可以使用 OkHttpClient 的构建者 OkHttpClient.Builder 来创建 OkHttp 客户端。 所以，我们可以总结： OkHttp 为不同的请求类型都提供了一个构建者方法用来创建请求体 RequestBody； 因为请求体只是整个请求的一部分，所以，又要用 Request.Builder 构建一个请求对象 Request； 这样我们得到了一个完整的 Http 请求，然后使用 OkHttpClient 对象进行网络访问得到响应对象 Response。 OkHttp 本身的设计比较友好，思路非常清晰，按照上面的思路搞懂了人家的 API 设计逻辑，自己再基于 OkHttp 封装一个库自然问题不大。 2、OkHttp 源码分析上面我们提到的一些是基础的 API 类，是提供给用户使用的。这些类的设计只是基于构建者模式，非常容易理解。这里我们关注点也不在这些 API 类上面，而是 OkHttp 内部的请求执行相关的类。下面我们就开始对 OkHttp 的请求过程进行源码分析（源码版本：3.10.0）。 2.1 一个请求的大致流程参考之前的示例程序，抛弃构建请求的过程不讲，单从请求的发送过程来看，我们的线索应该从 OkHttpClient.newCall(Request) 开始。下面是这个方法的定义，它会创建一个 RealCall 对象，并把 OkHttpClient 对象和 Request 对象作为参数传入进去： @Override public Call newCall(Request request) { return RealCall.newRealCall(this, request, false /* for web socket */); } 然后，RealCall 调用内部的静态方法 newRealCall 在其中创建一个 RealCall 实例并将其返回： static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { RealCall call = new RealCall(client, originalRequest, forWebSocket); call.eventListener = client.eventListenerFactory().create(call); return call; } 然后，当返回了 RealCall 之后，我们又会调用它的 execute() 方法来获取响应结果，下面是这个方法的定义： @Override public Response execute() throws IOException { synchronized (this) { if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; } captureCallStackTrace(); eventListener.callStart(this); try { // 加入到一个双端队列中 client.dispatcher().executed(this); // 从这里拿的响应Response Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(&quot;Canceled&quot;); return result; } catch (IOException e) { eventListener.callFailed(this, e); throw e; } finally { client.dispatcher().finished(this); } } 这里我们会用 client 对象（实际也就是上面创建 RealCall 的时候传入的 OkHttpClient）的 dispatcher() 方法来获取一个 Dispatcher 对象，并调用它的 executed() 方法来将当前的 RealCall 加入到一个双端队列中，下面是 executed(RealCall) 方法的定义，这里的 runningSyncCalls 的类型是 Deque&lt;RealCall&gt;： synchronized void executed(RealCall call) { runningSyncCalls.add(call); } 让我们回到上面的 execute() 方法，在把 RealCall 加入到双端队列之后，我们又调用了 getResponseWithInterceptorChain() 方法，下面就是该方法的定义。 Response getResponseWithInterceptorChain() throws IOException { // 添加一系列拦截器，注意添加的顺序 List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); // 桥拦截器 interceptors.add(new BridgeInterceptor(client.cookieJar())); // 缓存拦截器：从缓存中拿数据 interceptors.add(new CacheInterceptor(client.internalCache())); // 网络连接拦截器：建立网络连接 interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) { interceptors.addAll(client.networkInterceptors()); } // 服务器请求拦截器：向服务器发起请求获取数据 interceptors.add(new CallServerInterceptor(forWebSocket)); // 构建一条责任链 Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); // 处理责任链 return chain.proceed(originalRequest); } 这里，我们创建了一个列表对象之后把 client 中的拦截器、重连拦截器、桥拦截器、缓存拦截器、网络连接拦截器和服务器请求拦截器等依次加入到列表中。然后，我们用这个列表创建了一个拦截器链。这里使用了责任链设计模式，每当一个拦截器执行完毕之后会调用下一个拦截器或者不调用并返回结果。显然，我们最终拿到的响应就是这个链条执行之后返回的结果。当我们自定义一个拦截器的时候，也会被加入到这个拦截器链条里。 这里我们遇到了很多的新类，比如 RealCall、Dispatcher 以及责任链等。下文中，我们会对这些类之间的关系以及责任链中的环节做一个分析，而这里我们先对整个请求的流程做一个大致的梳理。下面是这个过程大致的时序图： 2.2 分发器 Dispatcher上面我们提到了 Dispatcher 这个类，它的作用是对请求进行分发。以最开始的示例代码为例，在使用 OkHttp 的时候，我们会创建一个 RealCall 并将其加入到双端队列中。但是请注意这里的双端队列的名称是 runningSyncCalls，也就是说这种请求是同步请求，会在当前的线程中立即被执行。所以，下面的 getResponseWithInterceptorChain() 就是这个同步的执行过程。而当我们执行完毕的时候，又会调用 Dispatcher 的 finished(RealCall) 方法把该请求从队列中移除。所以，这种同步的请求无法体现分发器的“分发”功能。 除了同步的请求，还有异步类型的请求：当我们拿到了 RealCall 的时候，调用它的 enqueue(Callback responseCallback) 方法并设置一个回调即可。该方法会执行下面这行代码： client.dispatcher().enqueue(new AsyncCall(responseCallback)); 即使用上面的回调创建一个 AsyncCall 并调用 enqueue(AsyncCall)。这里的 AsyncCall 间接继承自 Runnable，是一个可执行的对象，并且会在 Runnable 的 run() 方法里面调用 AsyncCall 的 execute() 方法。AsyncCall 的 execute() 方法与 RealCall 的 execute() 方法类似，都使用责任链来完成一个网络请求。只是后者可以放在一个异步的线程中进行执行。 当我们调用了 Dispatcher 的 enqueue(AsyncCall) 方法的时候也会将 AsyncCall 加入到一个队列中，并会在请求执行完毕的时候从该队列中移除，只是这里的队列是 runningAsyncCalls 或者 readyAsyncCalls。它们都是一个双端队列，并用来存储异步类型的请求。它们的区别是，runningAsyncCalls 是正在执行的队列，当正在执行的队列达到了限制的时候，就会将其放置到就绪队列 readyAsyncCalls 中： synchronized void enqueue(AsyncCall call) { if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) { runningAsyncCalls.add(call); executorService().execute(call); } else { readyAsyncCalls.add(call); } } 当把该请求加入到了正在执行的队列之后，我们会立即使用一个线程池来执行该 AsyncCall。这样这个请求的责任链就会在一个线程池当中被异步地执行了。这里的线程池由 executorService() 方法返回： public synchronized ExecutorService executorService() { if (executorService == null) { executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false)); } return executorService; } 显然，当线程池不存在的时候会去创建一个线程池。除了上面的这种方式，我们还可以在构建 OkHttpClient 的时候，自定义一个 Dispacher，并在其构造方法中为其指定一个线程池。下面我们类比 OkHttp 的同步请求绘制了一个异步请求的时序图。你可以通过将两个图对比来了解两种实现方式的不同： 以上就是分发器 Dispacher 的逻辑，看上去并没有那么复杂。并且从上面的分析中，我们可以看出实际请求的执行过程并不是在这里完成的，这里只能决定在哪个线程当中执行请求并把请求用双端队列缓存下来，而实际的请求执行过程是在责任链中完成的。下面我们就来分析一下 OkHttp 里的责任链的执行过程。 2.3 责任链的执行过程在典型的责任链设计模式里，很多对象由每一个对象对其下级的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。责任链在现实生活中的一种场景就是面试，当某轮面试官觉得你没有资格进入下一轮的时候可以否定你，不然会让下一轮的面试官继续面试。 在 OkHttp 里面，责任链的执行模式与之稍有不同。这里我们主要来分析一下在 OkHttp 里面，责任链是如何执行的，至于每个链条里面的具体逻辑，我们会在随后一一说明。 回到 2.1 的代码，有两个地方需要我们注意： 是当创建一个责任链 RealInterceptorChain 的时候，我们传入的第 5 个参数是 0。该参数名为 index，会被赋值给 RealInterceptorChain 实例内部的同名全局变量。 当启用责任链的时候，会调用它的 proceed(Request) 方法。 下面是 proceed(Request) 方法的定义： @Override public Response proceed(Request request) throws IOException { return proceed(request, streamAllocation, httpCodec, connection); } 这里又调用了内部的重载的 proceed() 方法。下面我们对该方法进行了简化： public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException { if (index &gt;= interceptors.size()) throw new AssertionError(); // ... // 调用责任链的下一个拦截器 RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); // ... return response; } 注意到这里使用责任链进行处理的时候，会新建下一个责任链并把 index+! 作为下一个责任链的 index。然后，我们使用 index 从拦截器列表中取出一个拦截器，调用它的 intercept() 方法，并把下一个执行链作为参数传递进去。 这样，当下一个拦截器希望自己的下一级继续处理这个请求的时候，可以调用传入的责任链的 proceed() 方法；如果自己处理完毕之后，下一级不需要继续处理，那么就直接返回一个 Response 实例即可。因为，每次都是在当前的 index 基础上面加 1，所以能在调用 proceed() 的时候准确地从拦截器列表中取出下一个拦截器进行处理。 我们还要注意的地方是之前提到过重试拦截器，这种拦截器会在内部启动一个 while 循环，并在循环体中调用执行链的 proceed() 方法来实现请求的不断重试。这是因为在它那里的拦截器链的 index 是固定的，所以能够每次调用 proceed() 的时候，都能够从自己的下一级执行一遍链条。下面就是这个责任链的执行过程： 清楚了 OkHttp 的拦截器链的执行过程之后，我们来看一下各个拦截器做了什么逻辑。 2.3 重试和重定向：RetryAndFollowUpInterceptorRetryAndFollowUpInterceptor 主要用来当请求失败的时候进行重试，以及在需要的情况下进行重定向。我们上面说，责任链会在进行处理的时候调用第一个拦截器的 intercept() 方法。如果我们在创建 OkHttp 客户端的时候没有加入自定义拦截器，那么RetryAndFollowUpInterceptor 就是我们的责任链中最先被调用的拦截器。 @Override public Response intercept(Chain chain) throws IOException { // ... // 注意这里我们初始化了一个 StreamAllocation 并赋值给全局变量，它的作用我们后面会提到 StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; // 用来记录重定向的次数 int followUpCount = 0; Response priorResponse = null; while (true) { if (canceled) { streamAllocation.release(); throw new IOException(&quot;Canceled&quot;); } Response response; boolean releaseConnection = true; try { // 这里从当前的责任链开始执行一遍责任链，是一种重试的逻辑 response = realChain.proceed(request, streamAllocation, null, null); releaseConnection = false; } catch (RouteException e) { // 调用 recover 方法从失败中进行恢复，如果可以恢复就返回true，否则返回false if (!recover(e.getLastConnectException(), streamAllocation, false, request)) { throw e.getLastConnectException(); } releaseConnection = false; continue; } catch (IOException e) { // 重试与服务器进行连接 boolean requestSendStarted = !(e instanceof ConnectionShutdownException); if (!recover(e, streamAllocation, requestSendStarted, request)) throw e; releaseConnection = false; continue; } finally { // 如果 releaseConnection 为 true 则表明中间出现了异常，需要释放资源 if (releaseConnection) { streamAllocation.streamFailed(null); streamAllocation.release(); } } // 使用之前的响应 priorResponse 构建一个响应，这种响应的响应体 body 为空 if (priorResponse != null) { response = response.newBuilder() .priorResponse(priorResponse.newBuilder().body(null).build()) .build(); } // 根据得到的响应进行处理，可能会增加一些认证信息、重定向或者处理超时请求 // 如果该请求无法继续被处理或者出现的错误不需要继续处理，将会返回 null Request followUp = followUpRequest(response, streamAllocation.route()); // 无法重定向，直接返回之前的响应 if (followUp == null) { if (!forWebSocket) { streamAllocation.release(); } return response; } // 关闭资源 closeQuietly(response.body()); // 达到了重定向的最大次数，就抛出一个异常 if (++followUpCount &gt; MAX_FOLLOW_UPS) { streamAllocation.release(); throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount); } if (followUp.body() instanceof UnrepeatableRequestBody) { streamAllocation.release(); throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code()); } // 这里判断新的请求是否能够复用之前的连接，如果无法复用，则创建一个新的连接 if (!sameConnection(response, followUp.url())) { streamAllocation.release(); streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(followUp.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; } else if (streamAllocation.codec() != null) { throw new IllegalStateException(&quot;Closing the body of &quot; + response + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;); } request = followUp; priorResponse = response; } } 以上的代码主要用来根据错误的信息做一些处理，会根据服务器返回的信息判断这个请求是否可以重定向，或者是否有必要进行重试。如果值得去重试就会新建或者复用之前的连接在下一次循环中进行请求重试，否则就将得到的请求包装之后返回给用户。这里，我们提到了 StreamAllocation 对象，它相当于一个管理类，维护了服务器连接、并发流和请求之间的关系，该类还会初始化一个 Socket 连接对象，获取输入/输出流对象。同时，还要注意这里我们通过 client.connectionPool() 传入了一个连接池对象 ConnectionPool。这里我们只是初始化了这些类，但实际在当前的方法中并没有真正用到这些类，而是把它们传递到下面的拦截器里来从服务器中获取请求的响应。稍后，我们会说明这些类的用途，以及之间的关系。 2.4 BridgeInterceptor桥拦截器 BridgeInterceptor 用于从用户的请求中构建网络请求，然后使用该请求访问网络，最后从网络响应当中构建用户响应。相对来说这个拦截器的逻辑比较简单，只是用来对请求进行包装，并将服务器响应转换成用户友好的响应： public final class BridgeInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request userRequest = chain.request(); // 从用户请求中获取网络请求构建者 Request.Builder requestBuilder = userRequest.newBuilder(); // ... // 执行网络请求 Response networkResponse = chain.proceed(requestBuilder.build()); // ... // 从网络响应中获取用户响应构建者 Response.Builder responseBuilder = networkResponse.newBuilder().request(userRequest); // ... // 返回用户响应 return responseBuilder.build(); } } 2.5 使用缓存：CacheInterceptor缓存拦截器会根据请求的信息和缓存的响应的信息来判断是否存在缓存可用，如果有可以使用的缓存，那么就返回该缓存该用户，否则就继续责任链来从服务器中获取响应。当获取到响应的时候，又会把响应缓存到磁盘上面。以下是这部分的逻辑： public final class CacheInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); // 根据请求和缓存的响应中的信息来判断是否存在缓存可用 CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; // 如果该请求没有使用网络就为空 Response cacheResponse = strategy.cacheResponse; // 如果该请求没有使用缓存就为空 if (cache != null) { cache.trackResponse(strategy); } if (cacheCandidate != null &amp;&amp; cacheResponse == null) { closeQuietly(cacheCandidate.body()); } // 请求不使用网络并且不使用缓存，相当于在这里就拦截了，没必要交给下一级（网络请求拦截器）来执行 if (networkRequest == null &amp;&amp; cacheResponse == null) { return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message(&quot;Unsatisfiable Request (only-if-cached)&quot;) .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); } // 该请求使用缓存，但是不使用网络：从缓存中拿结果，没必要交给下一级（网络请求拦截器）执行 if (networkRequest == null) { return cacheResponse.newBuilder().cacheResponse(stripBody(cacheResponse)).build(); } Response networkResponse = null; try { // 这里调用了执行链的处理方法，实际就是交给自己的下一级来执行了 networkResponse = chain.proceed(networkRequest); } finally { if (networkResponse == null &amp;&amp; cacheCandidate != null) { closeQuietly(cacheCandidate.body()); } } // 这里当拿到了网络请求之后调用，下一级执行完毕会交给它继续执行，如果使用了缓存就把请求结果更新到缓存里 if (cacheResponse != null) { // 服务器返回的结果是304，返回缓存中的结果 if (networkResponse.code() == HTTP_NOT_MODIFIED) { Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); cache.trackConditionalCacheHit(); // 更新缓存 cache.update(cacheResponse, response); return response; } else { closeQuietly(cacheResponse.body()); } } Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); // 把请求的结果放进缓存里 if (cache != null) { if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) { CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); } if (HttpMethod.invalidatesCache(networkRequest.method())) { try { cache.remove(networkRequest); } catch (IOException ignored) { // The cache cannot be written. } } } return response; } } 对缓存，这里我们使用的是全局变量 cache，它是 InternalCache 类型的变量。InternalCache 是一个接口，在 OkHttp 中只有一个实现类 Cache。在 Cache 内部，使用了 DiskLruCache 来将缓存的数据存到磁盘上。DiskLruCache 以及 LruCache 是 Android 上常用的两种缓存策略。前者是基于磁盘来进行缓存的，后者是基于内存来进行缓存的，它们的核心思想都是 Least Recently Used，即最近最少使用算法。我们会在以后的文章中详细介绍这两种缓存框架，也请继续关注我们的文章。 另外，上面我们根据请求和缓存的响应中的信息来判断是否存在缓存可用的时候用到了 CacheStrategy 的两个字段，得到这两个字段的时候使用了非常多的判断，其中涉及 Http 缓存相关的知识，感兴趣的话可以自己参考源代码。 2.6 连接复用：ConnectInterceptor连接拦截器 ConnectInterceptor 用来打开到指定服务器的网络连接，并交给下一个拦截器处理。这里我们只打开了一个网络连接，但是并没有发送请求到服务器。从服务器获取数据的逻辑交给下一级的拦截器来执行。虽然，这里并没有真正地从网络中获取数据，而仅仅是打开一个连接，但这里有不少的内容值得我们去关注。因为在获取连接对象的时候，使用了连接池 ConnectionPool 来复用连接。 public final class ConnectInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;); HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection); } } 这里的 HttpCodec 用来编码请求并解码响应，RealConnection 用来向服务器发起连接。它们会在下一个拦截器中被用来从服务器中获取响应信息。下一个拦截器的逻辑并不复杂，这里万事具备之后，只要它来从服务器中读取数据即可。可以说，OkHttp 中的核心部分大概就在这里，所以，我们就先好好分析一下，这里在创建连接的时候如何借助连接池来实现连接复用的。 根据上面的代码，当我们调用 streamAllocation 的 newStream() 方法的时候，最终会经过一系列的判断到达 StreamAllocation 中的 findConnection() 方法。 private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException { // ... synchronized (connectionPool) { // ... // 尝试使用已分配的连接，已经分配的连接可能已经被限制创建新的流 releasedConnection = this.connection; // 释放当前连接的资源，如果该连接已经被限制创建新的流，就返回一个Socket以关闭连接 toClose = releaseIfNoNewStreams(); if (this.connection != null) { // 已分配连接，并且该连接可用 result = this.connection; releasedConnection = null; } if (!reportedAcquired) { // 如果该连接从未被标记为获得，不要标记为发布状态，reportedAcquired 通过 acquire() 方法修改 releasedConnection = null; } if (result == null) { // 尝试供连接池中获取一个连接 Internal.instance.get(connectionPool, address, this, null); if (connection != null) { foundPooledConnection = true; result = connection; } else { selectedRoute = route; } } } // 关闭连接 closeQuietly(toClose); if (releasedConnection != null) { eventListener.connectionReleased(call, releasedConnection); } if (foundPooledConnection) { eventListener.connectionAcquired(call, result); } if (result != null) { // 如果已经从连接池中获取到了一个连接，就将其返回 return result; } boolean newRouteSelection = false; if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection.hasNext())) { newRouteSelection = true; routeSelection = routeSelector.next(); } synchronized (connectionPool) { if (canceled) throw new IOException(&quot;Canceled&quot;); if (newRouteSelection) { // 根据一系列的 IP 地址从连接池中获取一个链接 List&lt;Route&gt; routes = routeSelection.getAll(); for (int i = 0, size = routes.size(); i &lt; size; i++) { Route route = routes.get(i); // 从连接池中获取一个连接 Internal.instance.get(connectionPool, address, this, route); if (connection != null) { foundPooledConnection = true; result = connection; this.route = route; break; } } } if (!foundPooledConnection) { if (selectedRoute == null) { selectedRoute = routeSelection.next(); } // 创建一个新的连接，并将其分配，这样我们就可以在握手之前进行终端 route = selectedRoute; refusedStreamCount = 0; result = new RealConnection(connectionPool, selectedRoute); acquire(result, false); } } // 如果我们在第二次的时候发现了一个池连接，那么我们就将其返回 if (foundPooledConnection) { eventListener.connectionAcquired(call, result); return result; } // 进行 TCP 和 TLS 握手 result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, call, eventListener); routeDatabase().connected(result.route()); Socket socket = null; synchronized (connectionPool) { reportedAcquired = true; // 将该连接放进连接池中 Internal.instance.put(connectionPool, result); // 如果同时创建了另一个到同一地址的多路复用连接，释放这个连接并获取那个连接 if (result.isMultiplexed()) { socket = Internal.instance.deduplicate(connectionPool, address, this); result = connection; } } closeQuietly(socket); eventListener.connectionAcquired(call, result); return result; } 该方法会被放置在一个循环当中被不停地调用以得到一个可用的连接。它优先使用当前已经存在的连接，不然就使用连接池中存在的连接，再不行的话，就创建一个新的连接。所以，上面的代码大致分成三个部分： 判断当前的连接是否可以使用：流是否已经被关闭，并且已经被限制创建新的流； 如果当前的连接无法使用，就从连接池中获取一个连接； 连接池中也没有发现可用的连接，创建一个新的连接，并进行握手，然后将其放到连接池中。 在从连接池中获取一个连接的时候，使用了 Internal 的 get() 方法。Internal 有一个静态的实例，会在 OkHttpClient 的静态代码快中被初始化。我们会在 Internal 的 get() 中调用连接池的 get() 方法来得到一个连接。 从上面的代码中我们也可以看出，实际上，我们使用连接复用的一个好处就是省去了进行 TCP 和 TLS 握手的一个过程。因为建立连接本身也是需要消耗一些时间的，连接被复用之后可以提升我们网络访问的效率。那么这些连接被放置在连接池之后是如何进行管理的呢？我们会在下文中分析 OkHttp 的 ConnectionPool 中是如何管理这些连接的。 2.7 CallServerInterceptor服务器请求拦截器 CallServerInterceptor 用来向服务器发起请求并获取数据。这是整个责任链的最后一个拦截器，这里没有再继续调用执行链的处理方法，而是把拿到的响应处理之后直接返回给了上一级的拦截器： public final class CallServerInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { RealInterceptorChain realChain = (RealInterceptorChain) chain; // 获取 ConnectInterceptor 中初始化的 HttpCodec HttpCodec httpCodec = realChain.httpStream(); // 获取 RetryAndFollowUpInterceptor 中初始化的 StreamAllocation StreamAllocation streamAllocation = realChain.streamAllocation(); // 获取 ConnectInterceptor 中初始化的 RealConnection RealConnection connection = (RealConnection) realChain.connection(); Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); realChain.eventListener().requestHeadersStart(realChain.call()); // 在这里写入请求头 httpCodec.writeRequestHeaders(request); realChain.eventListener().requestHeadersEnd(realChain.call(), request); Response.Builder responseBuilder = null; if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) { if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) { httpCodec.flushRequest(); realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(true); } // 在这里写入请求体 if (responseBuilder == null) { realChain.eventListener().requestBodyStart(realChain.call()); long contentLength = request.body().contentLength(); CountingSink requestBodyOut = new CountingSink(httpCodec.createRequestBody(request, contentLength)); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); // 写入请求体 request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); realChain.eventListener() .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount); } else if (!connection.isMultiplexed()) { streamAllocation.noNewStreams(); } } httpCodec.finishRequest(); if (responseBuilder == null) { realChain.eventListener().responseHeadersStart(realChain.call()); // 读取响应头 responseBuilder = httpCodec.readResponseHeaders(false); } Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); // 读取响应体 int code = response.code(); if (code == 100) { responseBuilder = httpCodec.readResponseHeaders(false); response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); code = response.code(); } realChain.eventListener().responseHeadersEnd(realChain.call(), response); if (forWebSocket &amp;&amp; code == 101) { response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); } else { response = response.newBuilder() .body(httpCodec.openResponseBody(response)) .build(); } // ... return response; } } 2.8 连接管理：ConnectionPool与请求的缓存类似，OkHttp 的连接池也使用一个双端队列来缓存已经创建的连接： private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;(); OkHttp 的缓存管理分成两个步骤，一边当我们创建了一个新的连接的时候，我们要把它放进缓存里面；另一边，我们还要来对缓存进行清理。在 ConnectionPool 中，当我们向连接池中缓存一个连接的时候，只要调用双端队列的 add() 方法，将其加入到双端队列即可，而清理连接缓存的操作则交给线程池来定时执行。 在 ConnectionPool 中存在一个静态的线程池： private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */, Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp ConnectionPool&quot;, true)); 每当我们向连接池中插入一个连接的时候就会调用下面的方法，将连接插入到双端队列的同时，会调用上面的线程池来执行清理缓存的任务： void put(RealConnection connection) { assert (Thread.holdsLock(this)); if (!cleanupRunning) { cleanupRunning = true; // 使用线程池执行清理任务 executor.execute(cleanupRunnable); } // 将新建的连接插入到双端队列中 connections.add(connection); } 这里的清理任务是 cleanupRunnable，是一个 Runnable 类型的实例。它会在方法内部调用 cleanup() 方法来清理无效的连接： private final Runnable cleanupRunnable = new Runnable() { @Override public void run() { while (true) { long waitNanos = cleanup(System.nanoTime()); if (waitNanos == -1) return; if (waitNanos &gt; 0) { long waitMillis = waitNanos / 1000000L; waitNanos -= (waitMillis * 1000000L); synchronized (ConnectionPool.this) { try { ConnectionPool.this.wait(waitMillis, (int) waitNanos); } catch (InterruptedException ignored) { } } } } } }; 下面是 cleanup() 方法： long cleanup(long now) { int inUseConnectionCount = 0; int idleConnectionCount = 0; RealConnection longestIdleConnection = null; long longestIdleDurationNs = Long.MIN_VALUE; synchronized (this) { // 遍历所有的连接 for (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) { RealConnection connection = i.next(); // 当前的连接正在使用中 if (pruneAndGetAllocationCount(connection, now) &gt; 0) { inUseConnectionCount++; continue; } idleConnectionCount++; // 如果找到了一个可以被清理的连接，会尝试去寻找闲置时间最久的连接来释放 long idleDurationNs = now - connection.idleAtNanos; if (idleDurationNs &gt; longestIdleDurationNs) { longestIdleDurationNs = idleDurationNs; longestIdleConnection = connection; } } if (longestIdleDurationNs &gt;= this.keepAliveDurationNs || idleConnectionCount &gt; this.maxIdleConnections) { // 该连接的时长超出了最大的活跃时长或者闲置的连接数量超出了最大允许的范围，直接移除 connections.remove(longestIdleConnection); } else if (idleConnectionCount &gt; 0) { // 闲置的连接的数量大于0，停顿指定的时间（等会儿会将其清理掉，现在还不是时候） return keepAliveDurationNs - longestIdleDurationNs; } else if (inUseConnectionCount &gt; 0) { // 所有的连接都在使用中，5分钟后再清理 return keepAliveDurationNs; } else { // 没有连接 cleanupRunning = false; return -1; } } closeQuietly(longestIdleConnection.socket()); return 0; } 在从缓存的连接中取出连接来判断是否应该将其释放的时候使用到了两个变量 maxIdleConnections 和 keepAliveDurationNs，分别表示最大允许的闲置的连接的数量和连接允许存活的最长的时间。默认空闲连接最大数目为5个，keepalive 时间最长为5分钟。 上面的方法会对缓存中的连接进行遍历，以寻找一个闲置时间最长的连接，然后根据该连接的闲置时长和最大允许的连接数量等参数来决定是否应该清理该连接。同时注意上面的方法的返回值是一个时间，如果闲置时间最长的连接仍然需要一段时间才能被清理的时候，会返回这段时间的时间差，然后会在这段时间之后再次对连接池进行清理。 总结：以上就是我们对 OkHttp 内部网络访问的源码的分析。当我们发起一个请求的时候会初始化一个 Call 的实例，然后根据同步和异步的不同，分别调用它的 execute() 和 enqueue() 方法。虽然，两个方法一个会在当前的线程中被立即执行，一个会在线程池当中执行，但是它们进行网络访问的逻辑都是一样的：通过拦截器组成的责任链，依次经过重试、桥接、缓存、连接和访问服务器等过程，来获取到一个响应并交给用户。其中，缓存和连接两部分内容是重点，因为前者涉及到了一些计算机网络方面的知识，后者则是 OkHttp 效率和框架的核心。]]></content>
      <categories>
        <category>Android网络访问</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>计算机网络</tag>
        <tag>OkHttp</tag>
        <tag>源码阅读</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 体系详解：坐标系、滑动事件和分发机制]]></title>
    <url>%2F2018%2F10%2F14%2FView%20%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E6%BB%91%E5%8A%A8%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1、位置1.1 坐标系下面是 Android 中的 View 坐标系的基本图。要获得一个 View 的位置，我们可以借助两个对象，一个是 View ，一个是 MotionEvent。以下是它们的一些方法的位置的含义： 在 View 中共有 mLeft, mRight, mTop 和 mBottom 四个变量包含 View 的坐标信息，你可以在源码中获取它们的含义： mLeft：指定控件的左边缘距离其父控件左边缘的位置，单位：像素； mRight：指定控件的右边缘距离其父控件左边缘的位置，单位：像素； mTop：指定控件的上边缘距离其父控件上边缘的位置，单位：像素； mBottom：指定控件的下边缘距离其父控件上边缘的位置，单位：像素。 此外，View 中还有几个方法用来获取控件的位置等信息，实际上就是上面四个变量的 getter 方法： getLeft()：即 mLeft； getRight()：即 mRight； getTop()：即 mTop； getBottom()：即 mBottom； 所以，我们可以得到两个获取 View 高度和宽度信息的方法： getHeight()：即 mBottom - mTop； getWidth()：即 mRight - mLeft； 另外，就是 View 中的 getX() 和 getY() 两个方法，你需要注意将其与 MotionEvent 中的同名方法进行区分。在没有对控件进行平移的时候，getX() 与 getLeft() 返回结果相同，只是前者会在后者的基础上加上平移的距离： getX()：即 mLeft + getTranslationX()，即控件的左边缘加上 X 方向平移的距离； getY()：即 mTop + getTranslationY()，即控件的上边缘加上 Y 方向平移的距离； 以上是我们对 View 中获取控件位置的方法的梳理，你可以到源码中查看它们更加相详尽的定义，那更有助于自己的理解。 1.2 MotionEvent通常当你对控件进行触摸监听的时候会用到 MotionEvent ，它封住了触摸的位置等信息。下面我们对 MotionEvent 中的获取点击事件的位置的方法进行梳理，它主要涉及下面四个方法： MotionEvent.getX()：获取点击事件距离控件左边缘的距离，单位：像素； MotionEvent.getY()：获取点击事件距离控件上边缘的距离，单位：像素； MotionEvent.getRawX()：获取点击事件距离屏幕左边缘的距离，单位：像素； MotionEvent.getRawY()：获取点击事件距离屏幕上边缘的距离，单位：像素。 另外是触摸事件中的三种典型的行为，按下、移动和抬起。接下来的代码示例中我们会用到它们来判断手指的行为，并对其做响应的处理： MotionEvent.ACTION_DOWN：按下的行为； MotionEvent.ACTION_MOVE：手指在屏幕上移动的行为； MotionEvent.ACTION_UP：手指抬起的行为。 2、滑动我们有几种方式实现 View 的滑动： 2.1 layout() 方法调用控件的 layout() 方法进行滑动，下面是该方法的定义： 1public void layout(int l, int t, int r, int b) &#123; /*...*/ &#125; 其中的四个参数 l, t, r, b分别表示控件相对于父控件的左、上、右、下的距离，分别对应于上面的 mLeft, mTop, mRight 和 mBottom。所以，调用该方法同时可以改变控件的高度和宽度，但有时候我们不需要改变控件的高度和宽度，只要移动其位置即可。所以，我们又有方法 offsetLeftAndRight() 和 offsetTopAndBottom() 可以使用，后者只会对控件的位置进行平移。因此，我们可以进行如下的代码测试： private int lastX, lastY; private void layoutMove(MotionEvent event) { int x = (int) event.getX(), y = (int) event.getY(); switch (event.getAction()) { case MotionEvent.ACTION_DOWN: lastX = x; lastY = y; break; case MotionEvent.ACTION_MOVE: int offsetX = x - lastX, offsetY = y - lastY; getBinding().v.layout(getBinding().v.getLeft() + offsetX, getBinding().v.getTop() + offsetY, getBinding().v.getRight() + offsetX, getBinding().v.getBottom() + offsetY); break; case MotionEvent.ACTION_UP: break; } } 上面的代码的效果是指定的控件会随着手指的移动而移动。这里我们先记录下按下的位置，然后手指移动的时候记录下平移的位置，最后调用 layout() 即可。 2.2 offsetLeftAndRight() 和 offsetTopAndBottom()上面已经提到过这两个方法，它们只改变控件的位置，无法改变大小。我们只需要对上述代码做少量修改就可以实现同样的效果： getBinding().v.offsetLeftAndRight(offsetX); getBinding().v.offsetTopAndBottom(offsetY); 2.3 改变布局参数通过获取并修改控件的 LayoutParams，我们一样可以达到修改控件的位置的目的。毕竟，本身这个对象就代表着控件的布局： FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) getBinding().v.getLayoutParams(); lp.leftMargin = getBinding().v.getLeft() + offsetX; lp.topMargin = getBinding().v.getTop() + offsetY; getBinding().v.setLayoutParams(lp); 2.4 动画使用动画我们也可以实现控件移动的效果，这里所谓的动画主要是操作 View 的 transitionX 和 transitionY 属性： getBinding().v.animate().translationX(5f); getBinding().v.animate().translationY(5f); 关于动画的内容，我们会在后面详细介绍。 2.5 scrollTo() 和 scrollBy()scrollBy() 方法内部调用了 scrollTo()，以下是这部分的源码。scrollBy() 表示在当前的位置上面进行平移，而 scrollTo() 表示平移到指定的位置： public void scrollBy(int x, int y) { scrollTo(mScrollX + x, mScrollY + y); } 同样对上述代码进行修改，我们也可以实现之前的效果： ((View) getBinding().v.getParent()).scrollBy(-offsetX, -offsetY); 或者 View parent = ((View) getBinding().v.getParent()); parent.scrollTo(parent.getScrollX()-offsetX, parent.getScrollY()-offsetY); 此外，还有一个需要注意的地方是：与上面的 offsetLeftAndRight() 和 offsetTopAndBottom() 不同的是，这里我们用了平移的值的相反数。原因很简单，因为我们要使用这两个方法的时候需要对指定的控件所在的父容器进行调用（正如上面是先获取父控件）。当我们希望控件相对于之前的位置向右下方向移动，就应该让父容器相对于之前的位置向左上方向移动。因为实际上该控件相对于父控件的位置没有发生变化，变化的是父控件的位置。（参考的坐标系不同） 2.6 Scroller上面，我们的测试代码是让指定的控件随着手指移动，但是假如我们希望控件从一个位置移动到另一个位置呢？当然，它们也可以实现，但是这几乎就是在瞬间完成了整个操作，实际的UI效果肯定不会好。所以，为了让滑动的过程看起来更加流畅，我们可以借助 Scroller 来实现。 在使用 Scroller 之前，我们需要先实例化一个 Scroller ： private Scroller scroller = new Scroller(getContext()); 然后，我们需要覆写自定义控件的 computeScroll() 方法，这个方法会在绘制 View 的时候被调用。所以，这里的含义就是，当 View 重绘的时候会调用 computeScroll() 方法，而 computeScroll() 方法会判断是否需要继续滚动，如果需要继续滚动的时候就调用 invalidate() 方法，该方法会导致 View 进一步重绘。所以，也就是靠着这种不断进行重绘的方式实现了滚动的效果。 滑动效果最终结束的判断是通过 Scroller 的 computeScrollOffset() 方法实现的，当滚动停止的时候，该方法就会返回 false，这样不会继续调用 invalidate() 方法，因而也就不会继续绘制了。下面是该方法典型的覆写方式： @Override public void computeScroll() { super.computeScroll(); if (scroller.computeScrollOffset()) { ((View) getParent()).scrollTo(scroller.getCurrX(), scroller.getCurrY()); invalidate(); } } 然后，我们再加入一个滚动到指定位置的方法，在该方法内部我们使用了 2000ms 来指定完成整个滑动所需要的时间： public void smoothScrollTo(int descX, int descY) { scroller.startScroll(getScrollX(), getScrollY(), descX - getScrollX(), descY - getScrollY(), 2000); invalidate(); } 这样定义了之后，我们只需要在需要滚动的时候调用自定义 View 的 smoothScrollTo() 方法即可。 3、手势3.1 ViewConfiguration在类 ViewConfiguration 中定义了一些列的常量用来标志指定的行为，比如，TouchSlop 就是滑动的最小的距离。你可以通过 ViewConfiguration.get(context) 来获取 ViewConfiguration 实例，然后通过它的 getter 方法来获取这些常量的定义。 3.2 VelocityTrackerVelocityTracker 用来检测手指滑动的速率，它的使用非常简单。在使用之前，我们先使用它的静态方法 obtain() 获取一个实例，然后在 onTouch() 方法中调用它的 addMovement(MotionEvent) 方法： velocityTracker = VelocityTracker.obtain(); 随后，当我们想要获得速率的时候，先调用 computeCurrentVelocity(int) 传入一个时间片段，单位是毫秒，然后调用 getXVelocity() 和 getYVelocity() 分别获得在水平和竖直方向上的速率即可： velocityTracker.computeCurrentVelocity((int) duration); getBinding().tvVelocity.setText(&quot;X:&quot; + velocityTracker.getXVelocity() + &quot;\n&quot; + &quot;Y:&quot; + velocityTracker.getYVelocity()); 本质上，计算速率的时候是用指定时间的长度变化除以我们传入的时间片。当我们使用完了 VelocityTracker 之后，需要回收资源： velocityTracker.clear(); velocityTracker.recycle(); 3.3 GestureDectectorGestureDectector 用来检测手指的手势。在使用它之前我们需要先获取一个 GestureDetector 的实例： mGestureDetector = new GestureDetector(getContext(), new MyOnGestureListener()); 这里我们用了 GestureDetector 的构造方法，需要传入一个 OnGestureListener 对象。这里我们用了 MyOnGestureListener 实例。 MyOnGestureListener 是一个自定义的类，实现了 OnGestureListener 接口： private class MyOnGestureListener extends GestureDetector.SimpleOnGestureListener { @Override public boolean onSingleTapUp(MotionEvent e) { ToastUtils.makeToast(&quot;Click detected&quot;); return false; } @Override public void onLongPress(MotionEvent e) { LogUtils.d(&quot;Long press detected&quot;); } @Override public boolean onDoubleTap(MotionEvent e) { LogUtils.d(&quot;Double tab detected&quot;); return true; } @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) { LogUtils.d(&quot;Fling detected&quot;); return true; } } 在 MyOnGestureListener 中，我们覆写了它的一些方法。比如，单击、双击和长按等等，当检测到相应的手势的时候这些方法就会被调用。 然后，我们可以这样使用 GestureDetector，只要在控件的触摸事件回调中调用即可： getBinding().vg.setOnTouchListener((v, event) -&gt; { mGestureDetector.onTouchEvent(event); return true; }); 4、事件分发机制4.1 事件传递的过程当讨论事件分发机制的时候，我们首先要了解 Android 中 View 的组成结构。在 Android 中，一个 Activity 包含一个 PhoneWindow，当我们在 Activity 中调用 setContentView() 方法的时候，会调用该 PhoneWindow 的 setContentView() 方法，并在这个方法中生成一个 DecorView 作为 Activity 的跟 View。 根据上面的分析，当一个点击事件被触发的时候，首先接收到该事件的是 Activity。因为，Activity 覆盖了整个屏幕，我们需要先让它接收事件，然后它把事件传递给根 View 之后，再由根 View 向下继续传递。这样不断缩小搜索的范围，直到最顶层的 View。当然，任何的父容器都可以决定这个事件是不是要继续向下传递，因此，我们可以大致得到下面这个事件传递的图： 左边的图是一个 Activity 内部的 View 和 Window 的组织结构。右面的图可以看作它的切面图，其中的黑色箭头表示事件的传递过程。这里事件传递的过程是先从下到上，然后再从上到下。也就是从大到小，不断定位到触摸的控件，其中每个父容器可以决定是否将事件传递下去。（需要注意的地方是，如果一个父容器有多个子元素的话，那么在这些子元素中进行遍历的时候，顺序是从上往下的，也就是按照展示的顺序）。 上面我们分析了 Android 事件传递的过程，相信你有了一个大致的了解。但是，想要了解整个事件传递过程具体涉及了哪些方法、如何作用等，还需要我们对源码进行分析。 4.2 事件传递的原理当触摸事件发生的时候，首先会被 Activity 接收到，然后该 Activity 会通过其内部的 dispatchTouchEvent(MotionEvent) 将事件传递给内部的 PhoneWindow；接着 PhoneWindow 会把事件交给 DecorView，再由 DecorView 交给根 ViewGroup。剩下的事件传递就只在 ViewGroup 和 View 之间进行。我们可以通过覆写 Activity 的 dispatchTouchEvent(MotionEvent) 来阻止把事件传递给 PhoneWindow。实际上，在我们开发的时候不会对 Window 的事件传递方法进行重写，一般是对 ViewGroup 或者 View。所以，下面我们的分析只在这两种控件之间进行。 当讨论 View 的事件分发机制的时候，无外乎下面三个方法： boolean onInterceptTouchEvent(MotionEvent ev)：用来对事件进行拦截，该方法只存在于 ViewGroup 中。一般我们会通过覆写该方法来拦截触摸事件，使其不再继续传递给子 View。 boolean dispatchTouchEvent(MotionEvent event)：用来分发触摸事件，一般我们不覆写该方法，返回 true 则表示事件被处理了。在 View 中，它负责根据手势的类型和控件的状态对事件进行处理，会回调我们的 OnTouchListener 或者 OnClickListener；在 ViewGroup 中，该方法被覆写，它的责任是对事件进行分发，会对所有的子 View 进行遍历，决定是否将事件分发给指定的 View。 boolean onTouchEvent(MotionEvent event)：用于处理触摸事件，返回 true 表示触摸事件被处理了。ViewGroup 没有覆写该方法，故在 ViewGroup 中与 View 中的功能是一样的。需要注意的是，如果我们为控件设置了 OnTouchListener 并且在或者中返回了 true，那么这个方法不会被调用，也就是 OnTouchListener 比该方法的优先级较高。对我们开发来说，就是 OnTouchListener 比 OnClickListener 和 OnLongClickListener 的优先级要高。 于是，我们可以得到如下的伪代码。这段代码是存在于 ViewGroup 中的，也就是事件分发机制的核心代码： boolean dispatchTouchEvent(MotionEvent e) { boolean result; if (onInterceptTouchEvent(e)) { result = super.dispatchTouchEvent(e); } else { result = child.dispatchTouchEvent(e); } return result; } 按照上述分析，触摸事件经过 Activity 传递给根 ViewGroup 之后： 如果 ViewGourp 覆写了 onInterceptTouchEvent() 并且返回了 true 就表示希望拦截该方法，于是就把触摸事件交给当前 ViewGroup 进行处理（触发 OnTouchListener 或者 OnClickListener 等）；否则，会交给子元素的继续分发。如果该子元素是 ViewGroup 的话，就会在该子 View 中执行一遍上述逻辑，否则会在当前的子元素中对事件进行处理（触发 OnTouchListener 或者 OnClickListener 等）……就这样一层层地遍历下去，本质上是一个深度优先的搜索算法。 这里我们对整个事件分发机制的整体做了一个素描，在接下来的文章中我们会对各个方法的细节进行源码分析，为了防止您在接下来的行文中迷路，我们先把这个整体逻辑按下图进行描述： 4.3 事件传递的源码分析上述我们分析了事件分发机制的原理，下面我们通过源代码来更具体地了解这块是如何设计的。同样，我们的焦点也只在那三个需要重点关注的方法。 4.3.1 决定是否拦截事件首先，我们来看 ViewGroup 中的 dispatchTouchEvent(MotionEvent) 方法，我们节选了其一部分： @Override public boolean dispatchTouchEvent(MotionEvent ev) { // ... boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; if (actionMasked == MotionEvent.ACTION_DOWN) { // 1 // 这里表示如果是一个新的触摸事件就要重置所有的状态，其中包括将 mFirstTouchTarget 置为 null cancelAndClearTouchTargets(ev); resetTouchState(); } // 在这里检查是否拦截了事件，mFirstTouchTarget 是之前处理触摸事件的 View 的封装 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { // 这里判断该 ViewGroup 是否禁用了拦截，由 requestDisallowInterceptTouchEvent 设置 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); } else { intercepted = false; } } else { // 非按下事件并且 mFirstTouchTarget 为 null，说明判断过拦截的逻辑并且启用了拦截 intercepted = true; } // ... } // ... return handled; } 上面代码是我们节选的 ViewGroup 拦截事件的部分代码，这里的逻辑显然比伪代码复杂的多。不过，尽管如此，这些代码确实必不可少的。因为，当我们要去判断是否拦截一个触摸事件的时候，此时触摸的事件仍然在继续，这意味着这个方法会被持续调用；抬起的时候再按下，又是另一次调用。考虑到这个连续性，我们需要多做一些逻辑。 这里我们首先在 1 处通过行为是否是“按下”的来判断是否是一次新的触摸事件，如果是的话我们需要重置当前的触摸状态。其次，我们需要根据事件的类型来决定是否应该调用 onInterceptTouchEvent()，因为对一次触摸事件，我们只需要在“按下”的时候判断一次就够了。所以，显然我们需要将 MotionEvent.ACTION_DOWN 作为一个判断条件。然后，我们使用 mFirstTouchTarget 这个全局的变量来记录上次拦截的结果——如果之前的事件交给过子元素处理，那么它就不为空。 除了 mFirstTouchTarget，我们还需要用 mGroupFlags 的 FLAG_DISALLOW_INTERCEPT 标志位来判断该 ViewGroup 是否禁用了拦截。这个标志位可以通过 ViewGroup 的 requestDisallowInterceptTouchEvent(boolean) 来设置。只有没有禁用拦截事件的时候我们才需要调用 onInterceptTouchEvent() 判断是否开启了拦截。 4.3.2 分发事件给子元素如果在上面的操作中事件没有被拦截并且没有被取消，那么就会进入下面的逻辑。这部分代码处在 dispatchTouchEvent() 中。在下面的逻辑中会根据子元素的状态将事件传递给子元素： // 对子元素进行倒序遍历，即从上到下进行遍历 final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); // ... // 判断子元素是否能接收触摸事件：能接收事件并且不是正在进行动画的状态 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } // ... // 在这里调用了 dispatchTransformedTouchEvent() 方法将事件传递给子元素 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // ... 记录一些状态信息 // 在这里完成对 mFirstTouchTarget 的赋值，表示触摸事件被子元素处理 newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; // 结束循环，完成子元素的遍历 break; } // 显然，如果到了这一步，那么子元素的遍历仍将继续 } 当判断了指定的 View 可以接收触摸事件之后会调用 dispatchTransformedTouchEvent() 方法分发事件。其定义的节选如下： private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; // ... if (child == null) { // 本质上逻辑与 View 的 dispatchTouchEvent() 一致 handled = super.dispatchTouchEvent(transformedEvent); } else { // ... // 交给子元素继续分发事件 handled = child.dispatchTouchEvent(transformedEvent); } return handled; } dispatchTransformedTouchEvent() 会根据传入的 child 是否为 null 分成两种调用的情形：事件没有被拦截的时候，让子元素继续分发事件；另一种是当事件被拦截的时候，调用当前的 ViewGroup 的 super.dispatchTouchEvent(transformedEvent) 处理事件。 4.3.3 View 中的 dispatchTouchEvent上面我们分析的 dispatchTouchEvent(MotionEvent) 是 ViewGroup 中重写之后的方法。但是，正如我们上面的分析，重写之前的方法总是会被调用，只是对象不同。这里我们就来分析以下这个方法的作用。 public boolean dispatchTouchEvent(MotionEvent event) { // ... boolean result = false; // .... if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) { result = true; } // 这里回调了 setOnTouchListener() 方法传入的 OnTouchListener ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } // 如果 OnTouchListener 没有被回调过或者返回了 false，就会调用 onTouchEvent() 进行处理 if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } // ... return result; } 根据上面的源码分析，我们知道，如果当前的 View 设置过 OnTouchListener, 并且在 onTouch() 回调方法中返回了 true，那么 onTouchEvent(MotionEvent) 将不会得到调用。那么，我们再来看一下 onTouchEvent() 方法： public boolean onTouchEvent(MotionEvent event) { // ... // 判断当前控件是否是可以点击的：实现了点击、长按或者设置了可点击属性 final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; // ... if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) { switch (action) { case MotionEvent.ACTION_UP: // ... if (!focusTaken) { if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClick(); } } // ... break; case MotionEvent.ACTION_DOWN: // ... if (!clickable) { checkForLongClick(0, x, y); break; } // ... break; // ... } return true; } return false; } 这里先判断指定的控件是否是可点击的，即是否设置过点击或者长按的事件。然后会在手势抬起的时候调用 performClick() 方法，并会在这个方法中尝试从 ListenerInfo 取 OnClickListener 进行回调；会在长按的时候进行监听以调用相应长按事件；其他的事件与之类似，可以自行分析。所以，我们可以得出结论：当为控件的触摸事件进行了赋值并且在其中返回了 true 就代表该事件被消费了，即使设置过单击和长按事件也不会被回调，触摸事件的优先级比后面两者要高。 经过上述分析，我们可以知道 View 中的 dispatchTouchEvent(MotionEvent) 方法就是用来对手势进行处理的，所以回到 4.3.2，那里的意思就是：如果 ViewGroup 拦截了触摸事件，那么它就自己来对事件进行处理；否则就把触摸事件传递给子元素，让它来进行处理。 4.4.4 总结以上就是我们对 Android 中事件分发机制的详解，你可以通过图片和代码结合来更透彻得了解这方面的内容。虽然这部分代码比较多、比较长，但是每个地方的设计都是合情合理的。 源代码你可以在Github获取以上程序的源代码： Android-references。]]></content>
      <categories>
        <category>Android控件详解</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码阅读</tag>
        <tag>控件体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 体系详解：View 的工作流程]]></title>
    <url>%2F2018%2F10%2F14%2FView%20%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3%EF%BC%9AView%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、View 树的加载流程当我们调用 startActivity() 方法的时候，会调用到 ActivityThread 中的 performLaunchActivity() 获取一个 Activity 实例， 并在 Instrumentation 的 callActivityOnCreate() 方法中调用 Activity 的 onCreate() 完成 DecorView 的创建。这样我们就获取了一个 Activity 的实例，然后我们调用 handleResumeActivity() 来回调 Activity 的 onResume()： private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) { // .... WindowManagerGlobal.initialize(); // 创建 Activity 的实例，在这里完成对 Activity 的 onCreate() 方法的回调 Activity a = performLaunchActivity(r, customIntent); if (a != null) { // ... // 在这里回调 Activity 的 onResume() 方法 handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) { // 在这里完成对 Activity 的 onPause() 方法的回调 performPauseActivityIfNeeded(r, reason); // ... } } // ... } 然后，在 handleResumeActivity() 方法中的 performResumeActivity() 会回调 Activity 的 onResume() 方法。在该方法中，我们会从 Window 中获取之前添加进去的 DecorView，然后将其添加到 WindowManager 中： final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) { // 在这里会回调 Activity 的 onResume() r = performResumeActivity(token, clearHide, reason); if (r != null) { final Activity a = r.activity; // ... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) { r.window = r.activity.getWindow(); // 在这里获取 DecorView View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); // 获取 WindowManager 实例，实际是 WindowManagerImpl ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) { a.mWindowAdded = true; r.mPreserveWindow = false; // Activity 被重建，复用 DecorView，通知子元素 ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) { impl.notifyChildRebuilt(); } } if (a.mVisibleFromClient) { if (!a.mWindowAdded) { a.mWindowAdded = true; // 将 DecorView 添加到 WindowManager 中 wm.addView(decor, l); } else { a.onWindowAttributesChanged(l); } } } } } 这里的 WindowManager 是 WindowManagerImpl 的实例，而调用它的 addView() 方法的时候会使用 WindowManagerGlobal 的 addView() 方法。在该方法中会 new 出来一个 ViewRootImpl，然后调用它的 setView() 把传进来的 DecorView 添加到 Window 里。同时，会调用 requestLayout() 方法进行布局，然后，并最终调用 performTraversals() 完成对整个 View 树进行遍历： private void performTraversals() { // ... if (!mStopped || mReportNextDraw) { // ... performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); } // ... final boolean didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw); boolean triggerGlobalLayoutListener = didLayout || mAttachInfo.mRecomputeGlobalAttributes; if (didLayout) { performLayout(lp, mWidth, mHeight); // ... } // ... if (!cancelDraw &amp;&amp; !newSurface) { // ... performDraw(); } } 在该方法中会调用 performMeasure()、performLayout() 和 performDraw() 三个方法，它们分别会调用 DecorView 的 measure()、layout() 和 draw() 完成对整个 View 树的测量、布局和绘制，一个界面也就呈现给用户了。如果您做过自定义 View 的话，那么您对 onMeasure()、onLayout() 和 onDraw()三个方法一定不会陌生，前面的三个方法与后面的三个方法之间的关系就是：后面的三个方法会被前面的三个方法调用，本质上就是提供给用户用来自定义的方法。下面我们就看下这三个方法究竟各自做了什么操作，当然，我们尽可能从自定义控件的角度来分析，因为这对一个开发者可能帮助更大。 2、measure()View 的大小不仅由自身所决定，同时也会受到父控件的影响，为了我们的控件能更好的适应各种情况，一般会自己进行测量。在上面我们提到了 measure() 方法，它是用来测量 View 的大小的，但实际上测量的主要工作是交给 onMeasure() 方法的。在 View 中，onMeasure() 是一个 protected 的方法，显然它设计的目的就是：提供给子 View 按照父容器提供的限制条件，控制自身的大小，实现自己大小的测量逻辑。所以，当我们自定义一个控件的时候，只会去覆写 onMeasure() 而不去覆写 measure() 方法。 在 Android 中，我们的控件分成 View 和 ViewGroup 两种类型。根据上面的分析，对 View 的测量，我们可以得出如下结论：在 Android 中，ViewGroup 会根据其自身的布局特点，把限制条件封装成 widthMeasureSpec 和 heightMeasureSpec 两个参数传递给子元素；然后，在子元素中根据这两个参数来调整自身的大小。所以，ViewGroup 的 measure() 方法会根据其布局特性的不同而不同；而 View 的 measure()，不论其父容器是哪种类型，只根据 widthMeasureSpec 和 heightMeasureSpec 决定。 下面我们来看一下 onMeasure() 在 View 和 ViewGroup 中的不同表现形式。 2.1 View 的 onMeasure()下面是 View 类中的 onMeasure() 方法。这是一个默认的实现，调用了 setMeasuredDimension() 方法来存储测量之后的宽度和高度。当我们自定义 View 的时候，也需要调用 setMeasuredDimension() 方法把最终的测量结果存储起来： protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension( getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } 显然，我们的测量依据就是 widthMeasureSpec 和 heightMeasureSpec 两个参数。它们是整型的、32位变量，包含了测量模式和测量数值的信息（按位存储到整型变量上，包装成整型的目的是为了节约存储空间）。一般我们会像下面这样来分别获取高度和宽度的测量模式和测量数值（实际就是按位截取）： int widthsize = MeasureSpec.getSize(widthMeasureSpec); // 测量数值 int widthmode = MeasureSpec.getMode(widthMeasureSpec); // 测量模式 int heightsize = MeasureSpec.getSize(heightMeasureSpec); // 测量数值 int heightmode = MeasureSpec.getMode(heightMeasureSpec); // 测量模式 测量模式共有 MeasureSpec.UNSPECIFIED、MeasureSpec.AT_MOST 和 MeasureSpec.EXACTLY 三种，分别对应二进制数值 00、01 和 10，它们各自的含义如下： UNSPECIFIED：默认值，父控件没有给子 View 任何限制，子 View 可以设置为任意大小； EXACTLY：表示父控件已经确切的指定了子 View 的大小； AT_MOST：表示子 View 具体大小没有尺寸限制，但是存在上限，上限一般为父 View 大小。 这里，我不打算详细介绍 View 中默认测量逻辑的具体实现。它的大致逻辑是这样的：首先我们会用 getDefaultSize() 获取默认的宽度或者高度，这个方法接收两个参数，一个是默认的尺寸，一个测量模式。如果父控件没有给它任何限制，它就使用默认的尺寸，否则使用测量数值。这里的默认的尺寸通过 getSuggestedMinimumHeight()/getSuggestedMinimumWidth() 方法得到，它会根据背景图片高度/宽度和 mMinHeight/mMinWidth 的值，取一个最大的值作为控件的高度/宽度。 所以，View 的默认的测量逻辑的实际效果是：首先 View 的大小受父容器的影响，如果父容器没有给它限制的话，它会取背景图片和最小的高度或者宽度中取一个最大的值作为自己的大小。 2.2 ViewGroup 的 onMeasure()2.2.1 ViewGroup 中的方法由于 ViewGroup 本身没有布局的特点，所以它没有覆写 onMeasure()。有自身布局特点的，比如 LinearLayout 和 RelativeLayout 等都覆写并实现了这个方法。尽管如此，ViewGroup 提供了一些方法帮助我们进行测量，首先是 measureChildren() 方法： protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) { final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) { final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) { measureChild(child, widthMeasureSpec, heightMeasureSpec); } } } 这里的逻辑比较简单，就是对子元素进行遍历并判断如果指定的 View 是否位 GONE 的状态，如果不是就调用 measureChild() 方法： protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) { final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } 该方法也比较容易理解，就是将子元素的布局参数 LayoutParams 取出，获取它的宽度和高度之后，将所有信息传递给 getChildMeasureSpec()。这样就得到了用于子元素布局的 childWidthMeasureSpec 和 childHeightMeasureSpec 参数。然后，再调用子元素的 measure() 方法，从而依次完成对整个 View 树的遍历。下面我们看下 getChildMeasureSpec() 方法做了什么操作： public static int getChildMeasureSpec(int spec, int padding, int childDimension) { // 首先从 spec 中取出父控件的测量模式和测量数值 int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); // 这里需要保证 size 不能为负数，也就是预留给子元素的最大空间，由父元素的测量数值减去填充得到 int size = Math.max(0, specSize - padding); // 用于返回的值 int resultSize = 0; int resultMode = 0; // 根据父空间的测量模式 switch (specMode) { // 父控件的大小是固定的 case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) { // 子 View 指定了大小 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // 子元素希望大小与父控件相同（填满整个父控件） resultSize = size; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // 子元素希望有自己决定大小，但是不能比父控件大 resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // 父控件的具体大小没有尺寸限制，但是存在上限 case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) { // 子 View 指定了大小 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // 子控件希望与父控件大小一致，但是父控件的大小也是不确定的，故让子控件不要比父控件大 resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // 子控件希望自己决定大小，限制其不要比父控件大 resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // 父控件没有任何限制，可以设置为任意大小 case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) { // 子元素设置了大小 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // 子控件希望和父控件一样大，但是父控件多大都不确定；系统23以下返回true，以上返回size resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } else if (childDimension == LayoutParams.WRAP_CONTENT) { resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } break; } // 返回一个封装好的测量结果，就是把测量数值和测量模式封装成一个32位的整数 return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } 上面我们已经为这段代码作了非常详细的注释。只需要注意，这里在获取子元素的测量结果的时候是基于父控件的测量结果来的，需要根据父元素的测量模式和测量数值结合自身的布局特点分成上面九种情况。或者可以按照下面的写法将其划分成下面几种情况： public static int getChildMeasureSpec(int spec, int padding, int childDimension) { int specMode = MeasureSpec.getMode(spec), specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0, resultMode = 0; if (childDimension &gt;= 0) { // 子元素指定了具体的大小，就用子元素的大小 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) { // 子元素希望和父控件一样大，需要设置其上限，然后测量模式与父控件一致即可 if (specMode == MeasureSpec.EXACTLY || specMode == MeasureSpec.AT_MOST) { resultSize = size; resultMode = specMode; } else if (specMode == MeasureSpec.UNSPECIFIED) { // API23一下就是0，父控件没有指定大小的时候，子控件只能是0；以上是size resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) { // 子元素希望自己决定大小，设置其大小的上限是父控件的大小即可 if (specMode == MeasureSpec.EXACTLY || specMode == MeasureSpec.AT_MOST) { resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (specMode == MeasureSpec.UNSPECIFIED) { // API23一下就是0，父控件没有指定大小的时候，子控件只能是0；以上是size resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } } return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } 这两种方式只是划分的角度不一样，后面的这种方法是从子元素的布局参数上面来考虑的。另外，这里有个 sUseZeroUnspecifiedMeasureSpec 布尔参数需要提及一下，会根据系统的版本来进行赋值： sUseZeroUnspecifiedMeasureSpec = targetSdkVersion &lt; Build.VERSION_CODES.M; 也就是当系统是 API23 以下的时候的为 true. 加入这个参数的原因是，API23 之后，当父控件的测量模式是 UNSPECIFIED 的时候，子元素可以给父控件提供一个可能的大小。下面是注释的原话 ;-) // In M and newer, our widgets can pass a &quot;hint&quot; value in the size // for UNSPECIFIED MeasureSpecs. This lets child views of scrolling containers // know what the expected parent size is going to be, so e.g. list items can size // themselves at 1/3 the size of their container. It breaks older apps though, // specifically apps that use some popular open source libraries. 2.2.2 LinearLayout 的 onMeasure()上面我们分析的是 ViewGroup 中提供的一些方法，下面我们以 LinearLayout 为例，看一下一个标准的容器类型的控件是如何实现其测量的逻辑的。 下面是其 onMeasure() 方法，显然在进行测量的时候会根据其布局的方向分别实现测量的逻辑： protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { if (mOrientation == VERTICAL) { measureVertical(widthMeasureSpec, heightMeasureSpec); } else { measureHorizontal(widthMeasureSpec, heightMeasureSpec); } } 然后，我们以 measureVertical() 为例，来看一下 LinearLayout 在垂直方向上面是如何进行测量的。这段代码比较长，我们只截取其中的一部分来进行分析： void measureVertical(int widthMeasureSpec, int heightMeasureSpec) { // ... // 获取LinearLayout的测量模式 final int widthMode = MeasureSpec.getMode(widthMeasureSpec); final int heightMode = MeasureSpec.getMode(heightMeasureSpec); // ... mTotalLength += mPaddingTop + mPaddingBottom; int heightSize = mTotalLength; heightSize = Math.max(heightSize, getSuggestedMinimumHeight()); // ... for (int i = 0; i &lt; count; ++i) { final View child = getVirtualChildAt(i); if (child == null || child.getVisibility() == View.GONE) { continue; } final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final float childWeight = lp.weight; if (childWeight &gt; 0) { // ... // 获取一个测量的数值和测量模式 final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( Math.max(0, childHeight), MeasureSpec.EXACTLY); final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width); // 调用子元素进行测量 child.measure(childWidthMeasureSpec, childHeightMeasureSpec); childState = combineMeasuredStates(childState, child.getMeasuredState() &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT)); } final int margin = lp.leftMargin + lp.rightMargin; final int measuredWidth = child.getMeasuredWidth() + margin; maxWidth = Math.max(maxWidth, measuredWidth); boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT; alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth); allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT; final int totalLength = mTotalLength; // 将宽度增加到 mTotalLength 上 mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child)); } mTotalLength += mPaddingTop + mPaddingBottom; // ... maxWidth += mPaddingLeft + mPaddingRight; maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); // 最终确定测量的大小 setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState); // ... } 上面是 LinearLayout 在垂直方向上面的测量的过程，在测量的时候会根据子元素的布局将子元素的测量高度添加到 mTotalLength 上，然后再加上填充的大小，作为最终的测量结果。 3、layout() layout() 用于确定控件的位置，它提供了 onLayout() 来交给字类实现，同样我们在自定义控件的时候只要实现 onLayout() 方法即可。在我们自定义 View 的时候，如果定义的是非 ViewGroup 类型的控件，一般是不需要覆写 onLayout() 方法的。 下面我们先看一下 layout() 方法在 View 中的实现： public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { onLayout(changed, l, t, r, b); // ... } // ... } 这里会调用 setFrame() 方法，它的主要作用是根据新的布局参数和老的布局参数做一个对比，以判断控件的大小是否发生了变化，如果变化了的话就调用 invalidate() 方法并传入参数 true，以表明绘图的缓存也发生了变化。这里就不给出这个方法的具体实现了。然后注意到，在 layout() 方法中会回调 onLayout() 方法来完成各个控件的位置的确定。 对于 ViewGroup，它重写了 layout() 并在其中调用了 View 中的 layout() 方法，不过整体并没有做太多的逻辑。与测量过程类似，ViewGroup 并没有实现 onLayout 方法。同样，对于 ViewGroup 类型的控件，我们还是以 LinearLayout 为例说明一下 onLayout() 的实现逻辑： 与测量过程类似，LinearLayout 在 layout 的时候也根据布局的方向分成两种情形： protected void onLayout(boolean changed, int l, int t, int r, int b) { if (mOrientation == VERTICAL) { layoutVertical(l, t, r, b); } else { layoutHorizontal(l, t, r, b); } } 这里我们仍以垂直方向的方法为例。与测量的过程相比，layout 的过程的显得简单、清晰得多： void layoutVertical(int left, int top, int right, int bottom) { // ... // 根据控件的 gravity 特点得到顶部的位置 switch (majorGravity) { case Gravity.BOTTOM: childTop = mPaddingTop + bottom - top - mTotalLength; break; case Gravity.CENTER_VERTICAL: childTop = mPaddingTop + (bottom - top - mTotalLength) / 2; break; case Gravity.TOP: default: childTop = mPaddingTop; break; } // 遍历子控件 for (int i = 0; i &lt; count; i++) { final View child = getVirtualChildAt(i); if (child == null) { childTop += measureNullChild(i); } else if (child.getVisibility() != GONE) { final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); int gravity = lp.gravity; if (gravity &lt; 0) { gravity = minorGravity; } final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); // 得到子控件的左边的位置 switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) { case Gravity.CENTER_HORIZONTAL: childLeft = paddingLeft + ((childSpace - childWidth) / 2) + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: childLeft = childRight - childWidth - lp.rightMargin; break; case Gravity.LEFT: default: childLeft = paddingLeft + lp.leftMargin; break; } if (hasDividerBeforeChildAt(i)) { childTop += mDividerHeight; } childTop += lp.topMargin; // 本质上调用子控件的 layout() 方法 setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child, i); } } } 因为布局方向是垂直方向的，所以在对子元素进行遍历之前，先对自身的顶部的位置进行计算，然后再依次遍历子元素，并对顶部的高度不断叠加，最后调用 setChildFrame() 方法: private void setChildFrame(View child, int left, int top, int width, int height) { child.layout(left, top, left + width, top + height); } 这样就完成了对整个 View 树的 layout() 方法的调用。 4、draw()View 的 draw() 方法实现的逻辑也很清晰。在绘制的过程会按照如下的步骤进行： 绘制背景 保存 canvas 绘制自身的内容 绘制子控件 绘制 View 的褪色边缘，比如阴影效果之类的 绘制装饰，比如滚动条之类的 View 中提供了 onDraw() 方法用来完成对自身的内容的绘制，所以，我们自定义 View 的时候只要重写这个方法就可以了。当我们要自定义一个 ViewGroup 类型的控件的时候，一般是不需要重写 onDraw() 方法的，因为它只需要遍历子控件并依次调用它们的 draw() 方法就可以了。（当然，如果非要实现的话，也是可以的。） 下面是这部分代码，代码的注释中也详细注释了每个步骤的逻辑： public void draw(Canvas canvas) { final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) { drawBackground(canvas); } // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) { // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); drawAutofilledHighlight(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) { mOverlay.getOverlayView().dispatchDraw(canvas); } // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // Step 7, draw the default focus highlight drawDefaultFocusHighlight(canvas); if (debugDraw()) { debugDrawFocus(canvas); } // we&apos;re done... return; } // ... } 注意到在上面的方法中会调用 dispatchDraw(canvas) 方法来分发绘制事件给子控件来完成整个 View 树的绘制。在 View 中，这是一个空的方法，ViewGroup 覆写了这个方法，并在其中调用 drawChild() 来完成对指定的 View 的 draw() 方法的调用： protected boolean drawChild(Canvas canvas, View child, long drawingTime) { return child.draw(canvas, this, drawingTime); } 而对于 LinearLayout 这样本身没有绘制需求的控件，没有覆写 onDraw() 和 dispatchDraw(canvas) 等方法，因为 View 和 ViewGroup 中提供的功能已经足够使用。 总结：上文中，我们介绍了在 Android 系统中整个 View 树的工作的流程，从 DecorView 被加载到窗口中，到测量、布局和绘制三个方法的实现。本质上整个工作的流程就是对 View 树的一个深度优先的遍历过程。]]></content>
      <categories>
        <category>Android控件详解</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码阅读</tag>
        <tag>控件体系</tag>
      </tags>
  </entry>
</search>
