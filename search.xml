<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[五分钟学习 Java 8 的 Stream 编程]]></title>
    <url>%2F2018%2F11%2F11%2F%E4%BA%94%E5%88%86%E9%92%9F%E5%AD%A6%E4%B9%A0-Java-8-%E7%9A%84-Stream-%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、概述 Java8中在Collection中增加了一个stream()方法，该方法返回一个Stream类型。我们就是用该Stream来进行流编程的； 流与集合不同，流是只有在按需计算的，而集合是已经创建完毕并存在缓存中的； 流与迭代器一样都只能被遍历一次，如果想要再遍历一遍，则必须重新从数据源获取数据； 外部迭代就是指需要用户去做迭代，内部迭代在库内完成的，无需用户实现； 可以连接起来的流操作称为中间操作，关闭流的操作称为终端操作（从形式上看，就是用.连起来的操作中，中间的那些叫中间操作，最终的那个操作叫终端操作）。 2、筛选2.1 过滤Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); filter通过指定一个Predicate类型的行为参数对流中的元素进行过滤，最终还是会返回一个流，因为它是中间操作。中间操作返回的结果都是一个流，所以，如果我们想要得到一个集合或者其他的非流类型，就需要使用终端操作来获取。 List&lt;Integer&gt; list = Arrays.asList(1, 1, 2, 3, 4, 5, 5, 6, 7, 8, 9); List&lt;Integer&gt; filter = list.stream().filter(integer -&gt; integer &gt; 3).collect(Collectors.toList()); // [4, 5, 5, 6, 7, 8, 9] 2.2 去重Stream&lt;T&gt; distinct(); 上面就是去重的方法的定义，它会按照流中的元素的equal()和hashCode()方法进行去重。去重之后将继续返回一个流，所以它也是中间操作。 List&lt;Integer&gt; list = Arrays.asList(1, 1, 2, 3, 4, 5, 5, 6, 7, 8, 9); List&lt;Integer&gt; filter = list.stream().filter(integer -&gt; integer &gt; 3).distinct().collect(Collectors.toList()); // [4, 5, 6, 7, 8, 9] 2.3 限制Stream&lt;T&gt; limit(long maxSize); 就像是SQL里面的limit语句，在流中也有类似的limit()方法。它用于限制返回的结果的数量，将会从流的头开始取固定数量的元素，也是中间操作，使用完之后仍然会返回一个流。 List&lt;Integer&gt; list = Arrays.asList(1, 1, 2, 3, 4, 5, 5, 6, 7, 8, 9); List&lt;Integer&gt; filter = list.stream().filter(integer -&gt; integer &gt; 3).limit(3).collect(Collectors.toList()); // [4, 5, 5] 2.4 跳过Stream&lt;T&gt; skip(long n); 这个方法的定义和limit()几分相似。它也是中间操作，用于跳过从流的头开始指定数量的元素，使用完之后仍然会返回一个流。 List&lt;Integer&gt; list = Arrays.asList(1, 1, 2, 3, 4, 5, 5, 6, 7, 8, 9); List&lt;Integer&gt; filter = list.stream().filter(integer -&gt; integer &gt; 3).skip(3).collect(Collectors.toList()); // [6, 7, 8, 9] 3、映射&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 还记得Function函数接口的方法吗？它允许你把输入的类型转换成另一种类型。上面就是它在map()方法中的应用。在流操作中使用了该方法之后，流就会尝试将当前流中所有的元素转换成另一种类型。当你调用终端操作collect()的时候，自然也就得到了另一种类型的集合。 List&lt;Integer&gt; list = Arrays.asList(1, 1, 2, 3, 4, 5, 5, 6, 7, 8, 9); List&lt;String&gt; filter = list.stream().map((integer -&gt; String.valueOf(integer) + &quot;-&quot;)).collect(Collectors.toList()); // 结果：[1-, 1-, 2-, 3-, 4-, 5-, 5-, 6-, 7-, 8-, 9-] 4、查找Optional&lt;T&gt; findFirst(); Optional&lt;T&gt; findAny(); 在指定的流中查找元素的时候可以用这两个方法，它们是Stream接口中的方法，返回的已经不再是Stream类型了，这可以说明它们是终端操作。所以，通常也是用来放在终端，继续操作的话就要使用Optional接口的方法了。 List&lt;Integer&gt; list = Arrays.asList(1, 1, 2, 3, 4, 5, 5, 6, 7, 8, 9); Optional&lt;Integer&gt; optionalInteger = list.stream().filter(integer -&gt; integer &gt; 10).findAny(); Optional&lt;Integer&gt; optionalInteger = list.stream().filter(integer -&gt; integer &gt; 10).findFirst(); 上面是使用的两个示例，这里返回的结果是Optional类型的。Optional的设计借鉴了Guava中的Optional。使用它的好处是你不需要像以前一样将返回的结果与null进行判断，并在结果为null的时候通过=赋值一个默认值了。使用Optional中的方法，你可以更优雅地完成相同的操作。下面我们列出Optional中的一些常用的方法： 编号 方法 说明 1 isPresent() 判断值是否存在，存在的话就返回true，否则返回false 2 isPresent(Consumer block) 在值存在的时候执行给定的代码 3 T get() 如果值存在，那么返回该值；否则，抛出NoSuchElement异常 4 T orElse(T other) 如果值存在，那么返回该值；否则，则返回other 5、匹配boolean allMatch(Predicate&lt;? super T&gt; predicate); boolean noneMatch(Predicate&lt;? super T&gt; predicate); boolean anyMatch(Predicate&lt;? super T&gt; predicate); 从定义上面来看，上面的三个方法也是终端操作。它们分别用来判断：流中的数据是否全部匹配指定的条件，流中的数据是否全部不匹配指定的条件，流中的数据是否存在一些匹配指定的条件。下面是一些示例： List&lt;Integer&gt; list = Arrays.asList(1, 1, 2, 3, 4, 5, 5, 6, 7, 8, 9); boolean allMatch = list.stream().allMatch(integer -&gt; integer &lt; 10); boolean anyMatch = list.stream().anyMatch(integer -&gt; integer &gt; 3); boolean noneMatch = list.stream().noneMatch(integer -&gt; integer &gt; 100); 6、归约Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator); T reduce(T identity, BinaryOperator&lt;T&gt; accumulator); Stream接口中的reduce方法共有三个重载版本，上面我们给出常用的两个的定义。它们基本是类似的，只是第二个方法参数列表中多了个初始值，而没有初始值的那个，返回了Optinoal类型；所以，区别不大，我们只要搞明白它的行为就可以了。下面是归约的例子： List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;); String ret = list.stream().reduce(&quot;-&quot;, (a, b) -&gt; a + b); 它的输出结果是-abcdef，显然它的效果就是：假如，$是某种操作，List是某个”数列”，那么归约的意义就是初始值$n[0]$n[1]$n[2]$...$n[n-1]。 7、数值流同样是因为装箱的性能原因，Java8中为数值类型专门提供了数值流：IntStream DoubleStream和LongStream。Stream接口提供了三个中间方法来完成从任意流映射到数值流的操作： IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper); LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper); DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper); 所以你可以用上面三个方法从任意流中获取数值流。然后，再利用数值流的方法来完成其他的操作。上面三个数值流和Stream接口都继承子BaseStream，所以它们包含的方法还是有区别的，但总体上来说大同小异。Stream比较具有一般性，上面三个数值流更有针对性，后者也提供了许多便利的方法。如果想要从数值流中获取对象流，你可以调用它们的boxed()方法，来获取装箱之后的流。 这里稍提及一下，对于Optional，Java8也为我们提供了对应的数值类型：OptionalInt OptionalDouble OptionalLong。 在上面的三种数值流中还有几个静态方法用于获取指定数值范围的流： public static LongStream range(long startInclusive, final long endExclusive) public static LongStream rangeClosed(long startInclusive, final long endInclusive) 上面是用于获取指定范围的LongStream的方法，一个对应于数学中的开区间，一个对应于数学中的闭区间的概念。 8、构建流上面我们在获取流的时候，实际上都是从Collection的默认方法stream()中获取的流，这有些笨拙。实际上，Java8为我们提供了一些创建流的方法。这里，我们列举一下这些方法： public static&lt;T&gt; Builder&lt;T&gt; builder() // 1 public static&lt;T&gt; Stream&lt;T&gt; empty() // 2 public static&lt;T&gt; Stream&lt;T&gt; of(T t) // 3 public static&lt;T&gt; Stream&lt;T&gt; of(T... values) // 4 public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) // 5 public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s) // 6 public static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) // 7 上面的方法都是Stream接口中的静态方法，我们可以用这些方法来获取到流。下面我们对每个方法做一些简要的说明： 从名称上就可以看出这里使用了构建者模式，你可以每次调用Builder的add()方法插入一个元素来创建流； 用来创建一个空的流 创建一个只包含一个元素的流 使用不定参数创建一个包含指定元素的流 弄清楚它的原理关键是要搞明白后面的UnaryOperator的含义，这是一个函数式接口，并且继承自Function，不同之处在于它的入参和回参类型相同。这个方法的原理是从某个种子值开始，按照后面的函数的规则进行计算，每次是在之前的值的基础上执行某个函数的。所以Stream.iterate(2, n -&gt; n * n).limit(3)将返回由2 4 16构成的流。 这里的Supplier也是一个函数接口，它只有一个get()方法，无参，只接受指定类型的返回值。所以，这个方法需要你提供一个用于生成数值的函数（或者说规则），比如Math.random()等等。 这个比较容易理解，就是通过将两个流合并来得到一个新的流。 9、收集器上面我们已经见识过了流的规约操作，但是那些操作还比较幼稚。Java8的收集器为我们提供了更加强大的规约功能。 说起收集器，肯定绕不过两个类Collector和Collectors，它俩有啥关系呢？其实Collector只是一个接口；Collectors是一个类, 其中的静态内部类CollectorImpl实现了该接口，并且被Collectors用来提供一些功能。Collectors中有许多的静态方法用于获取Collector的实例，使用这些实例我们可以完成复杂的功能。当然，我们也可以通过实现Collector接口来定义自己的收集器。 Stream的collect()方法有3个重载的版本。我们就是通过其中的一个来使用收集器的，这是它的定义： &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector); 我们注意一下这个方法的参数和返回类型. 从上面我们可以看出传入的Collector有3个泛型,其中的最后一个泛类型R与返回的类型是一致的. 这很重要——可以预防你调用了某个方法却不知道最终返回的是什么类型。 我们先来看一些简单的例子，这里的stream是由Student对象构成的流： Optional&lt;Student&gt; student = stream.collect(Collectors.maxBy(comparator)) // 需要传入一个比较器到maxBy()方法中 long count = stream.collect(Collectors.counting()) 上面的两种方式比较鸡肋，因为你可以使用count()和max()方法来替代它们。下面我们再看一些收集器的其他例子，注意在这些例子中，我并没有使用lambda简化函数式接口，是因为想要你更清楚地看到它的泛类型和方法定义。这可能有助于你理解这些方法的作用机理。 9.1 计算平均值和总数下面的语句用于计算平均值，类似的还有summingInt()用于计算总数。它们的用法是相似的。 Double d = stream.collect(Collectors.averagingInt(new ToIntFunction&lt;Student&gt;() { @Override public int applyAsInt(Student value) { return value.getGrade(); } })); 从上面我们看出，调用averagingInt()方法的时候需要传入一个ToIntFunction函数式接口，用于根据指定的类型返回一个整数值。 9.2 连接字符串joining()工厂方法是专门用来连接字符串的，它要求流是字符串流，所以在对Student流进行拼接之前，需要先将其映射成字符串流： String members = stream.map(new Function&lt;Student, String&gt;() { @Override public String apply(Student student) { return student.getName(); } }).collect(Collectors.joining(&quot;, &quot;)); // 使用&apos;,&apos;将字符串拼接起来 9.3 广义的规约汇总Optional&lt;Student&gt; optional = stream.collect(Collectors.reducing(new BinaryOperator&lt;Student&gt;() { @Override public Student apply(Student student, Student student2) { return student.getGrade() &gt; student2.getGrade() ? student : student2; } })); 上面的就是用来规约的函数。我们用了reducing工厂方法，并向其中传入一个BinaryOperator类型。这里我们指定最终的返回类型是Student。所以，上面的代码的效果是获取成绩最大的学生。 9.4 分组Collectors中的分组还是比较有意思的。我们先看groupingBy方法的定义： Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier) Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Collector&lt;? super T, A, D&gt; downstream) groupingBy方法有3个重载的版本，这里我们给出其中常用的两个。第一个方法是通过指定规则对流进行分组的，而第二个方法先通过classifier指定的规则对流进行分组，然后用downstream的规则对分组后的流进行后续的操作。注意第二个参数仍然是Collector类型，这说明我们仍然可以对分组后的流再次收集，比如再分组、求最大值等等。 Map&lt;Integer, List&lt;Student&gt;&gt; map = stream.collect(Collectors.groupingBy(new Function&lt;Student, Integer&gt;() { @Override public Integer apply(Student student) { return student.getClazz(); } })); 以上是groupingBy()方法的第一个例子。注意这里我们是通过将Student通过’班级字段’映射成一个整数来进行分组的。下面是一个二次分组的例子。这里的用了上面的第二个groupingBy()方法，并在downstream中指定了另一个分组操作。 Map&lt;Integer, Map&lt;Integer, List&lt;Student&gt;&gt;&gt; map = stream.collect(Collectors.groupingBy(new Function&lt;Student, Integer&gt;() { @Override public Integer apply(Student student) { return student.getClazz(); } }, Collectors.groupingBy(new Function&lt;Student, Integer&gt;() { @Override public Integer apply(Student student) { return student.getGrade() == 100 ? 1 : student.getGrade() &gt; 90 ? 2 : student.getGrade() &gt; 80 ? 3 : 4; } }))); 9.5 分区与分组类似的还有一个分区的操作，分区只是分组的一种特例。它们的使用方式也基本一致，它的方法签名与上面的groupingBy方法类似。我们直接看它的一个使用的方式好了： Map&lt;Boolean, List&lt;Student&gt;&gt; map = stream.collect(Collectors.partitioningBy(new Predicate&lt;Student&gt;() { @Override public boolean test(Student student) { return student.getGrade() &gt; 90; } })); 这就是分区的使用方式。它通过一个指定的函数式接口，将指定的类型映射到一个布尔类型。所以，它类似与分组，只不过它分组的结果只有两种，要么true，要么false。当然，类似于分组，你也可以在partitioningBy()方法的第二个参数中再指定一个收集器，这样就可以对分区后的流进行后续的操作了。 总结：以上就是Java8中的流的常见的用法，这里只是列举了一些常见的、Java8 API中提供的一些类和方法。重点仍然是搞清楚其中的设计的原理，不要盲目记忆。学习的时候结合JDK源码进行，看到方法的定义就大致了解了它的设计原理。最后，不得不说的是，使用流编程确实很简洁和优雅。 相关代码：Github 如果您喜欢我的文章，可以在以下平台关注我： 个人主页：https://shouheng88.github.io/ 掘金：https://juejin.im/user/585555e11b69e6006c907a2a Github：https://github.com/Shouheng88 CSDN：https://blog.csdn.net/github_35186068 微博：https://weibo.com/u/5401152113]]></content>
      <categories>
        <category>Java编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java8</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五分钟学习 Java 8 行为参数化]]></title>
    <url>%2F2018%2F11%2F11%2F%E4%BA%94%E5%88%86%E9%92%9F%E5%AD%A6%E4%B9%A0-Java-8-%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1、概览Java8的改进比历史上任何一次改变都比较深远。Java不断改进也是编程语言生态变化的使然——诸如大数据需要在多核上面运行，而Java此前是不支持这种操作的。 在Java8之前，如果想要利用多个计算机的内核，你要使用线程，并且要处理复杂的同步逻辑。但是在Java8中，你可以很容易地使用流让自己的代码在多个内核上面执行。 此外，它还借鉴了其他语言和开源库的内容，比如Scala、Guava等。我们总结一下Java8的主要几个特征或者改进： 函数式编程和Lambda表达式； 流(Stream)编程； 时间API的改进； 默认方法 2、行为参数化“行为”就是指方法，“行为参数化”就是指将方法作为参数传入，说白了就是指策略模式。而Java8只是使用了Lambda表达式简化了匿名类的代码，使匿名类看起来更加简洁。在这块内容上，你所需要掌握的东西并不多。 2.1 Lambda表达式基本语法(parameters) -&gt; expression // 表达式 (parameters) -&gt; {statements;} // 语句，语句尾带分号且要用花括号括起来 上面是Lambda的基本语法，第一行中是Lambda中使用表达式的情况，第二行中式Lambda中使用语句的情况。 下面是一些使用Lambda表达式的示例： public static void main(String...args) { // 创建对象 ICreateObject createObject = Employee::new; IExpression expression = employees -&gt; employees.get(0); // 可以进一步简化为 IExpression expression2 = List::isEmpty; IExpression expression2 = employees -&gt; employees.isEmpty(); IConsumeObject consumeObject = employee -&gt; System.out.println(employee.name); IAdd add = (a, b) -&gt; a + b; IAdd add1 = Java8LambdaExample::cal; // 会报出不是Function接口异常 // Object object = Employee::new; } 从上面的示例代码，我们可以总结出一些结论： 所谓的函数接口就是指只包含一个非默认方法的接口，可以用@FunctionalInterface注解标明指定的接口是函数接口； 如果Lambda中的-&gt;后面的是语句，并且当该语句只有一行的时候，我们可以将花括号去掉； 想要将Lambda表达式赋值给一个对象的时候，如果这个对象不是函数接口，那么IDEA会给提示； 还要注意函数式接口是不允许抛出受检异常的。 下面我们总结一些常见的方法引用的示例： 上面代码中的Employee::new就是所谓的方法引用，下面是常见的方法引用的例子： 编号 Lambda 等效的方法引用 1 (Employee e)-&gt;e.getName() Employee::getName 2 (String s) -&gt; System.out.println(s) System.out::println 3 (str, i) -&gt; str.substring(i) String::substring 所以，我们总结下来的三种方法引用的情形： 编号 Lambda 等效的方法引用 1 (参数) -&gt; 类名.静态方法(参数) 类名::静态方法 2 (参数1, 其他参数) -&gt; 参数1.实例方法(其他参数) 类名::实例方法 3 (参数) -&gt; 表达式.实例方法(参数) 表达式::实例方法 2.2 Java API 中的函数式接口Java8的API中为我们提供了几个函数式接口，这些接口有必要了解一下。因为自从Java8开始接口可以定义默认方法了，所以这些接口里面又提供了一些有意思的默认方法。这可能对我们编程比较有帮助。 public interface Predicate&lt;T&gt; { boolean test(T t); } public interface Consumer&lt;T&gt; { void accept(T t); } public interface Function&lt;T, R&gt; { R apply(T t); } 上面就是这三个接口的定义。它们的应用场景的不同就体现再返回的参数上面： 第一个用来判断的，大致用来实现过滤的效果； 第二是没有返回类型，只能用来对传入的参数进行处理； 第三个是用来映射的，也就是说，当你想要实现的行为的参数和返回是不同的类型的时候可以用它（当然，如果是相同类型的话也是可以的）。 因为对于数值类型，Java需要做额外的装箱和拆箱的操作，这是需要成本的。所以，对于上面的三个接口（其他的接口也是），Java8中提供了不需要装箱的版本，也就是从泛型变成了数值类型而已。以IntPredicate为例： public interface IntPredicate { boolean test(int value); } 2.3 复合Lambda表达式Java8中提供的一些接口还是可以复合操作的。使用复合操作可以实现更复杂的逻辑。这些复合操作是以默认方法的形式定义的，每个函数式接口略有不同。所以，我们这里只列举出部分用于复合的方法。在实际的开发过程中，你可以直接进入到指定的函数式接口中查看这些方法的定义。 2.3.1 比较器Comparator假设有一个数据列表employees，其中的对象是Employee，它有getName()和getAge()两个方法。 employees.sort(Comparator.comparing(Employee::getName)); employees.sort(Comparator.comparing(Employee::getName).reversed().thenComparing(Employee::getAge)); 上面的两行代码中，第一行实现对employees按照getName()的结果进行排序。第二行代码对employees，先按照getName()的结果进行排序，然后将返回的结果逆序，再按照getAge()的结果进行排序。 2.3.2 谓词复合 negate()、or()和and()Predicate&lt;Employee&gt; employeePredicate = (employee -&gt; employee.getAge() &gt; 13) employeePredicate.negate() employeePredicate.and(employee -&gt; employee.getAge() &lt;= 15).or(employee -&gt; &quot;LiHua&quot;.equals(employee.getName())) 这里首先定义了employeePredicate，它可以用来过滤“年龄大于13的雇员”。对其调用了negate()方法将返回一个Predicate，可以用来过滤“年纪小于等于13的雇员”。最后的复合操作则表示“年龄大于13并且小于15的雇员或者名字为LiHua的雇员”。 注意，这里的and和or操作的顺序是从左向右的，也就是a.or(b).and(c)将被看作(a || b) and c。 2.3.3 函数Function复合Function有andThen和compose两个默认方法，它们都会返回一个Function实例。 Function&lt;Integer, Integer&gt; f = x -&gt; x + 1; Function&lt;Integer, Integer&gt; g = x -&gt; x * 2; Function&lt;Integer, Integer&gt; h1 = f.andThen(g); // h1(x) = g(f(x)) = (x + 1) * 2 Function&lt;Integer, Integer&gt; h2 = f.compose(g); // h2(x) = f(g(x)) = (x * 2) + 1 System.out.println(h1.apply(1)); System.out.println(h2.apply(1)); 上面是Function的复合操作的示例，其实它的效果就相当于数学中的复合函数。不过，应当注意一下两个方法的实际的复合效果是不同的。 总结以上就是Java8改进的第一部分，总结一下：行为参数化其实就是策略模式，使用Lambda可以简化函数接口的形式；Java API中提供了一些有用的函数式接口，这些接口又可以使用复合方法实现更加强大的功能。 我是 WngShhng. 如果您喜欢我的文章，可以在以下平台关注我： 个人主页：https://shouheng88.github.io/ 掘金：https://juejin.im/user/585555e11b69e6006c907a2a Github：https://github.com/Shouheng88 CSDN：https://blog.csdn.net/github_35186068 微博：https://weibo.com/u/5401152113]]></content>
      <categories>
        <category>Java编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java8</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础知识总结]]></title>
    <url>%2F2018%2F11%2F11%2FMySQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1、概述目前属于Oracle，分成社区版和企业版，关系型数据库。 1.1 目录结构 bin：存储可执行文件 data：存储数据文件 doc：文档 include：存储包含头文件 lib：存储库文件 share：错误消息和字符集 配置文件：my.ini 1.2 启动和停止在win cmd中使用net start/stop mysql来启动和停止mysql服务 1.3 登入和登出1.3.1 登入mysql -uuer_name -ppassword -Pport -hhost 可以只使用mysql -uuser_name -ppasswrod来开启，后面的可以使用默认的值。-P是指端口号，默认3306。-h是指地址，默认127.0.0.1。 1.3.2 登出在MySQL命令窗口输入：exit, quit和\q之中任意一个即可。 1.4 修改输入提示符在登入时，通过-prompt来指定提示符，或者在处于命令行时使用prompt来指定。 在指定提示符的时候可以使用\D, \d, \h和\u来指示提示符显示当前的日期、数据库、服务器和用户。 1.5 查询数据库信息使用SELECT VERSION(), SELECT NOW(), SELECT USER(), SELECT DATABASE()可以分别用来显示当前的数据库版本、时间、操作用户和数据库。 1.6 注释 行注释：-- 多行注释：/**/ 1.7 约定数据库操作指令大写；数据库相关的名称小写，且单词之间用下划线分开。 1.8 关于字符编码查看mysql中当前编码 show variables like &apos;char% 查看数据表的编码格式 mysql&gt; show create table &lt;表名&gt;; 创建数据库时指定数据库的字符集 mysql&gt;create database &lt;数据库名&gt; character set utf8; 创建数据表时指定数据表的编码格式 create table tb_books ( name varchar(45) not null, price double not null, bookCount int not null, author varchar(45) not null ) default charset = utf8; 修改数据库的编码格式 mysql&gt;alter database &lt;数据库名&gt; character set utf8; 修改数据表格编码格式 mysql&gt;alter table &lt;表名&gt; character set utf8; 修改字段编码格式 mysql&gt;alter table &lt;表名&gt; change &lt;字段名&gt; &lt;字段名&gt; &lt;类型&gt; character set utf8; window命令行中中文乱码问题，连接之后使用 set names gbk; 2、数据库操作2.1 创建CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] character_name DEFAULT用来说明使用默认编码方式。默认编码方式通过配置文件my.ini中的default-character-set中指定。 CHARACTER SET [=] character_name用来指定数据库的字符编码方式。 有了IF NOT EXISTS当指定数据库已经存在的时候，就不会报错了，否则会报错，但是报的错还是可以查找到的。 建立表的时候使用备注： CREATE TABLE test_table ( test_grade int DEFAULT 1 COMMENT &apos;等级&apos; ) COMMENT = &apos;测试表&apos;; 2.2 显示创建数据库的SQL语句SHOW CREATE DATABASE db_name; 类似的，还有显示表的创建的SQL语句：SHOW CREATE TABLE tbl_name; 2.3 修改修改数据库的字符编码方式的语句： ALTER {DATABASE|SCHEMA} [DEFAULT] CHARACTER SET [=] charset_name; 2.4 删除DROP {DATABASE|SCHEMA} [IF EXISTS] db_name 2.5 显示当前所有数据库SHOW DATABASES; 类似的，有SHOW TABLES [FROM db_name]用于显示当前数据库（或指定数据库）下面的所有表。 3、数据类型3.1 整型整数分为有符号和无符号的，通过UNSIGNED指定。（取值范围和C语言中的类型范围一样） TiNYINT：1字节 SMALLINT：2字节 MEDIUMINT：3字节 INT：4字节 BIGINT：8字节 3.2 浮点型浮点数也分为有符号的和无符号的。如下所示，前面的m指定了总的位数，后面的n指定了小数的位数，所以整数位数为m-n. 和C语言中的float和double范围一样。 FLOAT[(m,n)]： DOUBLE[(m,n)]： DECIMAL[(m,n)]：适用于高精度要求的场景 3.3 时间类型 YEAR：1字节，格式YYYY，范围1901-2155，零值0000 TIME：3字节，格式HH:MM:SS，范围-838:59:59-838:59:59，零值00:00:00 DATE：4字节，格式YYYY-MM-DD，范围1000-01-01-9999-12-31，零值0000-00-00 DATETIME：8字节，格式YYYY-MM-DD HH:MM:SS，范围1000-01-01 00:00:00-9999-12-31 23:59:59，零值0000-00-00 00:00:00 TIMESTAMP：4字节，格式YYYY-MM-DD HH:MM:SS，范围19700101080001-2038年的某个时刻，零值00000000000000 或者使用时间戳，用BIGINT保存指定时间的毫秒值。 3.4 字符型 CHAR(m)：m字节，0&lt;=m&lt;=255 VARCHAR(m)：L+1字节，L&lt;=m&lt;=65535 TINYTEXT：L+1字节，L&lt;28 TEXT：L+2字节，L&lt;216 MEDIUMEXT：L+3字节，L&lt;224 LONGTEXT：L+4字节，L&lt;232 ENUM(‘val1’, ‘val2’, …)：枚举类型，取决于枚举个数，最多65535 SET(‘val1’, ‘val2’, …)：主要用于对枚举进行组合选择 4、数据表的操作4.1 创建数据表CREATE TABLE [IF NOT EXISTS] table_name ( column_name data_type, ... ); 4.2 查看数据库的表查看指定数据库的所有的表 SHOW TABLES [FROM db_name][LIKE &apos;pattern&apos;|WHERE expr]; 4.3 查看列定义显示指定表的各个列的定义： SHOW COLUMNS FROM tbl_name; 4.4 约束4.4.1 表的空和非空在创建表的时候，在定义列的后面加上NOT NULL来指定指定的列不可为空。这样的列在插入记录的时候必须对其进行赋值。 4.4.2 自增自动编号，必须与主键组合使用。通过在创建表的时候在列定义后加入AUTO_INCREMENT来实现。此外，可以通过ALTER TABLE users AUTO_INCREMENT = 10000;来指定自增的开始值。 4.4.3 主键必须保证唯一性，一个表只能有一个，非NULL。创建表的时候使用PRIMARY KEY来指定列是主键。 4.4.4 唯一约束必须保证唯一性，一个表可以有多个，可以是NULL的。创建表的时候使用UNIQUE KEY来指定列是唯一的。 4.4.5 默认约束当指定的列没有指定值的时候就使用默认的值，在创建表的时候，通过使用DEFAULT关键字来指定列的默认值。 4.4.6 外键约束在实际开发过程中更多地使用逻辑外键而不是物理外键，就是只要保证表之间的关联关系就好，而不为表设置外键。因为外键要求创建表的时候，父表和子表都必须使用INNODB引擎。 4.5 修改表4.5.1 添加单列ALTER TABLE tbl_name ADD [COLUMN] col_name col_def [FIRST|AFTER col_name] 向指定的表中加入一列。通过FIRST指定新加入的列处于所有列的最前方，通过AFTER col_name指定新加入的列相对于某个列的位置。 4.5.2 添加多个列ALTER TABLE tbl_name ADD [COLUMN] (col_name col_def[, col_name col_def, ...]) 当向表中添加多个列的时候，只能将新加入列放在表的最后面的位置。 4.5.3 删除列ALTER TABLE tbl_name DROP [COLUMN] col_name[, col_name, ...] 可以指定并删除多个列。 4.5.4 添加约束ALTER TABLE tbl_name ADD [CONSTRAINT[symbol]] PRIMARY KEY [index_type](index_col_name) ALTER TABLE tbl_name ADD [CONSTRAINT[symbol]] UNIQUE [index_type](index_col_name) 上面的两条语句分别用来向指定的表中的列加入主键和唯一性约束。示例ALTER TABLE temp ADD UNIQUE(name)（列名上要加括号）。加入了主键和唯一性约束的同时会为指定的列加上索引，所以可以使用index_type来指定索引的类型。要为MySQL设置默认的索引，到my.ini中的default-storage-engine中进行设置即可。另外，可以使用SHOW INDEXES FROM tbl_name查看指定表中存在的索引。 4.5.5 删除约束ALTER TABLE tbl_name DROP PRIMARY KEY; ALTER TABLE DROP {INDEX|KEY} col_name; 4.5.6 修改表定义ALTER TABLE tbl_name MODIFY [COLUMN] col_name col_def [FIRST|AFTER col_name] 上面这种方式可以修改列的定义语句，它适用的范围比较广——可以通过在col_def中指定约束和数据类型来对列进行更多的修改。 ALTER TABLE tbl_name CHANGE [COLUMN] old_col_name new_col_name col_def [FIRST|AFTER col_name] 上面的修改语句的适用范围更广，它可以修改的范围包括：列的数据类型、约束、位置和名称。 4.5.7 修改表名ALTER TABLE tbl_name RENAME [TO|AS] new_tbl_name RENAME TABLE tbl_anem TO new_tbl_name [, tbl_name TO new_tbl_name...] 4.5.8 增加索引 主键索引, 添加PRIMARY KEY：ALTER TABLE tbl_name ADD PRIMARY KEY (col_name) 唯一索引, 添加UNIQUE：ALTER TABLE tbl_name ADD UNIQUE (col_name) 普通索引, 添加INDEX： ALTER TABLE ADD key(col_name)以及ALTER TABLE tbl_name ADD INDEX index_name (col_name) 全文索引, 添加FULLTEXT: ALTER TABLE tbl_name ADD FULLTEXT (col_name) 多列索引: ALTER TABLE tbl_name ADD INDEX index_name (col_name1, col_name2, ..) 5、插入操作向表中插入记录 INSERT [INTO] tbl_name [(col_name, ...)] {VALUES|VALUE} ({expr|DEFAULT}, ...), (...), ... 以上用来向指定数据库的指定列中插入数据，如果不指定了列的名称，就必须对表的所有的列进行赋值。可以为指定的列指定值，可以使用表达式，也可以使用默认值。 INSERT [INTO] tbl_name SET col_name = {expr|DEFAULT} [, col_name = {expr|DEFAULT}] INSERT [INTO] tbl_name [(col_name, ...)] SELECT ... 将查询结果插入到指定的表中。比如INSERT INTO temp (name) SELECT name FROM assignment 6、更新操作UPDATE [LOW_PRIORITY] [IGNORE] table_reference SET col_name1 = {expr|DEFAULT} [, col_name2 = {expr|DEFAULT}] ... [WHERE where_condition] 没有指定WHERE语句，就对整个表的全部记录进行更新。 7、删除操作DELETE FROM tbl_name [WHERE where_condition] 8、查找SELECT select_expr [, select_expr ...] [ FROM table_references [WHERE where_condition] [GROUP BY {col_name|position} [ASC|DESC], ... ] [HAVING having_condition] [ORDER BY {col_name|expr|position} [ASC|DESC], ...] [LIMIT {[offset,] row_count | row_count OFFSET offset}] ] 8.1 查找不同值将DISTINCT关键字放在指定的列前面，用于检索指定的列的不同的值。比如，select count(distinct cust_id) from orders;。 DISTINCT作用于所有的列，而不是其后的那一列。比如，select count(distinct cust_id, order_num) from orders;将搜索出cust_id不同并且order_num不同的列。 8.2 限制结果集、分页select * from orders limit 2 offerset 2; select * from orders limit 2 , 2; 类似于上面这样，前面的数字2表示查询的数目条数，后面的2表示从哪个位置开始。所以，上面的效果是查询第2条和第3条数据。但是，要注意的是数据库中条的编号的起始位置是0。如果不指定第二个2将查出所有数据中前两个记录。 8.3 排序结果集使用ORDER BY语句。可以指定多个列进行排序，可以为要排序的列指定排序的方向，使用ASC表示增序排列，使用DESC表示降序排列。默认，升序排列。除了使用列名来指定要排序的列，害可以使用列的在查询的所有列中的位置来指定排序的列。 DESC只应用到直接位于其前面的列，如果要为多个列进行降序，就应该每个列后面加上DESC。 8.4 过滤结果集8.4.1 WEHER子句操作符 等于 = 不等于 &lt;&gt;和!= 小于和小于等于 &lt;和&lt;= 大于和大于等于 &gt;和&gt;= 为NULL值IS NULL 处于两者之间BETWEEN BETWEEN实例： SELECT * FROM orders WHERE order_num BETWEEN 20006 AND 30000; 8.4.2 AND和OR操作符使用AND和OR操作符的时候要注意优先级是AND&gt;OR。比如， select * from orders where order_num = 20006 or order_num = 200005 and cust_id = 1000000001; 会被当成 select * from orders where order_num = 20006 or (order_num = 20005 and cust_id = 1000000001); 而如果我们想要表达的意思是： select * from orders where (order_num = 20006 or order_num = 200005) and cust_id = 1000000001; 因此就要在OR操作符上面增加圆括号。 8.4.3 IN操作符select * from orders where order_num in (20006, 20005); IN操作符其实完成的操作和OR一样。 8.4.4 NOT操作select * from orders where not order_num = 20005; 如上所示将not操作加在where条件的前面可以表示对条件的反。上面的效果就相当于where order_num != 20005 8.4.5 existsselect * from orders t where 1 = 1 and exists(select * from customers where cust_id = t.cust_id); 8.4.6 likeselect * from products where prod_name like &apos;%doll&apos;; 上面的是查找所有prod_name以doll结尾的记录。还可以，比如Fish%用来匹配所有以Fish开头的，F%y用来匹配以F开头并且以y结尾的记录。 通配符%可以用来匹配除NULL意外的记录，即WHERE prod_name like &#39;%&#39;不会找出prod_name为NULL的记录。 8.4.7 下划线下划线用来匹配指定数量的字符。一个下划线匹配一个字符。 8.5 创建计算字段8.5.1 拼接字符串select concat(cust_name,&apos;:&apos;,cust_city) from customers; 如上所示，使用concat函数可以将查询结果拼接起来。 8.5.2 使用别名select concat(cust_name,&apos;:&apos;,cust_city) as cust_city from customers; 如上所示，使用AS操作符来将拼接的字符串命名为cust_city. 8.5.3 使用正则表达式下面的是使用正则表达式对数据进行过滤的例子，即可以将REGEXP像like一样使用，并在REGEXP后面加上正则表达式即可。下面的表达式检索出的结果是，customers中所有cust_name中包含’Fun’的记录。 select * from customers where cust_name REGEXP &apos;Fun&apos;; 下面的SQL语句用来搜索出所有prod_name开头字符包含在1,2,8之内，并且字符后面是’ inch’的记录： select * from products where prod_name regexp &apos;[812] inch&apos; 8.6 分组数据8.6.1 分组过滤GROUP BYselect order_num, count(order_num) from orderitems group by order_num; 使用GROUP BY可以对数据进行分组，上面的效果是显示出指定order_num的记录的条数。 select t.*, sum(quantity*item_price) as total from orders as t, orderitems where t.order_num = orderitems.order_num group by order_num; 上面的语句的执行的结果是，得到了orders表的全部数据，以及每条订单对应的总价（根据orderitems表计算得出）。但是如果没有加入Group BY语句就无法得到上面的结果。 可以使用下面的两个SQL语句的执行结果来理解GROUP BY语句的效果： select sum(quantity*item_price) from orderitems; select sum(quantity*item_price) from orderitems group by order_num; 如果没加Group BY得到的是两个列的每条记录的两个字段相乘之后的总和，使用之后得到的是针对每个order_num的两个字段相乘之后的总和。前面的只得到了一条记录，后面的得到了针对每个order_num的记录。 下面的例子也使用了GROUP语句，但是这里在分组的时候的依据不是order_num而是cust_id。这样也是可以的，它得到的结果是：各个cust_id所应该支付的账单总额。 select sum(i.quantity*i.item_price) as total from orders as o, orderitems as i where o.order_num = i.order_num group by o.cust_id; 如果我们再关联一张customers表，来得到用户的名称，那么我们可以写成下面的样子： select c.cust_name as name, sum(i.quantity*i.item_price) as total from orderitems as i, orders as o, customers as c where i.order_num = o.order_num and c.cust_id = o.cust_id group by c.cust_id; 8.6.2 过滤分组HAVINGselect sum(quantity * item_price) as total from orderitems group by order_num having total &gt; 1000; 如上所示，我们使用HAVING语句来对分组之后的结果进行过滤。上面是找出总价值在1000以上的分组。 8.7 子查询下面的使用了子查询的语句执行的结果与上面的一样：指定名称用户的总额。 select c.cust_name, (select sum(i.quantity*i.item_price) from orderitems as i, orders as o where i.order_num = o.order_num and c.cust_id = o.cust_id group by o.cust_id) as total from customers as c; 上面的这种方式是将子查询用作计算字段。 子查询的另一种是用方式是将子查询的结果放在一个IN中作为取值范围。 8.8 联结表所谓的联结可以理解成按照指定的方式将两个或者多个表组合起来，形成一个类似于新的表。因为MySQL是关系型数据库，所以经常会在多个表之间存在一对多或者多对多关系，而联结的效果就是将这样的表联结起来。比如，如果两个数据库之间是一对多关系，那么肯定有些字段只存在于父表中，在查询的时候我们要将这些存在于父表中的字段与存在于子表中的字段组合起来，形成一个完整的“数据”，就应该使用联结来实现。 假如有这样的数据： 在表1中存储着：A0B0, A0B1在表2中存储着：A0C0, A0C1, A0C2 这里的A, B, C表示的是数据库的列中存储的记录。A表示一个列中的数据，B也表示列中的数据，AB构成一个记录。 那么，如果我们对表1和表2在A上面使用联结将得到的记录如下： B0C0, B0C1, B0C2, B1C0, B1C1, B1C2 这就相当于我们将B中的与A相关的字段补充了起来。 8.8.1 等值联结联结表的最常见的形式是使用=将两表的对应的字段连接起来，这叫做等值联结。 8.8.2 内联结下面是使用内联结的一个实现： select vend_name, prod_name from vendors as v inner join products as p on v.vend_id = p.vend_id; 内联结相当于对两个表在指定的列上面取交集，即只有两个表中都存在的字段才会进行联结。 8.8.3 自联结select * from customers as c1, customers as c2 where c1.cust_name = c2.cust_name and c2.cust_contact = &apos;Jim Jones&apos;; 上面的SQL语句的是自联结的，需要为两个相同的表分别指定一个别名。 8.8.4 外联结所谓的外联结，就是指左联结和右联结。它跟内联结不同的地方只在于，以左联结为例，如果左表中被用来指定联结的值在右表中不存在，那么也一样将左表中的记录检索出来，只是右表中指定的字段为NULL。 select vend_name, prod_name from vendors as v left join products as p on v.vend_id = p.vend_id; 比如上面的SQL中，如果vendors中的vend_id在右表中不存在，那么prod_name作为NULL。同理，可得右联结。 联结的语法： LEFT [OUTER] JOIN，左外连接。 RIGHT [OUTER] JOIN，右外连接。 这里的OUTER是可选的，有没有都行。 8.8.5 组合查询UNIONselect prod_name from products union select vend_name from vendors; 使用UNION可以将两个分别独立的SQL查询的结果合并起来。（但是要求两个SQL检索出的列的数目要相等，其实它的效果和OR差不多） 如果查询出来的两条记录一样，重复的行会被取消，可以使用UNION ALL关键字来替代UNION，这样重复的行就不会被取消。 使用UNION组合查询的时候，只能有一条ORDER BY子句，且必须位于最后一条SELECT语句的后面。 9、视图视图可以用来简化SQL操作，你可以将一次的查询结果作为一个视图，并为其添加一个名称，比如A。然后，我们可以像使用一个表一样从A中检索出数据。 视图的创建语句如下： create view orderdetail as select o.*, i.order_item, i.prod_id, i.quantity, i.item_price from orders as o left join orderitems as i on o.order_num = i.order_num; 即在一个标准的查询语句上面增加一个create view orderdetail as语句来创建视图。创建完毕视图之后，我们就可以像使用表一样从视图中检索数据。比如： select * from orderdetail order by cust_id; 10、存储过程存储过程和视图相似，也是提供一种SQL复用的机制。因为本身视图只能用来将指定的数据检索出来作为数据表一样使用，它本身只能用于“查询”操作，具有一定的局限性。因此，这里有存储过程来将指定功能的SQL封装起来，使其像一个函数一样可以被调用。 存储过程的可移植性比较差，而且需要更高的技能和经验，因此通过被限制创建。 10.1 创建存储过程10.1.1 创建无参存储过程在MySQL命令行中创建存储过程的示例： mysql&gt; delimiter // mysql&gt; create procedure mypp() -&gt; begin -&gt; select * from orders; -&gt; end// 在这里delimiter //的作用是使用//而不是’;’作为语句分隔符。 10.1.2 为存储过程添加参数MySQL支持IN（传递给存储过程）、 OUT（从存储过程传出，如这里所用）和INOUT（对存储过程传入和传出）类型的参数。 mysql&gt; create procedure avgprice(in num int, out price decimal(8,2)) -&gt; begin -&gt; select avg(item_price) -&gt; from orderitems -&gt; where order_num = num -&gt; into price; -&gt; end// 上面的语句中创建了一个名为avgprice的存储过程。它接受两个参数，num是传入的参数；price是传出的参数。在存储过程内部，我们为orderitems的指定order_num为num的所有记录的平均item_price赋值非price. 创建完毕了存储过程之后，我们可以像下面这样调用以上存储过程： call avgprice(20009, @price); 然后，我们可以使用SELECT语句得到price的计算结果： select @price 10.2 使用存储过程没有参数的存储过程的使用示例： call mypp(); 10.3 删除存储过程drop procedure mypp; 10.4 检查存储过程show create procedure avgprice; 11、游标MySQL游标只能用于存储过程（和函数） mysql&gt; create procedure copyprodname() -&gt; begin -&gt; --定义局部变量，结束条件 -&gt; declare done boolean default 0; -&gt; --定义局部变量，产品名称 -&gt; declare name varchar(255); -&gt; -&gt; --定义游标 -&gt; declare names cursor -&gt; for -&gt; select prod_name from products; -&gt; -&gt; --定义循环结束条件 -&gt; declare continue handler for sqlstate &apos;02000&apos; set done = 1; -&gt; -&gt; --创建表 -&gt; create table if not exists prod_name(name varchar(255)); -&gt; -&gt; --打开游标 -&gt; open names; -&gt; -&gt; --定义循环 -&gt; repeat -&gt; --获取游标的数据，将其填充到name中 -&gt; fetch names into name; -&gt; --将游标中的数据插入到prod_name表中 -&gt; insert into prod_name values(name); -&gt; --定义循环的结束条件 -&gt; until done end repeat; -&gt; -&gt; --结束游标 -&gt; close names; -&gt; end// 在上面的代码中，使用 declare done boolean default 0; 定义了循环的条件为布尔类型，并将其默认值设置为0. 然后，使用定义了循环结束的条件 declare continue handler for sqlstate &apos;02000&apos; set done = 1; 这里的’02000’是一个未找到条件， 当REPEAT由于没有更多的行供循环而不能继续时，出现这个条件。在使用游标之前，需要先打开游标。这通过SQL语句： open names; 来完成。当我们执行完业务逻辑之后，需要关闭游标。这通过SQL语句： close names; 来完成。在游标的打开和关闭的作用域内，我们通过 fetch names into name; 将从游标中得到的数据填充到name中。 12、触发器触发器用来在某事件发生时自动执行，有些类似于监听器的作用。它只能为delete, insert, update三种操作设置触发器。触发器可以设置在指定的操作执行之前或者之后触发。 只有表才支触发器，视图和临时表都不支持。 每个表最多设置6个触发器，且同一触发器不能与多个事件或多个表关联。 12.1 创建触发器触发器创建的基本语法格式： CREATE TRIGGER &lt;触发器名称&gt; --触发器必须有名字，最多64个字符 { BEFORE | AFTER } --触发器有执行的时间设置：可以设置为事件发生前或后。 { INSERT | UPDATE | DELETE } --触发的事件：insert、update或delete的过程中触发。 ON &lt;表名称&gt; --触发器是属于某一个表的:当在这个表上执行插入、 更新或删除操作的时候就触发。 FOR EACH ROW --触发器的执行间隔：FOR EACH ROW子句通知触发器 每隔一行执行一次动作，而不是对整个表执行一次。 &lt;触发器SQL语句&gt; --触发器包含所要触发的SQL语句：这里的语句可以是任何合法的语句， 包括复合语句，但是这里的语句受的限制和函数的一样。 触发器的使用示例： mysql&gt; create trigger watcher after insert on prod_name -&gt; for each row -&gt; begin -&gt; insert into prod_name_copy values(new.name); -&gt; end// 上面的触发器监听prod_name表的插入操作，每当向表prod_name中插入一条记录的同时向prod_name_copy也插入一条记录。 insert触发器代码内，可以引用一个名为new的虚拟表，访问被插入的行。 delete触发器代码内，可以引用一个名为old的虚拟表，访问被删除的行。 update触发器代码内，可以使用一个名为old的虚拟表，访问更新之前的数据，使用名为new的虚拟表，访问更新的值。 12.2 删除触发器DROP TRIGGER 触发器名称： 13、事务管理事务保证了一系列操作的原子性，只有当执行过程中没有产生错误，并且提交了之后才会将执行的结果反应到数据库上。如果使用了回滚操作将回复到开始事务之前的状态。 MySQL中的数据库引擎分别支持不同类型的事务。 13.1 基本的事务操作开始事务可以使用下面的语句： START TRANSACTION; 回滚事务使用： ROLLBACK; 提交事务使用： COMMIT; 13.2 创建保留点可以使用语句 SAVEPOINT 名称; 来创建保留点。在准备回滚的时候，我们可以使用 ROLLBACK TO 名称; 来回滚到指定的保留点。这样指定保留点之前的操作不会回滚，而保留点之后的操作将全部被会滚。 通常，保留点越多越好。当提交或者回滚之后，保留点会被自动释放。此外，也可以使用RELEASE来主动释放保留点。 13.3 修改默认提交行为使用 SET autocommit = 0; 来设置不自动提交。 14、安全管理在MySQL的数据库中存在一个mysql库，那里面的user表用于存储MySQL的用户。 create user shouheng identified by &apos;psd&apos;; 上面的SQL用来MySQL中添加一个用户。如果要对用户进行重命名，可以使用： rename user little_boy to shouheng; 如果删除用户可以使用： drop user username; 查看授予用户的权限： show grants for shouheng; 授予权限： grant select on sql_test_db.* to shouheng; 以上操作用来将sql_test_db的所有数据的只读权限授予指定用户。如果要回收指定用户的权限，可以使用 revoke select on sql_test_db.* from shouheng; 它表示回收指定用户对sql_test_db的只读权限。 除了上面示例的只读权限以外，MySQL还允许为新加入的用户指定其他权限。 为指定的用户修改密码： set password for shouheng = Password(&apos;psd&apos;); 如果您喜欢我的文章，可以在以下平台关注我： 个人主页：https://shouheng88.github.io/ 掘金：https://juejin.im/user/585555e11b69e6006c907a2a Github：https://github.com/Shouheng88 CSDN：https://blog.csdn.net/github_35186068 微博：https://weibo.com/u/5401152113]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 多线程编程：IntentService & HandlerThread]]></title>
    <url>%2F2018%2F11%2F11%2FAndroid-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%EF%BC%9AIntentService-HandlerThread%2F</url>
    <content type="text"><![CDATA[因为 Android 是使用 Java 开发的，所以当我们谈及 Android 中的多线程，必然绕不过 Java 中的多线程编程。但在这篇文章中，我们不会过多地分析 Java 中的多线程编程的知识。我们会在以后分析 Java 并发编程的时候分析 Java 中的多线程、线程池和并发 API 的用法。 我们先来总结一下 Android 多线程编程的演变过程：首先是 Java 的 Thread。因为本身在创建一个线程和销毁一个线程的时候会有一定的开销，当我们任务的执行时间相比于这个开销很小的时候，单独创建一个线程就显得不划算。所以，当程序中存在大量的、小的任务的时候，建议使用线程池来进行管理。但我们一般也很少主动去创建线程池，这是因为——也许是考虑到开发者自己去维护一个线程池比较复杂—— Android 中已经为我们设计了 AsyncTask。AsyncTask 内部封装了一个线程池，我们可以使用它来执行耗时比较短的任务。但 AsyncTask 也有一些缺点：1).如果你的程序中存在很多的不同的任务的时候，你可能要为每个任务定义一个 AsyncTask 的子类。2).从异步线程切换到主线程的方式不如 RxJava 简洁。所以，在实际开发的过程中，我通常使用 RxJava 来实现异步的编程。尤其是局部的优化、不值得专门定义一个 AsyncTask 类的时候，RxJava 用起来更加舒服。 上面的多线程创建的只是普通的线程，对系统来说，优先级比较低。在 Android 中还提供了 IntentService 来执行优先级相对较高的任务。启动一个 IntentService 任务的时候会将任务添加到其内部的、异步的消息队列中执行。此外，IntentService 又继承自 Service，所以这让它具有异步和较高的优先级两个优势。 在之前的文章中，我们已经分析过 AsyncTask、RxJava 以及用来实现线程切换的 Handler. 这里奉上这些文章的链接： 《Android AsyncTask 源码分析》 《RxJava2 系列 (1)：一篇的比较全面的 RxJava2 方法总结》 《RxJava2 系列 (2)：背压和Flowable》 《RxJava2 系列 (3)：使用 Subject》 《Android 消息机制：Handler、MessageQueue 和 Looper》 你可以通过以上的文章来了解这部分的内容。在本篇文章中，我们主要来梳理下另外两个多线程相关的 API，HandlerThread 和 IntentService。 1、异步消息队列：HandlerThread如果你之前还没有了解过 Handler 的实现的话，那么最好通过我们上面的那篇文章 《Android 消息机制：Handler、MessageQueue 和 Looper》 了解一下。因为 HandlerThread 就是通过封装一个 Looper 来实现的。 1.1 HandlerThread 的使用HandlerThread 继承自线程类 Thread，内部又维护了一个 Looper，Looper 内又维护了一个消息队列。所以，我们可以使用 HandlerThread 来创建一个异步的线程，然后不断向该线程发送任务。这些任务会被封装成消息放进 HandlerThread 的消息队列中被执行。所以，我们可以用 HandlerThread 来创建异步的消息队列。 在使用 HandlerThread 的时候有两个需要注意的地方： 因为 HandlerThread 内部的 Looper 的初始化和开启循环的过程都在 run() 方法中执行，所以，在使用 HandlerThread 之前，你必须调用它的 start() 方法。 因为 HandlerThread 的 run() 方法使用 Looper 开启一个了无限循环，所以，当不再使用它的时候，应该调用它的 quitSafely() 或 quit() 方法来结束该循环。 在使用 HandlerThread 的时候只需要创建一个它的实例，然后使用它的 Looper 来创建 Handler 实例，并通过该 Handler 发送消息来将任务添加到队列中。下面是一个使用示例： myHandlerThread = new HandlerThread(&quot;MyHandlerThread&quot;); myHandlerThread.start(); handler = new Handler( myHandlerThread.getLooper() ){ @Override public void handleMessage(Message msg) { // ... do something } }; handler.sendEmptyMessage(1); 这里我们创建了 HandlerThread 实例之后用它来创建 Handler 然后通过 Handler 把任务加入到消息队列中进行执行。 显然，使用 HandlerThread 可以很轻松地实现一个消息队列。你只需要在创建了 Handler 之后向它发送消息，然后所有的任务将被加入到队列中执行。当然，它也有缺点。因为所有的任务将会被按顺序执行，所以一旦队列中有某个任务执行时间过长，那么就会导致后续的任务都会被延迟处理。 1.2 HandlerThread 源码解析下面是该 API 的源码，实现也比较简单，我们直接通过注释来对主要部分进行说明： public class HandlerThread extends Thread { int mPriority; int mTid = -1; Looper mLooper; private @Nullable Handler mHandler; public HandlerThread(String name) { super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; } protected void onLooperPrepared() { } // 在这个方法开启了 Looper 循环，因为是一个无限循环，所以不适用的时候应该将其停止 @Override public void run() { mTid = Process.myTid(); Looper.prepare(); synchronized (this) { mLooper = Looper.myLooper(); notifyAll(); } Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; } // 获取该 HandlerThread 对应的 Looper public Looper getLooper() { if (!isAlive()) { return null; } synchronized (this) { while (isAlive() &amp;&amp; mLooper == null) { try { wait(); } catch (InterruptedException e) { } } } return mLooper; } public boolean quit() { Looper looper = getLooper(); if (looper != null) { looper.quit(); return true; } return false; } public boolean quitSafely() { Looper looper = getLooper(); if (looper != null) { looper.quitSafely(); return true; } return false; } // ... 无关代码 } 上面的代码比较简单明了，在 run() 方法中初始化 Looper 并执行。如果 Looper 还没有被创建，那么当调用 getLooper() 方法获取 Looper 的时候会让线程阻塞。当 Looper 创建完毕之后会唤醒所有阻塞的线程继续执行。另外，就是两个停止 Looper 的方法。它们基本上就是对 Looper 进行了一层封装。 2、IntentService2.1 使用 IntentServiceIntentService 继承自 Serivce，因此它比普通的多线程任务优先级要高。这使得它相比于普通的异步任务不容易被系统 kill 掉。它内部也是通过一个 Looper 来实现的，所以也是一种消息队列。在研究它的源码之前，我们先来看一下它的使用。 IntentService 的使用是比较简单的，只需要：1).继承它并实现其中的 onHandleIntent() 方法；2). 将 IntentService 注册到 manifest 中；3). 像开启一个普通的服务那样开启一个 IntentService 即可。下面是该类的一个使用示例： public class FileRecognizeTask extends IntentService { public static void start(Context context) { Intent intent = new Intent(context, FileRecognizeTask.class); context.startService(intent); } public FileRecognizeTask() { super(&quot;FileRecognizeTask&quot;); } @Override protected void onHandleIntent(@androidx.annotation.Nullable @Nullable Intent intent) { // 你的需要异步执行的业务逻辑 } } OK，介绍完了 IntentService 的使用，我们再来分析一下它的源码。 2.2 IntentService 源码分析实现 IntentService 的时候使用到了我们上面分析过的 HandlerThread. 首先，在 onCreate() 回调方法中创建了一个 HandlerThread，然后使用它的 Looper 创建了一个 ServiceHandler： HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); ServiceHandler 是 IntentSerice 的内部类，其定义如下： private final class ServiceHandler extends Handler { public ServiceHandler(Looper looper) { super(looper); } @Override public void handleMessage(Message msg) { onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); } } ServiceHandler 用来执行被添加到队列中的消息。它会回调 IntentService 中的 onHandleIntent() 方法，也就是我们实现业务逻辑的方法。当消息执行完毕之后，会调用 Service 的 stopSelf(int) 方法来尝试停止服务。注意这里调用的是 stopSelf(int) 而不是 stopSelf()。它们之间的区别是，当还存在没有完成的任务的时候 stopSelf(int) 不会立即停止服务，而 stopSelf() 方法会立即停止服务。 IntentSerivce 的 onCreate() 方法会在第一次启动的时候被调用，来创建服务。而 onStartCommond() 方法会在每次启动的时候被调用。下面是该方法的定义。 @Override public void onStart(@Nullable Intent intent, int startId) { Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); } @Override public int onStartCommand(@Nullable Intent intent, int flags, int startId) { onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; } onStartCommand() 内部调用了 onStart() 来处理请求。在 onStart() 方法中会通过 mServiceHandler 创建一个消息，并将该消息发送给 mServiceHandler. 该消息会在被 mServiceHandler 放进消息队列中排队，并在合适的时机被执行。 因此，我们可以总结一下 IntentService 的工作过程：首先，当我们第一次启动 IntentService 的时候会初始化一个 Looper 和 Handler；然后调用它的 onStartCommond() 方法，把请求包装成消息之后发送到消息队列中等待执行；当消息被 Handler 处理的时候会回调 IntentService 的 onHandleIntent() 方法来执行。此时，如果又有一个任务需要执行，那么 IntentService 的 onStartCommond() 方法会再次被执行并把请求封装之后放入队列中。当队列中的所有的消息都执行完毕，并且没有新加入的请求，那么此时服务就会自动停止，否则服务还会继续在后台执行。 这里，同样也应该注意下，IntentService 中的任务是按照被添加的顺序来执行的。 总结以上就是我们对 IntentService 和 HandlerThread 的分析。它们都是使用了 Handler 来实现，所以搞懂它们的前提是搞懂 Handler。关于 Handler，还是推荐一下笔者的另一篇文章 《Android 消息机制：Handler、MessageQueue 和 Looper》。 我是 WngShhng. 如果您喜欢我的文章，可以在以下平台关注我： 个人主页：https://shouheng88.github.io/ 掘金：https://juejin.im/user/585555e11b69e6006c907a2a Github：https://github.com/Shouheng88 CSDN：https://blog.csdn.net/github_35186068 微博：https://weibo.com/u/5401152113]]></content>
      <categories>
        <category>Android高阶编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迁移到 AndroidX 过程中遇到的各种问题]]></title>
    <url>%2F2018%2F11%2F11%2F%E8%BF%81%E7%A7%BB%E5%88%B0-AndroidX-%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[该博文用来整理开源项目 Android-References 迁移到 AndroidX 过程中遇到的各种问题。 👏 Android-References 是一个 Android 示例程序项目：包含了 MVP, MVVM, 组件化, ARouter, RxJava, EventBus, ButterKnife, 视频播放, 视频直播, 网络访问, 布局和控件整理等，感性却可以到 Gihub：https://github.com/Shouheng88/Android-references 参考源码。 因为该项目包含了各种 support 包控件，并且各种组件化、架构模式和各种常见的功能一应俱全，因此，比较具有代表性。这里我们使用它来作为一个示例来将我们的项目迁移到 AndroidX。 1、关于 AndroidX关于 AndroidX，可以参考: Hello world AndroidX AndroidX 用来统一 Android 中的 support 包，之前我们通过引入 support 包的各个版本来使用支持包，现在我们可以通过使用 AndroidX 来使用支持包。从长远来看这当然是大有好处的，可以避免使用支持包中遇到的版本冲突、升级带来的各种问题。 不过，如果项目完全迁移到 AndroidX 风险还是太大。如果项目紧急的话，引入 AndroidX 成本都有些高，主要是因为一些三方库的原因。虽然一些使用特别多的三方库，比如 Glide 等都已经开始支持 AndroidX。当然，还有一些潜在的问题，比如使用字符串来获取类的 Behavior 等，迁移的时候可能就不会被照顾到。 为了迁移到 AndroidX，Google 给开发者提供了一个工具：在 AS 的 Refactor 中提供了一项 Migrate to AndroidX 的选项。但选择了迁移之后，出现一些问题还需要开发者自己手动解决。 2、着手迁移2.1 第一个问题：Execution failed for task ‘:app:transformClassesWithMultidexlistForAlphaDebug’这里我们迁移之后在 build 的时候出现了标题的问题： 123* What went wrong:Execution failed for task &apos;:app:transformClassesWithMultidexlistForAlphaDebug&apos;.&gt; com.android.build.api.transform.TransformException: Error while generating the main dex list. 显然是将 class 转换成 dex 的过程中出现了一些问题，不过只是上面的这行日志我们无法定位问题。所以，我们需要让 gradle 输出更多的错误信息，于是我们执行： 1gradlew build --stacktrace 来让 Gradle 输出错误栈信息： 12345Caused by: com.android.builder.multidex.D8MainDexList$MainDexListException: com.android.tools.r8.errors.CompilationError: Program type already present: com.alibaba.android.arouter.routes.ARouter$$Group$$library at com.android.builder.multidex.D8MainDexList.generate(D8MainDexList.java:87) at com.android.build.gradle.internal.transforms.D8MainDexListTransform.transform(D8MainDexListTransform.kt:131) ... 54 more 显然是 ARouter$$Group$$library 类的问题，我们使用 Ctrl+N 来搜索这个类，发现出现了两个同样的类。这个类是使用阿里的 ARouter 的时候在编译期间生成的： 按照上面的错误提示，该类同时出现在了我们的两个模块 libraries 和 layout 下面，因而类冲突了。所以，接下来的问题就是要发现为什么会出现类冲突。 经过一层层排查发现是一个地方写错了： 这个是 layout 模块下面的冲突的类，我们发现它的路由地址是 /library/swipe_back，所以因为路由的地址是 library 的原因它在 layout 的模块下面生成了 ARouter$$Group$$Library。按照正确的写法它应该是出现在 layout 模块下面，并且路由的地址是 /layout/swipe_back，那样就应该被生成到 ARouter$$Group$$Layout 下面，就不会多出一个类 ARouter$$Group$$Library 了。 虽然，最终问题的原因很简单，但是我们看到，发现问题的过程中需要自己有思路的去排查，而不是除了问题立刻 Google 或者 SOF。 2.2 android.view.InflateException: Binary XML file line #14: Error inflating class修改了上面的问题之后，我们的程序可以编译并且安装了。 然后，我们又遇到下面的问题： 1android.view.InflateException: Binary XML file line #14: Error inflating class 这种问题比较常见，是 XML 的某个地方写错了，经过排查发现有一行代码，当我们为控件添加 Behavior 的时候使用了字符串形式的类名。在迁移的时候没有被照顾到： 事实上在 Google 的新的 material 包下面的 values.xml 文件中定义了一些 Behavior，新的包中这些字符串的值已经被替换过。但是像我们上面的这种情况，因为使用的是字符串而不是引用的资源，所以就没有被替换过去。因此，引用非自定义的 Behavior 的时候需要注意使用字符串资源进行引用而不是使用字符串： 2.3 android.view.InflateException: Binary XML file line #12: Binary XML file line #12: Error inflating class com.google.android.material.button.MaterialButton这里的类 Support28Activity 用来整理原来的 support-28 包里面的一些控件，迁移之后页面打开的时候立即崩溃。然后留下了一地鸡毛（异常）： 1java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;me.shouheng.references/me.shouheng.layout.view.support28.Support28Activity&#125;: android.view.InflateException: Binary XML file line #12: Binary XML file line #12: Error inflating class com.google.android.material.button.MaterialButton 我们尝试在程序中寻找 MaterialButton，发现确实能够找到这个类，但这里加载失败是什么原因呢？ 于是我们继续查看输出的错误日志，从这里我们获取到了更多的信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 Process: me.shouheng.references, PID: 22961 java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;me.shouheng.references/me.shouheng.layout.view.support28.Support28Activity&#125;: android.view.InflateException: Binary XML file line #12: Binary XML file line #12: Error inflating class com.google.android.material.button.MaterialButton at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3037) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3172) at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:78) at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:108) at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:68) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1906) at android.os.Handler.dispatchMessage(Handler.java:106) at android.os.Looper.loop(Looper.java:193) at android.app.ActivityThread.main(ActivityThread.java:6863) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:537) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858) Caused by: android.view.InflateException: Binary XML file line #12: Binary XML file line #12: Error inflating class com.google.android.material.button.MaterialButton Caused by: android.view.InflateException: Binary XML file line #12: Error inflating class com.google.android.material.button.MaterialButton Caused by: java.lang.reflect.InvocationTargetException at java.lang.reflect.Constructor.newInstance0(Native Method) at java.lang.reflect.Constructor.newInstance(Constructor.java:343) at android.view.LayoutInflater.createView(LayoutInflater.java:647) at android.view.LayoutInflater.createViewFromTag(LayoutInflater.java:790) at android.view.LayoutInflater.createViewFromTag(LayoutInflater.java:730) at android.view.LayoutInflater.rInflate(LayoutInflater.java:863) at android.view.LayoutInflater.rInflateChildren(LayoutInflater.java:824) at android.view.LayoutInflater.inflate(LayoutInflater.java:515) at android.view.LayoutInflater.inflate(LayoutInflater.java:423) at androidx.databinding.DataBindingUtil.inflate(DataBindingUtil.java:126) at androidx.databinding.DataBindingUtil.inflate(DataBindingUtil.java:95) at me.shouheng.commons.view.activity.CommonActivity.onCreate(CommonActivity.java:41) at android.app.Activity.performCreate(Activity.java:7149) at android.app.Activity.performCreate(Activity.java:7140) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1288) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3017) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3172) at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:78) at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:108) at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:68) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1906) at android.os.Handler.dispatchMessage(Handler.java:106) at android.os.Looper.loop(Looper.java:193) at android.app.ActivityThread.main(ActivityThread.java:6863) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:537) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858) Caused by: java.lang.IllegalArgumentException: The style on this component requires your app theme to be Theme.MaterialComponents (or a descendant). at com.google.android.material.internal.ThemeEnforcement.checkTheme(ThemeEnforcement.java:240) at com.google.android.material.internal.ThemeEnforcement.checkMaterialTheme(ThemeEnforcement.java:215) at com.google.android.material.internal.ThemeEnforcement.checkCompatibleTheme(ThemeEnforcement.java:143)2018-11-10 15:21:55.948 22961-22961/me.shouheng.references E/AndroidRuntime: at com.google.android.material.internal.ThemeEnforcement.obtainStyledAttributes(ThemeEnforcement.java:78) at com.google.android.material.button.MaterialButton.&lt;init&gt;(MaterialButton.java:140) at com.google.android.material.button.MaterialButton.&lt;init&gt;(MaterialButton.java:133) ... 27 more 按照后面几行的意思： 1Caused by: java.lang.IllegalArgumentException: The style on this component requires your app theme to be Theme.MaterialComponents (or a descendant). 这个错误是因为我们设置的主题照成的。按照上面的意思，我们需要更新自己的控件的主题到 Theme.MaterialComponents。除了切换控件的主题，我们可以更新应用的主题，我们可以让自己的应用主题继承 Material Components Bridge 主题： 123&lt;style name=&quot;Theme.MyApp&quot; parent=&quot;Theme.MaterialComponents.Light.Bridge&quot;&gt; &lt;!-- ... --&gt;&lt;/style&gt; 可以根据自己的需要选择继承下面的几种主题： 12345Theme.MaterialComponents.BridgeTheme.MaterialComponents.Light.BridgeTheme.MaterialComponents.NoActionBar.BridgeTheme.MaterialComponents.Light.NoActionBar.BridgeTheme.MaterialComponents.Light.DarkActionBar.Bridge 或者在你之前的 AppCompact 主题之上增加一些新的属性： 123456789101112131415161718192021222324252627282930313233&lt;style name=&quot;Theme.MyApp&quot; parent=&quot;Theme.AppCompat&quot;&gt; &lt;!-- Original AppCompat attributes. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/my_app_primary_color&lt;/item&gt; &lt;item name=&quot;colorSecondary&quot;&gt;@color/my_app_secondary_color&lt;/item&gt; &lt;item name=&quot;android:colorBackground&quot;&gt;@color/my_app_background_color&lt;/item&gt; &lt;item name=&quot;colorError&quot;&gt;@color/my_app_error_color&lt;/item&gt; &lt;!-- New MaterialComponents attributes. --&gt; &lt;item name=&quot;colorPrimaryVariant&quot;&gt;@color/my_app_primary_variant_color&lt;/item&gt; &lt;item name=&quot;colorSecondaryVariant&quot;&gt;@color/my_app_secondary_variant_color&lt;/item&gt; &lt;item name=&quot;colorSurface&quot;&gt;@color/my_app_surface_color&lt;/item&gt; &lt;item name=&quot;colorOnPrimary&quot;&gt;@color/my_app_color_on_primary&lt;/item&gt; &lt;item name=&quot;colorOnSecondary&quot;&gt;@color/my_app_color_on_secondary&lt;/item&gt; &lt;item name=&quot;colorOnBackground&quot;&gt;@color/my_app_color_on_background&lt;/item&gt; &lt;item name=&quot;colorOnError&quot;&gt;@color/my_app_color_on_error&lt;/item&gt; &lt;item name=&quot;colorOnSurface&quot;&gt;@color/my_app_color_on_surface&lt;/item&gt; &lt;item name=&quot;scrimBackground&quot;&gt;@color/mtrl_scrim_color&lt;/item&gt; &lt;item name=&quot;textAppearanceHeadline1&quot;&gt;@style/TextAppearance.MaterialComponents.Headline1&lt;/item&gt; &lt;item name=&quot;textAppearanceHeadline2&quot;&gt;@style/TextAppearance.MaterialComponents.Headline2&lt;/item&gt; &lt;item name=&quot;textAppearanceHeadline3&quot;&gt;@style/TextAppearance.MaterialComponents.Headline3&lt;/item&gt; &lt;item name=&quot;textAppearanceHeadline4&quot;&gt;@style/TextAppearance.MaterialComponents.Headline4&lt;/item&gt; &lt;item name=&quot;textAppearanceHeadline5&quot;&gt;@style/TextAppearance.MaterialComponents.Headline5&lt;/item&gt; &lt;item name=&quot;textAppearanceHeadline6&quot;&gt;@style/TextAppearance.MaterialComponents.Headline6&lt;/item&gt; &lt;item name=&quot;textAppearanceSubtitle1&quot;&gt;@style/TextAppearance.MaterialComponents.Subtitle1&lt;/item&gt; &lt;item name=&quot;textAppearanceSubtitle2&quot;&gt;@style/TextAppearance.MaterialComponents.Subtitle2&lt;/item&gt; &lt;item name=&quot;textAppearanceBody1&quot;&gt;@style/TextAppearance.MaterialComponents.Body1&lt;/item&gt; &lt;item name=&quot;textAppearanceBody2&quot;&gt;@style/TextAppearance.MaterialComponents.Body2&lt;/item&gt; &lt;item name=&quot;textAppearanceCaption&quot;&gt;@style/TextAppearance.MaterialComponents.Caption&lt;/item&gt; &lt;item name=&quot;textAppearanceButton&quot;&gt;@style/TextAppearance.MaterialComponents.Button&lt;/item&gt; &lt;item name=&quot;textAppearanceOverline&quot;&gt;@style/TextAppearance.MaterialComponents.Overline&lt;/item&gt;&lt;/style&gt; 显然，这里是要求你为了使自己的应用符合 Material 规范，需要预先定义一些属性值，然后会被应用到程序的控件中。 这里我们将主题稍做修改 123&lt;!--&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;--&gt;&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.MaterialComponents.Light.NoActionBar.Bridge&quot;&gt;&lt;/style&gt; 按照上面的方式，我们成功地打开了该页面。 2.4 java.lang.IllegalArgumentException: Invalid Region.Op - only INTERSECT and DIFFERENCE are allowed然而打开了页面不久就又发现了问题，这个问题出现在 MaterialButton 的点击的时候： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Process: me.shouheng.references, PID: 5730java.lang.IllegalArgumentException: Invalid Region.Op - only INTERSECT and DIFFERENCE are allowed at android.graphics.Canvas.checkValidClipOp(Canvas.java:779) at android.graphics.Canvas.clipRect(Canvas.java:826) at com.google.android.material.shape.MaterialShapeDrawable.prepareCanvasForShadow(MaterialShapeDrawable.java:850) at com.google.android.material.shape.MaterialShapeDrawable.draw(MaterialShapeDrawable.java:746) at android.view.View.getDrawableRenderNode(View.java:20622) at android.view.View.drawBackground(View.java:20558) at android.view.View.draw(View.java:20357) at android.view.View.updateDisplayListIfDirty(View.java:19241) at android.view.View.draw(View.java:20094) at android.view.ViewGroup.drawChild(ViewGroup.java:4337) at androidx.coordinatorlayout.widget.CoordinatorLayout.drawChild(CoordinatorLayout.java:1246) at android.view.ViewGroup.dispatchDraw(ViewGroup.java:4116) at android.view.View.updateDisplayListIfDirty(View.java:19232) at android.view.View.draw(View.java:20094) at android.view.ViewGroup.drawChild(ViewGroup.java:4337) at android.view.ViewGroup.dispatchDraw(ViewGroup.java:4116) at android.view.View.updateDisplayListIfDirty(View.java:19232) at android.view.View.draw(View.java:20094) at android.view.ViewGroup.drawChild(ViewGroup.java:4337) at android.view.ViewGroup.dispatchDraw(ViewGroup.java:4116) at android.view.View.updateDisplayListIfDirty(View.java:19232) at android.view.View.draw(View.java:20094) at android.view.ViewGroup.drawChild(ViewGroup.java:4337) at android.view.ViewGroup.dispatchDraw(ViewGroup.java:4116) at android.view.View.updateDisplayListIfDirty(View.java:19232) at android.view.View.draw(View.java:20094) at android.view.ViewGroup.drawChild(ViewGroup.java:4337) at android.view.ViewGroup.dispatchDraw(ViewGroup.java:4116) at android.view.View.updateDisplayListIfDirty(View.java:19232) at android.view.View.draw(View.java:20094) at android.view.ViewGroup.drawChild(ViewGroup.java:4337) at android.view.ViewGroup.dispatchDraw(ViewGroup.java:4116) at android.view.View.draw(View.java:20369) at com.android.internal.policy.DecorView.draw(DecorView.java:781) at android.view.View.updateDisplayListIfDirty(View.java:19241) at android.view.ThreadedRenderer.updateViewTreeDisplayList(ThreadedRenderer.java:690) at android.view.ThreadedRenderer.updateRootDisplayList(ThreadedRenderer.java:696) at android.view.ThreadedRenderer.draw(ThreadedRenderer.java:805) at android.view.ViewRootImpl.draw(ViewRootImpl.java:3515) at android.view.ViewRootImpl.performDraw(ViewRootImpl.java:3312) at android.view.ViewRootImpl.performTraversals(ViewRootImpl.java:2681) at android.view.ViewRootImpl.doTraversal(ViewRootImpl.java:1633) at android.view.ViewRootImpl$TraversalRunnable.run(ViewRootImpl.java:7786) at android.view.Choreographer$CallbackRecord.run(Choreographer.java:1004) at android.view.Choreographer.doCallbacks(Choreographer.java:816) at android.view.Choreographer.doFrame(Choreographer.java:751) at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:990) at android.os.Handler.handleCallback(Handler.java:873) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loop(Looper.java:193) at android.app.ActivityThread.main(ActivityThread.java:6863) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:537) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858) 经过排查发现，在 com.google.android.material.shape.MaterialShapeDrawable 中的 prepareCanvasForShadow() 方法中使用了 Region.Op.REPLACE， 12345private void prepareCanvasForShadow(Canvas canvas) &#123; // ... 无关代码 canvas.clipRect(canvasClipBounds, Region.Op.REPLACE); // ... 无关代码&#125; 而在 support-28 中增加了下面的校验（这个校验在 support-27 上面是不存在的），显然是因为我们使用了 Region.Op.REPLACE 属性的原因： 1234567private static void checkValidClipOp(@NonNull Region.Op op) &#123; if (sCompatiblityVersion &gt;= Build.VERSION_CODES.P &amp;&amp; op != Region.Op.INTERSECT &amp;&amp; op != Region.Op.DIFFERENCE) &#123; throw new IllegalArgumentException( &quot;Invalid Region.Op - only INTERSECT and DIFFERENCE are allowed&quot;); &#125;&#125; 在该方法上面有真么几行注释： 1Region.Op values other than Region.Op.INTERSECT and Region.Op.DIFFERENCE have the ability to expand the clip. The canvas clipping APIs are intended to only expand the clip as a result of a restore operation. This enables a view parent to clip a canvas to clearly define the maximal drawing area of its children. The recommended alternative calls are clipRect(Rect) and clipOutRect(Rect) 大体意思是：Region.Op.INTERSECT和Region.Op.DIFFERENCE以外的Region.Op值可以展开 Clip。画布剪辑API仅用于在还原操作后展开Clip。这使视图父级能够剪切画布以清楚地定义其子画面的最大绘制区域。推荐调用clipRect（Rect）和clipOutRect（Rect）. 虽然我们找到了问题的原因，但是这个类究竟是在哪里用到的我们还无法定位到，因此，我们还需要进一步进行排查。 经过排查，我们发现出现问题的原因是 material 包中的 BottomAppBar 控件。其实从上面的栈中我们也可以看出这一点：明显是在绘制 View 树的子 View 的时候出现的异常，而且是绘制 CoordinatorLayout。在 BottomAppBar 中使用了 materialShapeDrawable，该变量是 MaterialShapeDrawable。正是出现问题的罪魁祸首。 这个类MaterialShapeDrawable是用来实现 BottomBar 的阴影效果的，虽然它是 BottomBar 的内部类，但是如果不希望它调用上面的那个方法也是可以的。 首先，我发现它要先判断是否具有阴影再调用绘制阴影的方法： 1234567 if (hasCompatShadow()) &#123; // Save the canvas before changing the clip bounds. canvas.save(); prepareCanvasForShadow(canvas);// ...无关代码 &#125; 而这里的判断是否具有阴影的方法如下： 12345private boolean hasCompatShadow() &#123; return shadowCompatMode != SHADOW_COMPAT_MODE_NEVER &amp;&amp; shadowCompatRadius &gt; 0 &amp;&amp; (shadowCompatMode == SHADOW_COMPAT_MODE_ALWAYS || requiresCompatShadow());&#125; 我们可以通过为 BottomBar 设置移除阴影效果来避免这个类调用绘制阴影的方法。于是， 123456789&lt;com.google.android.material.bottomappbar.BottomAppBar android:id=&quot;@+id/bottom_app_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:layout_gravity=&quot;bottom&quot; app:backgroundTint=&quot;@color/colorAccent&quot; app:fabAlignmentMode=&quot;center&quot; app:elevation=&quot;0dp&quot; app:layout_behavior=&quot;@string/hide_bottom_view_on_scroll_behavior&quot;/&gt; 虽然效果不好看，但是阴影解决了。 2.5 android.view.InflateException: Binary XML file line #24: Binary XML file line #24: Error inflating class com.google.android.material.floatingactionbutton.FloatingActionButton在排查上面问题的过程中，我们同样发现了 FAB 的一个问题。这个 Material 包中的 FAB 与 Support-28 包中的相比做了一些调整。且看下面的异常信息。这里问题显然是类无法记载造成的。那么具体是因为什么呢？我们往下看到错误栈的最后几行，发现是有一个属性没有找到。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950512018-11-10 16:56:48.408 27581-27581/me.shouheng.references E/AndroidRuntime: FATAL EXCEPTION: main Process: me.shouheng.references, PID: 27581 java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;me.shouheng.references/me.shouheng.layout.view.support28.BottomAppBarActivity&#125;: android.view.InflateException: Binary XML file line #24: Binary XML file line #24: Error inflating class com.google.android.material.floatingactionbutton.FloatingActionButton at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3037) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3172) at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:78) at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:108) at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:68) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1906) at android.os.Handler.dispatchMessage(Handler.java:106) at android.os.Looper.loop(Looper.java:193) at android.app.ActivityThread.main(ActivityThread.java:6863) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:537) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858) Caused by: android.view.InflateException: Binary XML file line #24: Binary XML file line #24: Error inflating class com.google.android.material.floatingactionbutton.FloatingActionButton Caused by: android.view.InflateException: Binary XML file line #24: Error inflating class com.google.android.material.floatingactionbutton.FloatingActionButton Caused by: java.lang.reflect.InvocationTargetException at java.lang.reflect.Constructor.newInstance0(Native Method) at java.lang.reflect.Constructor.newInstance(Constructor.java:343) at android.view.LayoutInflater.createView(LayoutInflater.java:647) at android.view.LayoutInflater.createViewFromTag(LayoutInflater.java:790) at android.view.LayoutInflater.createViewFromTag(LayoutInflater.java:730) at android.view.LayoutInflater.rInflate(LayoutInflater.java:863) at android.view.LayoutInflater.rInflateChildren(LayoutInflater.java:824) at android.view.LayoutInflater.inflate(LayoutInflater.java:515) at android.view.LayoutInflater.inflate(LayoutInflater.java:423) at androidx.databinding.DataBindingUtil.inflate(DataBindingUtil.java:126) at androidx.databinding.DataBindingUtil.inflate(DataBindingUtil.java:95) at me.shouheng.commons.view.activity.CommonActivity.onCreate(CommonActivity.java:41) at android.app.Activity.performCreate(Activity.java:7149) at android.app.Activity.performCreate(Activity.java:7140) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1288) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3017) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3172) at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:78) at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:108) at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:68) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1906) at android.os.Handler.dispatchMessage(Handler.java:106) at android.os.Looper.loop(Looper.java:193) at android.app.ActivityThread.main(ActivityThread.java:6863) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:537) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858) Caused by: java.lang.UnsupportedOperationException: Failed to resolve attribute at index 0: TypedValue&#123;t=0x2/d=0x7f0300b3 a=3&#125; at android.content.res.TypedArray.getColorStateList(TypedArray.java:565) at com.google.android.material.resources.MaterialResources.getColorStateList(MaterialResources.java:65) at com.google.android.material.floatingactionbutton.FloatingActionButton.&lt;init&gt;(FloatingActionButton.java:204)2018-11-10 16:56:48.408 27581-27581/me.shouheng.references E/AndroidRuntime: at com.google.android.material.floatingactionbutton.FloatingActionButton.&lt;init&gt;(FloatingActionButton.java:190) ... 27 more 根据错误的栈信息，我们到指定的方法下面去查看问题的原因，发现是设置背景着色的时候出现的问题： 123backgroundTint = MaterialResources.getColorStateList( context, a, R.styleable.FloatingActionButton_backgroundTint); 但我们并没有为 FAB 添加该属性，那么又是哪里出现的问题呢？原来是因为我们为 FAB 添加了一个 style： 1style=&quot;@style/Widget.MaterialComponents.FloatingActionButton&quot; 而该 style 的定义是： 123456789101112&lt;/style&gt; &lt;style name=&quot;Widget.MaterialComponents.FloatingActionButton&quot; parent=&quot;Widget.Design.FloatingActionButton&quot;&gt; &lt;item name=&quot;enforceMaterialTheme&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;elevation&quot;&gt;@dimen/mtrl_fab_elevation&lt;/item&gt; &lt;item name=&quot;backgroundTint&quot;&gt;?attr/colorSecondary&lt;/item&gt; &lt;item name=&quot;tint&quot;&gt;?attr/colorOnSecondary&lt;/item&gt; &lt;item name=&quot;hoveredFocusedTranslationZ&quot;&gt;@dimen/mtrl_fab_translation_z_hovered_focused&lt;/item&gt; &lt;item name=&quot;pressedTranslationZ&quot;&gt;@dimen/mtrl_fab_translation_z_pressed&lt;/item&gt; &lt;item name=&quot;rippleColor&quot;&gt;@color/mtrl_fab_ripple_color&lt;/item&gt; &lt;item name=&quot;showMotionSpec&quot;&gt;@animator/mtrl_fab_show_motion_spec&lt;/item&gt; &lt;item name=&quot;hideMotionSpec&quot;&gt;@animator/mtrl_fab_hide_motion_spec&lt;/item&gt;&lt;/style&gt; 这样刚好与我们的问题吻合，所以解决的方案就是移除这个属性。 2.6 java.net.UnknownServiceException: CLEARTEXT communication to baobab.kaiyanapp.com not permitted by network security policy按照上面的方式对我们的项目做了调整之后，我们发现项目已经可以运行了。接下来出现的问题是网络访问过程中出现的。当我们访问网络的时候会遇到下面的这个异常： 1java.net.UnknownServiceException: CLEARTEXT communication to baobab.kaiyanapp.com not permitted by network security policy 这个是因为 Android P 中新引入了网络安全规则，以上内容会对使用 http 的 URL 出现，默认会禁止访问 http 类型的地址。 当然，通常我们发布的时候会使用 Https 类型的网络协议，而当开发和调试的时候可能就没有那么严格了。所以，为了解决这个问题， Android 新引入了下面的解决方案： 首先，创建配置文件 res/xml/network_security_config.xml，内容如下： 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;network-security-config&gt; &lt;domain-config cleartextTrafficPermitted=&quot;true&quot;&gt; &lt;domain includeSubdomains=&quot;true&quot;&gt;localhost&lt;/domain&gt; &lt;/domain-config&gt;&lt;/network-security-config&gt; 这里的 localhost是 host 的地址，比如我上面的出错的地址应该是kaiyanapp.com`。 然后，我们将其配置到 manifest.xml 中： 123456&lt;application android:networkSecurityConfig=&quot;@xml/network_security_config&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot; (...) &lt;/application&gt; 在我们的项目中使用了三个不同的地址，并且都是 http 的，所以就需要在该地址下面配置三个域名，然后再次访问网络，问题就解决了。 关于 Android 网络和安全的内容，建议参考官方文档：网络安全性配置 | Android Developers。 总结显然迁移到 AndroidX 的过程中还是会出现许多问题的，大多数是与 Android 的支持包有关的。按照我们上面遇到的问题，主要包括以下几点内容： 主题 支持库的控件（控件属性，实现方式好像变了一些） 三方库，许多库并没有迁移，所以会导致程序内标红，但是编译和运行没有问题 网络安全，网络安全部分做了一些调整 好了，这篇文章大致到这里。也希望通过这篇文章来让你了解下迁移到 AndroidX 过程中可能会出现什么问题，并以此来考虑迁移的成本。 1.Getting started with Material Components for Android2.网络安全性配置 | Android Developers 如果您喜欢我的文章，可以在以下平台关注我： 个人主页：https://shouheng88.github.io/ 掘金：https://juejin.im/user/585555e11b69e6006c907a2a Github：https://github.com/Shouheng88 CSDN：https://blog.csdn.net/github_35186068 微博：https://weibo.com/u/5401152113]]></content>
      <categories>
        <category>Android高阶编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>AndroidX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 消息机制：Handler、MessageQueue 和 Looper]]></title>
    <url>%2F2018%2F11%2F04%2FAndroid-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%EF%BC%9AHandler%E3%80%81MessageQueue-%E5%92%8C-Looper%2F</url>
    <content type="text"><![CDATA[在这篇文章中，我们将会讨论 Android 的消息机制。提到 Handler，有过一些 Android 开发经验的都应该很清楚它的作用，通常我们使用它来通知主线程更新 UI。但是 Handler 需要底层的 MessageQueue 和 Looper 来支持才能运作。这篇文章中，我们将会讨论它们三个之间的关系以及实现原理。 在这篇文章中，因为涉及线程方面的东西，所以就避不开 ThreadLocal。笔者在之前的文章中有分析过该 API 的作用，你可以参考笔者的这篇文章来学习下它的作用和原理，本文中我们就不再专门讲解：《Java 并发编程：ThreadLocal 的使用及其源码实现》。 1、Handler 的作用通常，当我们在非主线程当中做了异步的操作之后使用 Handler 来在主线程当中更新 UI。之所以这么设计无非就是因为 Android 中的 View 不是线程安全的。之所以将 View 设计成非线程安全的，是因为：1).对 View 进行加锁之后会增加控件使用的复杂度；2).加锁之后会降低控件执行的效率。但 Handler 并非只能用来在主线程当中更新 UI，确切来说它有两个作用： 任务调度：即通过 post() 和 send() 等方法来指定某个任务在某个时间执行； 线程切换：你也许用过 RxJava，但如果在 Android 中使用的话还要配合 RxAndroid，而这里的 RxAndroid 内部就使用 Handler 来实现线程切换。 下文中，我们就来分别看一下它的这两个功能的作用和原理。 1.1 任务调度使用 Hanlder 可以让一个任务在某个时间点执行或者等待某段时间之后执行。Handler 为此提供了许多方法，从方法的命名上，我们可以将其分成 post() 和 sned() 两类方法。post() 类的用来指定某个 Runnable 在某个时间点执行，send() 类的用来指定某个 Message 在某个时间点执行。 这里的 Message 是 Android 中定义的一个类。它内部有多个字段，比如 what、arg1、arg2、replyTo 和 sendingUid 来帮助我们指定该消息的内容和对象。同时， Message 还实现了 Parcelable 接口，这表明它可以被用来跨进程传输。此外，它内部还定义了一个 Message 类型的 next 字段，这表明 Message 可以被用作链表的结点。实际上 MessageQueue 里面只存放了一个 mMessage，即链表的头结点。所以，MessageQueue 内部的消息队列，本质上是一个单链表，每个链表的结点就是 Message。 当调用 post() 类型的方法来调度某个 Runnable 的时候，首先会将其包装成一个 Message，然后再使用 send() 类的方法进行任务分发。所以，不论是 post() 类的方法还是 send() 类的方法，最终都会使用 Handler 的 sendMessageAtTime() 方法来将其加入到队列中： public boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { // ... 无关代码 return false; } return enqueueMessage(queue, msg, uptimeMillis); } 使用 Handler 进行任务调度是非常简单的。下面的代码就实现了让一个 Runnable 在 500ms 之后执行的逻辑： new Handler().postDelayed(new Runnable() { @Override public void run() { // do something } }, 500); 上面的任务执行方式在主线程中执行不会出现任何问题，如果你在非主线程中执行的话就可能会出现异常。原因我们后面会讲解。 既然每个 Runnable 被 post() 发送之后还要被包装成 Message，那么 Message 的意义何在呢？ Runnable 被包装的过程依赖于 Handler 内部的 getPostMessage() 方法。下面是该方法的定义： private static Message getPostMessage(Runnable r) { Message m = Message.obtain(); m.callback = r; return m; } 可见，我们的 Runnable 会被赋值给 Message 的 callback。这种类型的消息无法做更详细的处理。就是说，我们无法利用消息的 what、arg1 等字段（本身我们也没有设置这些字段）。如果我们希望使用 Message 的这些字段信息，就需要： 首先，要使用 send() 类型的方法来传递我们的 Message 给 Handler； 然后，我们的 Handler 要覆写 handleMessage() 方法，并在该方法中获取每个 Message 并根据其内部的信息依次处理。 下面的一个例子用来演示 send() 类型的方法。首先，我们要定义 Handler 并覆写其 handleMessage() 方法来处理消息： private final static int SAY_HELLO = 1; private static Handler handler = new Handler() { @Override public void handleMessage(Message msg) { switch (msg.what) { case SAY_HELLO: LogUtils.d(&quot;Hello!&quot;); break; } } }; 然后，我们向该 Handler 发送消息： Message message = Message.obtain(handler); message.what = SAY_HELLO; message.sendToTarget(); 这样，我们的 Handler 接收到了消息并根据其 what 得知要 SAY_HELLO，于是就打印出了日志信息。除了调用 Message 的 sendToTarget() 方法，我们还可以直接调用 handler 的 sendMessage() 方法（sendToTarget() 内部调用了 handler 的 sendMessage()）。 1.2 线程切换下面我们用了一份示例代码，它会先在主线程当中实例化一个 Handler，然后在某个方法中，我们开启了一个线程，并执行了某个任务。2 秒之后任务结束，我们来更新 UI。 // 在主线程中获取 Handler private static Handler handler = new Handler(); // 更新UI，会将消息发送到主线程当中 new Thread(() -&gt; { try { Thread.sleep(2000); handler.post(() -&gt; getBinding().tv.setText(&quot;主线程更新UI&quot;)); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); 上面之所以能够在主线程当中更新 UI，主要是因为我们的 Handler 是在主线程当中进行获取的。随后，我们调用 handler 的 post() 方法之后，传入的 Runnable 会被包装成 Message，然后加入到主线程对应的消息队列中去，并由主线程对应的 Looper 获取到并执行。所以，就使得该 Runnable 的操作最终在主线程中完成。 也许你会觉得先在主线程当中获取到 Handler 然后再使用比较麻烦。别担心，我们还有另一种方式来解决这个问题。我们可以直接使用 Looper 的 getMainLooper() 方法来获取主线程对应的 Looper，然后使用它来实例化一个 Handler 并使用该 Handler 来处理消息： new Handler(Looper.getMainLooper()) .post(() -&gt; getBinding().tv.setText(&quot;主线程更新UI&quot;)); 本质上，当我们调用 Handler 的无参构造方法，或者说不指定 Looper 的构造方法的时候，会直接使用当前线程对应的 Looper 来实例化 Handler。每个线程对应的 Looper 存储在该线程的局部变量 ThreadLocal 里。当某个线程的局部变量里面没有 Looper 的时候就会抛出一个异常。所以，我们之前说直接使用 new 来实例化一个 Handler 的时候可能出错就是这个原因。 主线程对应的 Looper 会在 ActivityThread 的静态方法 main() 中被创建，它会调用 Looper 的 prepareMainLooper() 静态方法来创建主线程对应的 Looper。然后会调用 Looper 的 loop() 静态方法来开启 Looper 循环以不断处理消息。这里的 ActivityThread 用来处理应用进程中的活动和广播的请求，会在应用启动的时候调用。ActivityThread 内部定义了一个内部类 H，它继承自 Handler，同样运行在主线程中，用来处理接收到的来自各个活动、广播和服务的请求。 除了使用主线程对应的 Looper，我们也可以开启我们自定义线程的 Looper。下面的代码中，我们开启了一个线程，并在线程中先调用 Looper 的 prepare() 静态方法，此时 Looper 会为我们当前的线程创建 Looper，然后将其加入到当前线程的局部变量里面。随后，当我们调用 Looper 的 loop() 方法的时候就开启了 Looper 循环来不断处理消息： new Thread(() -&gt; { LogUtils.d(&quot;+++++++++&quot; + Thread.currentThread()); Looper.prepare(); new Handler().post(() -&gt; LogUtils.d(&quot;+++++++++&quot; + Thread.currentThread())); Looper.loop(); }).start(); 从以上的内容我们可以看出，Handler 之所以能够实现线程切换，主要的原因是其内部的消息队列是对应于每一个线程的。发送的任务会在该线程对应的消息队列中被执行。而成功获取到该线程对应的消息队列就依靠 ThreadLocal 来对每个线程对应的消息队列进行存储。 2、源码解析以上，我们分析了 Handler 的主要的两种主要用途，并且在这个过程中，我们提及了许多 Handler、MessageQueue 和 Looper 的底层设计。在上面的文章中，我们只是使用了文字来进行描述。在下文中，我们来通过源码来验证我们上面提到的一些内容。 2.1 实例化 HandlerHandler 了提供了多个重载的构造方法，我们可以将其分成两种主要的类型。一种在构造方法中需要明确指定一个 Looper，另一种在构造方法中不需要指定任何 Looper，在构造方法内部会获取当前线程对应的 Looper 来初始化 Handler。 第一种初始化的方式最终都会调用下面的方法来完成初始化。这个方法比较简单，是基本的赋值操作： public Handler(Looper looper, Callback callback, boolean async) { mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; } 第二种初始化的方式最终会调用下面的方法。这里使用 Looper 的静态方法 myLooper() 来获取当前线程对应的 Looper。如果当前线程不存在任何 Looper 就会抛出一个异常。 public Handler(Callback callback, boolean async) { // 潜在内存泄漏的检查 if (FIND_POTENTIAL_LEAKS) { final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) { Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); } } // 使用 Looper 的静态方法 myLooper() 来获取当前线程的 Looper mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException(); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; } 而 Looper 的静态方法 myLooper() 会使用线程局部变量 sThreadLocal 来获取之前存储到该线程内部的 Looper： public static @Nullable Looper myLooper() { return sThreadLocal.get(); } 2.2 Looper 的初始化前面我们也说过 Looper 的创建过程。对于主线程的 Looper 会在 ActivityThread 的 main() 方法中被调用： public static void main(String[] args) { // ... 无关代码 Looper.prepareMainLooper(); // ... 无关代码 // 开启 Looper 循环 Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); } 这里调用了 Looper 的静态方法 prepareMainLooper() 来初始化主线程的 Looper： public static void prepareMainLooper() { prepare(false); synchronized (Looper.class) { if (sMainLooper != null) { throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); } sMainLooper = myLooper(); } } 其内部先调用了 prepare(boolean) 方法来初始化一个 Looper 并将其放在线程局部变量 sThreadLocal 中，然后判断 sMainLooper 是否之前存在过。这是一种基本的单例校验，显然，我们只允许主线程的 Looper 被实例化一次。 同样，非主线程的 Looper 也只允许被实例化一次。当我们在非主线程实例化一个 Looper 的时候会调用它的 prepare() 静态方法。它同样调用了 prepare(boolean) 方法来初始化一个 Looper 并将其放在线程局部变量 sThreadLocal 中。所以，主线程和非主线程的 Looper 实例化的时候本质上是调用同样的方法，只是它们实现的时机不同，并且，都只能被实例化一次。 public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); } sThreadLocal.set(new Looper(quitAllowed)); } 经过上述分析，我们可以得知，对于一个线程只能实例化一个 Looper，所以当我们在同一个线程中多次创建 Handler 实例，它们是共享一个 Looper 的。或者说是一个 Looper 对应多个 Handler 也是可以的。 2.3 MessageQueue 的实例化相比于 Looper 和 Handler，MessageQueue 就显得相对复杂一些。因为内部用到了 JNI 编程。初始化、销毁和入队等事件都用到了 native 的方法。你可以在 android_os_MessageQueue 查看其源码的定义。 每当我们实例化一个 Looper 的时候会调用它的构造方法，并在其中实例化一个 MessageQueue： private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } 在实例化 Handler 的小节中可以看出，每次实例化一个 Handler 的时候，会从当前线程对应的 Looper 中取出 MessageQueue。所以，这里我们又可以得出结论一个 Handler 对应一个 MessageQueue。 当我们实例化一个 MessageQueue 的时候会使用它的构造方法。这里会调用 native 层的 nativeInit() 方法来完成 MessageQueue 的初始化： MessageQueue(boolean quitAllowed) { mQuitAllowed = quitAllowed; mPtr = nativeInit(); } 在 native 层，nativeInit() 方法的定义如下： static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) { NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); if (!nativeMessageQueue) { jniThrowRuntimeException(env, &quot;Unable to allocate native queue&quot;); return 0; } nativeMessageQueue-&gt;incStrong(env); return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue); } 从上面我们可以看出，在该方法中实例化了一个 NativeMessageQueue 之后返回了 mPtr 作为是 Java 层 MessageQueue 与NativeMessesageQueue 的桥梁。这个 long 类型的成员保存了 native 实例，这是 jni 开发中常用到的方式。因此 MessageQueue 同样使用 mPtr 来表示 native 层的消息队列。NativeMessageQueue 在 native 层的部分定义和其构造方法的定义如下。 class NativeMessageQueue : public MessageQueue, public LooperCallback { // ... 无关代码 NativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) { mLooper = Looper::getForThread(); if (mLooper == NULL) { mLooper = new Looper(false); Looper::setForThread(mLooper); } } 从上面我们可以看出，NativeMessageQueue 继承自 MessageQueue。并且在其内部实例化了一个 native 层的 Looper（其源码在 Looper）。 在 Android 的 native 层存在着一个于 Java 层类似的 Looper，它的主要作用是用来与 Java 层的 Looper 相互配合完成 Android 中最主要的线程通信。当消息队列中有消息存入时，会唤醒 Natvice 层的 Looper。当消息队列中没有消息时或者消息尚未到处理时间时， Natvice 层的 Looper 会 block 住整个线程。所以，创建了 Java Looper 的线程只有在有消息待处理时才处于活跃状态，无消息时 block 在等待消息写入的状态。既然如此，当我们在主线程中开启了 Looper 循环的话，为什么不会 block 住整个线程而导致 ANR 呢？这是因为，我们的主线程的消息都会发送给主线程对应的 Looper 来处理，所以，本质上，我们主线程中的许多事件也都是以消息的形式发送给主线程的 Handler 来进行处理的。只有当某个消息被执行的时间过长的时候才会出现 ANR。 上面我们实例化了一个 Native 层的 Looper。在其中主要做到的逻辑如下： void Looper::rebuildEpollLocked() { // 如果之前存在的话就关闭之前的 epoll 实例 if (mEpollFd &gt;= 0) { mEpollFd.reset(); // 关闭旧的epoll实例 } // 申请新的 epoll 实例，并且注册 “Wake管道” mEpollFd.reset(epoll_create(EPOLL_SIZE_HINT)); LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance: %s&quot;, strerror(errno)); struct epoll_event eventItem; // 把未使用的数据区域进行置0操作 memset(&amp; eventItem, 0, sizeof(epoll_event)); eventItem.events = EPOLLIN; eventItem.data.fd = mWakeEventFd.get(); // 将唤醒事件 (mWakeEventFd) 添加到 epoll 实例 (mEpollFd) int result = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, mWakeEventFd.get(), &amp;eventItem); LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not add wake event fd to epoll instance: %s&quot;, strerror(errno)); // 这里主要添加的是Input事件如键盘，传感器输入，这里基本上由系统负责，很少主动去添加 for (size_t i = 0; i &lt; mRequests.size(); i++) { const Request&amp; request = mRequests.valueAt(i); struct epoll_event eventItem; request.initEventItem(&amp;eventItem); // 将 request 队列的事件，分别添加到 epoll 实例 int epollResult = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, request.fd, &amp;eventItem); } } 这里涉及了 epoll 相关的知识。epoll 是一个可扩展的 Linux I/O 事件通知机制，用来实现多路复用 (Multiplexing)。它将唤醒事件按对应的 fd 注册进 epoll，然后 epoll 帮你监听哪些唤醒事件上有消息到达。此时的唤醒事件应该采用非阻塞模式。这样，整个过程只在调用 epoll 的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的响应模式。 上面的代码中使用了 epoll_ctl 方法来将被监听的描述符添加到 epoll 句柄。关于 epoll 的指令，可以参考这篇博文 《epoll机制:epoll_create、epoll_ctl、epoll_wait、close》。这部分代码的主要作用是创建一个 epoll 实例并用它来监听 event 触发。 2.4 消息的执行过程2.4.1 消息入队的过程在介绍 Handler 的使用的时候，我们也说过不论是 Runnable 还是 Message 最终都会被封装成 Meseage 并加入到队列中。那么，加入队列之后又是怎么被执行的呢？ 首先，我们先看下入队的过程。以下是 Handler 中定义的方法，每当我们将一个消息入队的时候，都会调用它来完成。 private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis); } 从上面可以看出，入队的时候实际上是使用了 MessageQueue 的 enqueueMessage() 方法。所以，我们再来看下该方法的定义： boolean enqueueMessage(Message msg, long when) { // ... 无关代码，校验 synchronized (this) { // ... 无关代码 Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { msg.next = p; mMessages = msg; needWake = mBlocked; } else { needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; prev.next = msg; } if (needWake) { nativeWake(mPtr); } } return true; } 从上面的方法可以看出，所谓的入队操作本质上就是一个将新的消息加入到队列中的逻辑。当然，这里加入的时候要根据消息的触发时间对消息进行排序。然后，会根据 needWake 来决定是否调用 native 层的方法进行唤醒。只有当当前的头结点消息之前存在栅栏 (barrier) 并且新插入的消息是最先要被触发的异步消息就进行唤醒。当一般情况下是无需进行唤醒的。 这里的 nativeWake() 方法会最终调用 native 层的 Looper 的 awake() 方法： void Looper::wake() { uint64_t inc = 1; ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd.get(), &amp;inc, sizeof(uint64_t))); if (nWrite != sizeof(uint64_t)) { if (errno != EAGAIN) { LOG_ALWAYS_FATAL(&quot;Could not write wake signal to fd %d: %s&quot;, mWakeEventFd.get(), strerror(errno)); } } } 此方法向 mWakeEventFd 写入了一个字节的内容。到底是什么内容并不重要，重要的是 fd 存在内容了，换句话说就是 mWakeEventFd 可读了，也就是 Native 层的 Looper 的线程从 block 状态中醒了过来。之所以需要进行唤醒，是因为，每次我们处理了消息之后会根据下个消息执行的时间进行唤醒。如果新插入的消息是最新的消息，那么显然，我们需要把唤醒的时间重置。（Native 层的 Looper 会在我们调用 Java 层的 MessageQueue 的时候执行 epoll_wait 时进入 block 状态。） 2.4.2 消息执行的过程在上文中，我们分析了 MessageQueue 将消息入队的过程。那么这些消息要在什么时候被执行呢？在介绍 Handler 的使用的时候，我们也提到过当我们实例化了 Looper 之后都应该调用它的 loop() 静态方法来处理消息。下面我们来看下这个方法的定义。 public static void loop() { final Looper me = myLooper(); // .. 无关代码 final MessageQueue queue = me.mQueue; // .. 无关代码 for (;;) { Message msg = queue.next(); // 可能会 bolck if (msg == null) { return; } // ... 无关代码 final long dispatchEnd; try { msg.target.dispatchMessage(msg); dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; } finally { if (traceTag != 0) { Trace.traceEnd(traceTag); } } // ... 无关代码 msg.recycleUnchecked(); } } 从上面我们可以看出，当该方法被调用的时候，它会先开启一个无限循环，并在该循环中使用 MessageQueue 的 next() 方法来取出下一个消息并进行分发。这里我们先不看 next() 方法的定义。我们先把这个方法中涉及的部分分析一下。 当获取到了下一个消息之后，会调用它的target 也就是发送该消息的 Handler 的 dispatchMessage() 方法来进行处理。该方法的定义如下： public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } 从上面可以看出，如果该消息是通过包装 Runnable 得到的话，会直接调用它的 handleCallback() 方法进行处理。在该方法内部会直接调用 Runnable 的 run() 方法。因为比较见到那，我们就补贴出代码了。 然后，会根据 mCallback 是否为空来决定是交给 mCallback 进行处理还是内部的 handleMessage() 方法。这里的 mCallback 是一个接口，可以在创建 Handler 的时候通过构造方法指定，也比较简单。而这里的 handleMessage() 方法，我们就再熟悉不过了，它就是我们创建 Handler 的时候重写的、用来处理消息的方法。这样，消息就被发送到了我们的 Handler 中进行处理了。 以上就是消息被处理的过程，代码的逻辑还是比较清晰的。下面我们就来看下 MessageQueue 是如何获取 “下一个” 消息的。 2.4.3 MessageQueue 的消息管理上面我们已经分析完了 Handler 发送的消息执行的过程。这里我们在来分析一下其中的获取 “下一个” 消息的逻辑： Message next() { // 如果消息循环已经停止就直接返回。如果应用尝试重启已经停止的Looper就会可能发生这种情况。 final long ptr = mPtr; if (ptr == 0) { return null; } int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } // 调用 native 的方法，可能会这个函数发生 block nativePollOnce(ptr, nextPollTimeoutMillis); // ... 无关代码 } } 从上面可以看出 Java 层的 MessageQueue 的 next() 方法是一个循环。除了获取消息队列之外，还要监听 Natvie 层 Looper 的事件触发。通过调用 native 层的 nativePollOnce() 方法来实现。该方法内部又会调用 NativeMessageQueue 的 pollOnce() 方法。而且注意下，在下面的方法中，nativeMessageQueue 是从 Java 层的 mPtr 中获取到的。所以我们说，在初始化 MessageQueue 的时候得到的 mPtr 起到了桥梁的作用： static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) { NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis); } 在 NativeMessageQueue 的 pollOnce() 方法中会调用 native 层的 Looper 的 pollOnce()，并最终调用 native 层 Looper 的 pollInner() 方法： int Looper::pollInner(int timeoutMillis) { // ... 根据下一个消息的事件调整超时时间 int result = POLL_WAKE; mResponses.clear(); mResponseIndex = 0; mPolling = true; // 将要空闲 struct epoll_event eventItems[EPOLL_MAX_EVENTS]; // 待已注册之事件被触发或计时终了 int eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis); mPolling = false; // 不再空闲 mLock.lock(); // 请求锁 if (mEpollRebuildRequired) { mEpollRebuildRequired = false; rebuildEpollLocked(); // 根据需要重建 epoll goto Done; } // 进行检查 if (eventCount &lt; 0) { if (errno == EINTR) { goto Done; } result = POLL_ERROR; // 错误 goto Done; } if (eventCount == 0) { result = POLL_TIMEOUT; // 超时 goto Done; } // 处理所有消息 for (int i = 0; i &lt; eventCount; i++) { int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeEventFd.get()) { // 唤醒 fd 有反应 if (epollEvents &amp; EPOLLIN) { awoken(); // 已经唤醒了，则读取并清空管道数据 } } else { // 其他 input fd 处理，其实就是将活动 fd 放入到 responses 队列中，等待处理 ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &gt;= 0) { int events = 0; if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT; if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT; if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR; if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP; // 将消息放进 mResponses 中 pushResponse(events, mRequests.valueAt(requestIndex)); } } } Done: ; // 触发所有的消息回调，处理 Native 层的Message mNextMessageUptime = LLONG_MAX; while (mMessageEnvelopes.size() != 0) { nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0); if (messageEnvelope.uptime &lt;= now) { { // 获取 handler sp&lt;MessageHandler&gt; handler = messageEnvelope.handler; Message message = messageEnvelope.message; mMessageEnvelopes.removeAt(0); mSendingMessage = true; mLock.unlock(); handler-&gt;handleMessage(message); } // 释放 handler mLock.lock(); mSendingMessage = false; result = POLL_CALLBACK; } else { // 队列头部的消息决定了下个唤醒的时间 mNextMessageUptime = messageEnvelope.uptime; break; } } mLock.unlock(); // 释放锁 // 触发所有的响应回调 for (size_t i = 0; i &lt; mResponses.size(); i++) { Response&amp; response = mResponses.editItemAt(i); if (response.request.ident == POLL_CALLBACK) { int fd = response.request.fd; int events = response.events; void* data = response.request.data; int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data); if (callbackResult == 0) { removeFd(fd, response.request.seq); // 移除文件描述符 } response.request.callback.clear(); result = POLL_CALLBACK; } } return result; } 从上面我们可以看出 Native 层的 pollInner() 方法首先会根据 Java 层传入的 timeoutMillis 调用 epoll_wait 方法来让线程进入等待状态。如果 timeoutMillis 不为 0，那么线程将进入等待状态。如果有事件触发发生，wake 或者其他复用 Looper 的 event，处理event，这样整个 Native 层的 Looper 将从 block 状态中解脱出来了。这样回到 Java 层就将继续执行 MessageQueue 中下一条语句。至于 Native 层的 Looper 何时从 block 状态中醒过来，就需要根据我们入队的消息来定。也就用到了 MessageQueue 的 enqueueMessage() 方法的最后几行代码： if (needWake) { nativeWake(mPtr); } 即：只有当当前的头结点消息之前存在栅栏 (barrier) 并且新插入的消息是最先要被触发的异步消息就进行唤醒。 上面主要是 Native 层的 Looper 线程 block 的相关的逻辑。即当我们获取消息队列的下一条消息的时候会根据下一个消息的时间来决定线程 block 的时长。当我们将一个消息加入到队列的时候会根据新的消息的时间重新调整线程 block 的时长，如果需要的话还需要唤起 block 的线程。当线程从 block 状态恢复出来的时候，Java 层的 Looper 就拿到了一个消息，对该消息进行处理即可。 3、总结在上文中，我们从 Java 层到 Native 层分析了 Handler 的作用的原理。这里我们对这部分内容做一个总结。 3.1 Handler、MessageQueue 和 Looper 之间的关系首先是 Handler、MessageQueue 和 Looper 之间的关系。我们用下面的这个图来表示： 也就是说，一个线程中可以定义多个 Handler 实例，但是每个 Handler 实际上引用的是同一个 Looper。当然，我们要在创建 Handler 之前先创建 Looper。而每个 Looper 又只对应一个 MessageQueue。该 MessageQueue 会在创建 Looper 的时候被创建。在 MessageQueue 中使用 Message 对象来拼接一个单向的链表结构，依次来构成一个消息队列。每个 Message 是链表的一个结点，封装了我们发送的信息。 3.2 Handler 的消息发送过程然后，我们再来分析下 Handler 中的消息是如何被发送的。同样，我们使用一个图来进行分析： 根据上文的内容我们将 Handler 发送消息的方法分成 post 和 send 两种类型。post 的用来发送 Runnable 类型的数据，send 类型的用来发送 Message 类型的数据。但不论哪种类型最终都会调用 Handler 的 sendMessageAtTime() 方法来加入到 MessageQueue 的队列中。区别在于，post 类型的方法需要经过 Handler 的 getPostMessage() 包装成 Message 之后再发送。 3.3 Looper 的执行过程当消息被添加到队列之后需要执行消息，这部分内容在 Looper 的 loop() 方法中。但是这部分内容稍显复杂，因为涉及 Native 层的一些东西。我们这里仍然使用图来进行描述： 当我们调用 Looper 的 loop() 方法之后整个 Looper 循环就开始不断地处理消息了。在上图中就是我们用绿色标记的一个循环。当我们在循环中调用 MessageQueue 的 next() 方法来获取下一个消息的时候，会调用 nativePollOnce() 方法，该方法可能会造成线程阻塞和非阻塞，当线程为非阻塞的时候就会从 Native 层回到 Java 层，从 MessageQueuue 中取得一个消息之后给 Looper 进行处理。如果获取的时候造成线程阻塞，那么有两种情况会唤醒阻塞的线程，一个是当一个新的消息被加入到队列中，并且将会早于之前队列的所有消息被触发，那么此时将会重新设置超时时间。如果达到了超时时间同样可以从睡眠状态中返回，也就回到了 Java 层继续处理。所以，Native 层的 Looper 的作用就是通过阻塞消息队列获取消息的过程阻塞 Looper。 3.4 最后因为本文中不仅分析了 Java 层的代码，同时分析了 framework 层的代码，所以最好能够结合两边的源码一起看，这样更有助于自己的理解。在上面的文章中，我们给出了一些类的在线的代码链接，在 Google Source 上面，需要 VPN 才能浏览。另外，因为笔者水平有限，难免存在有误和不足的地方，欢迎批评指正。 我是 WngShhng. 如果您喜欢我的文章，可以在以下平台关注我： 个人主页：https://shouheng88.github.io/ 掘金：https://juejin.im/user/585555e11b69e6006c907a2a Github：https://github.com/Shouheng88 CSDN：https://blog.csdn.net/github_35186068 微博：https://weibo.com/u/5401152113]]></content>
      <categories>
        <category>Android消息机制</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码阅读</tag>
        <tag>Framework</tag>
        <tag>Handler</tag>
        <tag>Looper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理在 Android 中的应用：Retrofit 源码解析]]></title>
    <url>%2F2018%2F10%2F20%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%9C%A8%20Android%20%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9ARetrofit%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在之前的文章 《Andriod 网络框架 OkHttp 源码解析》 中我们分析了 OkHttp 的源代码。现在我们就来分析一下 OkHttp 的兄弟框架 Retrofit。关于 Retrofit 的注解的使用，可以参考其官方文档：https://square.github.io/retrofit/。 Retrofit 也是 Square 发布的一个开源的库，它是一个类型安全的 Http 客户端，适用于 Android 和 Java。本质上，Retrofit 使用了 Java 的动态代理，内部使用 OkHttp 来进行网络访问，并且可以通过指定 “请求适配器” 和 “类型转换器” 来完成方法参数到 OkHttp 的请求的转换，以及 OkHttp 响应到用户指定的实体类型的转换。 1、基本使用Retrofit 设计的一个好的地方就是它把我们上面提到的 “请求适配器” 和 “类型转换器” 使用策略模式解耦出来。用户可以根据自己的需求通过实现指定的接口来自定义自己的类型转换器。所以，当我们使用 Gson 和 RxJava2 转换器的时候，就需要指定下面三个依赖： api &apos;com.squareup.retrofit2:retrofit:2.4.0&apos; api &apos;com.squareup.retrofit2:converter-gson:2.4.0&apos; api &apos;com.squareup.retrofit2:adapter-rxjava2:2.4.0&apos; 然后，我们需要根据自己的 API 接口的信息，在代码里用一个接口来对该 API 接口进行声明： public interface WXInfoService { @GET(&quot;/sns/userinfo&quot;) Observable&lt;WXUserInfo&gt; getWXUserInfo( @Query(&quot;access_token&quot;) String accessToken, @Query(&quot;openid&quot;) String openId); } 这里的 WXUserInfo 是由该 API 接口返回的 Json 生成的 Java 对象。然后，我们可以像下面这样获取一个该接口的代理对象： WXInfoService wXInfoService = new Retrofit.Builder() .baseUrl(&quot;https://api.weixin.qq.com/&quot;) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .client(okHttpClient) .build().create(WXInfoService.class); 然后，我们就可以使用该对象并调用其方法来获取接口返回的信息了： Disposable disposable = wxInfoService.getWXUserInfo(accessToken, openId) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(wxUserInfo -&gt; { /*...拿到结果之后进行处理...*/ }); 上面我们只是使用了 Retrofit 的最基础的 GET 接口。当然，Retrofit 本身的功能远比这要丰富得多，关于其更多的使用，可以参考其官方的文档。 2、动态代理：魔力发生的地方上面我们使用 Retrofit 进行网络请求，实际其内部使用 OkHttp 来完成网络请求的，然后，使用我们传入的 “类型转换器” 把响应转换成我们指定的类型。定义了一个接口并调用了该接口的方法，然后就拿到了请求的结果，这看上去非常简洁，而这其中的最功不可没的就是动态代理。 当我们使用 Retrofit.Builder 的 create() 方法获取一个 WXInfoService 实例的时候，实际返回的是经过代理之后的对象。该方法内部会调用 Proxy 的静态方法 newProxyInstance() 来得到一个代理之后的实例。为了说明这个方法的作用，我们写了一个例子： public static void main(String...args) { Service service = getProxy(Service.class); String aJson = service.getAInfo(); System.out.println(aJson); String bJson = service.getBInfo(); System.out.println(bJson); } private static &lt;T&gt; T getProxy(final Class&lt;T&gt; service) { InvocationHandler h = (proxy, method, args) -&gt; { String json = &quot;{}&quot;; if (method.getName().equals(&quot;getAInfo&quot;)) { json = &quot;{A请求的结果}&quot;; } else if (method.getName().equals(&quot;getBInfo&quot;)) { json = &quot;{B请求的结果}&quot;; } return json; }; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[]{service}, h); } 该程序的输出结果是： {A请求的结果} {B请求的结果} 在上面的这个例子中，我们先使用 getProxy() 获取一个代理之后的实例，然后依次调用它的 getAInfo() 和 getBInfo() 方法，来模拟调用 A 接口和 B 接口的情形，并依次得到了 A 请求的结果和 B 请求的结果。上面的效果近似于我们使用 Retrofit 访问接口的过程。为了说明这个过程中发生了什么，我们需要先了解一下这里的 newProxyInstance() 方法： public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) { // ... } 该方法接收三个参数：第一个是类加载器；第二个是接口的 Class 类型；第三个是一个处理器，你可以将其看作一个用于回调的接口。当我们的代理实例触发了某个方法的时候，会调用该回调接口的方法进行处理。InvocationHandler 是一个接口，它内部定义了一个方法如下： public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; 该方法也接收三个参数：第一个是触发该方法的代理实例；第二个是代理类触发的方法；第三个是触发的方法的参数。invoke() 方法的返回结果会作为代理类的方法执行的结果。 所以，当了解了 newProxyInstance() 方法的定义之后，我们可以做如下总结：当我们使用 newProxyInstance() 方法获取了一个代理实例 service 并调用其 getAInfo() 方法之后，该方法的信息和参数信息会分别通过 method 和 args 传入到 h 的 invoke() 中。所以，最终的效果就是，当我们调用 service 的 getAInfo() 时候会触发 h 的 invoke()。然后，在该方法中我们根据 method 得知触发的方法是 getAInfo。于是，我们把它对应的请求从 invoke() 方法中返回，并作为 service.getAInfo() 的返回结果。 所以，我们可以总结 Retrofit 的大致工作流程：当我们获取了接口的代理实例，并调用它的 getWXUserInfo() 方法之后，该 API 的请求参数会传递到代理类的 InvocationHandler.invoke() 方法中。然后在该方法中，我们将其转换成 OkHttp 的 Request，然后使用 OkHttp 进行访问。当拿到结果之后，我们使用传入的 “转换器” 将响应转换成接口指定的 Java 类型。 上面是 Retrofit 请求处理的基本流程，下面我们看一下 Retrofit 的代理方法内部究竟发生了什么。 3、Retrofit 的源码解析3.1 创建 Retrofit根据上面的例子，当使用 Retrofit 的时候，首先我们需要使用 Retrofit 的构建者来创建 Retrofit 的实例。这里有几个重要的方法需要提及一下： 3.1.1 addConverterFactory 方法该方法用来向 Retrofit 中添加一个 Converter.Factory。Converter.Factory，顾名思义是一种工厂模式，它是一个接口需要实现两个重要的方法。每个方法需要返回一个转换器：一个是某种数据类型到请求体的转换器，另一个是响应体到我们需要的数据类型的转换器。当我们使用 Gson 来完成这个转换，那么我们就需要使用 GsonConverterFactory.create() 来得到一个适用于 Gson 的 Converter.Factory。 public Builder addConverterFactory(Converter.Factory factory) { converterFactories.add(checkNotNull(factory, &quot;factory == null&quot;)); return this; } 3.1.2 addCallAdapterFactory 方法CallAdapter.Factory 用于获取 CallAdapter 对象， CallAdapter 对象用于把原生的 OkHttp 的 Call 转换成我们指定的请求类型。比如，转换成 RxJava2 的 Observable 类型。下面是该方法的定义： public Builder addCallAdapterFactory(CallAdapter.Factory factory) { callAdapterFactories.add(checkNotNull(factory, &quot;factory == null&quot;)); return this; } 3.1.3 build 方法当根据用户的自定义设置完了参数之后，就可以调用 build() 方法，来获取一个 Retrofit 的实例。在该方法中会将上述的工厂实例添加到一个列表中，然后根据请求、响应的类型来获取工厂实例，然后分别获取一个转换器或者适配器。 3.1.4 小结为了说明适配器 CallAdapter 和转换器 Converter 的作用，我们绘制了下图： 从上面我们看出，CallAdapter 主要用来将某个请求转换成我们指定的类型。比如，在我们最开始的例子中，要将请求转换成 Observable&lt;WXUserInfo&gt;。如果转换之后的请求是 Observable 类型的，那么当我们对转换后的请求进行订阅的时候，就启动了 OkHttp 的网络请求过程。 在进行网络请求之前会先使用 Converter 将请求的参数转换成一个 RequestBody。这里将其作为一个接口的好处是便于解耦。比如，上面我们用 Gson 来完成转换过程，你也可以通过自定义转换器来使用其他的框架，比如 Moshi 等。当拿到了响应之后，我们又会再次使用 Converter 来将响应体 ResponseBody 转换成我们要求的类型。比如，上面的例子中应该转换为 WXUserInfo。 最后，OkHttp 那里得到的响应会在 CallAdapter 方法内部被包装成 Observable&lt;WXUserInfo&gt; 并返回给观察者。这样，我们就拿到了这个请求的结果。 从上面我们看出，Retrofit 设计的非常妙的地方就在于上面的两个过程的解耦（策略模式+工厂模式）。一次是将请求转换成 Observable 的过程，一次是将请求体和响应体转换成 OkHttp 要求的 RequestBody 和 ResponseBody 的过程。对于前者，不论我们使用的是 RxJava 1 还是 RxJava 2，只要传入一个 CallAdapter 即可。对于后者，不论我们使用哪种 Json 转换框架，只要实现了 Converter 接口皆可。 3.2 获取代理实例3.2.1 划分平台：Platform创建了 Retrofit 的实例之后，我们就可以使用它的 create() 方法来获取代理之后的服务实例。下面是这个方法的定义。在这里，我们会先根据 validateEagerly 变量来判断是否立即对传入的服务接口的方法进行解析。然后，我们使用 Proxy 的静态方法获取一个代理实例。 public &lt;T&gt; T create(final Class&lt;T&gt; service) { Utils.validateServiceInterface(service); // 这里的 validateEagerly 在 Retrofit 构建的时候设置 if (validateEagerly) { // 是否立即对 Service 方法的内容进行解析 eagerlyValidateMethods(service); } // 获取代理实例 return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service }, new InvocationHandler() { private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable { // 该方法是 Object 的方法，直接触发该方法 if (method.getDeclaringClass() == Object.class) { return method.invoke(this, args); } // 如果是 default 方法，那么使用该 Java8 平台的方法执行 if (platform.isDefaultMethod(method)) { return platform.invokeDefaultMethod(method, service, proxy, args); } // 获取服务方法的信息，并将其包装成 ServiceMethod ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.adapt(okHttpCall); } }); } 这里的 eagerlyValidateMethods() 方法定义如下： private void eagerlyValidateMethods(Class&lt;?&gt; service) { // 获取程序当前运行的平台 Platform platform = Platform.get(); for (Method method : service.getDeclaredMethods()) { // 判断该方法是否是 default 方法 if (!platform.isDefaultMethod(method)) { loadServiceMethod(method); } } } 它的作用是立即对服务接口的方法进行解析，并将解析之后的结果放进一个缓存中。这样，当这个服务方法被触发的时候，直接从缓存当中获取解析之后的 ServiceMethod 来使用即可。该方法会先会根据当前程序运行的平台来决定是否应该加载服务的方法。因为，Java 8 之后，我们可以为接口增加 default 类型的方法，所以，如果是 default 类型的话，我们不会调用 loadServiceMethod() 进行解析，而是调用 Java8 平台的 invokeDefaultMethod() 来处理。在 invokeDefaultMethod() 中，会根据传入的信息创建一个实例并使用反射触发它的方法。此时，就间接地触发了该 default 方法。 判断平台的时候，使用了如下这段代码： platform.isDefaultMethod(Method) 这里的 platform 是调用 Platform.get() 的时候得到的。它会在 get() 方法中尝试使用反射去获取一个只有 Java8 平台才具有的类，以此来判断是否是 Java8 的环境。在 Retrofit 中，提供了 Java8 和 Android 两个类来区分所在的平台，并会根据运行环境来决定返回哪个实例。 从上面我们看出，Platform 算是一种策略的设计模式，以根据平台的不同做不同的处理。但在当前的版本中，它的主要作用是对 default 类型的方法进行处理。 3.2.2 解析服务方法：ServiceMethod上面我们提到过 loadServiceMethod() 方法，它的主要作用：首先会尝试从缓存当中获取该方法对应的 ServiceMethod 实例，如果取到的话，就将其返回；否则，就使用构建者模式创建一个并放进缓存中，然后将其返回。 ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) { // 从缓存中进行获取 ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method); if (result != null) return result; synchronized (serviceMethodCache) { result = serviceMethodCache.get(method); if (result == null) { // 创建ServiceMethod实例 result = new ServiceMethod.Builder&lt;&gt;(this, method).build(); serviceMethodCache.put(method, result); } } return result; } ServiceMethod 的构建过程比较简单，只需要把当前的 Retrofit 实例和服务方法 method 传入进去，然后调用它的 build() 方法就完成了整个创建过程。在 build() 方法中，会完成对 method 的解析，比如根据注解判断是什么类型的请求，根据方法的参数来解析请求的请求体等等。ServiceMethod 内部的变量主要是与请求的相关的信息，同时它也提供了一些方法，用于获取 OkHttp 的请求和响应。 所以，ServiceMethod 的作用是缓存服务方法对应的请求信息，这样下次我们就不需要再次解析了。同时，它提供了以下几个方法，它们的主要作用是用来从 ServiceMethod 中获取请求相关的信息。 toCall() 用来获取用于 OkHttp 请求的 Call 对象： okhttp3.Call toCall(@Nullable Object... args) throws IOException { RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody, isFormEncoded, isMultipart); // ... return callFactory.newCall(requestBuilder.build()); } toResponse(ResponseBody) 用来把 OkHttp 得到的响应体转换成 Java 对象等（在示例中是WXUserInfo）： R toResponse(ResponseBody body) throws IOException { return responseConverter.convert(body); } adapt(Call&lt;R&gt;) 用来将 OkHttp 的请求转换成我们的服务方法的返回类型（在示例中是Observable&lt;WXUserInfo&gt;）： T adapt(Call&lt;R&gt; call) { return callAdapter.adapt(call); } 3.2.3 请求封装：OkHttpCall解析完毕服务方法之后，我们得到了 ServiceMethod 实例。然后，我们使用它来创建 OkHttpCall 实例。这里的 OkHttpCall 实现了 Retrofit 中定义的 Call 接口，会在方法内调用 ServiceMethod 的 toCall() 方法来获取 OkHttp 中的 Call 对象，然后使用它进行网络访问。当拿到了请求的结果之后又使用 ServiceMethod 的 toResponse() 把响应转换成我们指定的类型。下面是该类中的几个比较重要的方法： execute() 方法，用来同步执行网络请求： 1234567891011121314151617181920212223@Overridepublic Response&lt;T&gt; execute() throws IOException &#123; okhttp3.Call call; synchronized (this) &#123; // ... call = rawCall; if (call == null) &#123; try &#123; // 创建 OkHttp 的 Call 实例 call = rawCall = createRawCall(); &#125; catch (IOException | RuntimeException | Error e) &#123; throwIfFatal(e); creationFailure = e; throw e; &#125; &#125; &#125; if (canceled) &#123; call.cancel(); &#125; // 同步执行请求，并解析结果 return parseResponse(call.execute());&#125; createRawCall() 用来创建 OkHttp 的 Call 实例： 12345678// 使用 serviceMethod 的 toCall 方法获取 OkHttp 的 Call 实例private okhttp3.Call createRawCall() throws IOException &#123; okhttp3.Call call = serviceMethod.toCall(args); if (call == null) &#123; throw new NullPointerException(&quot;Call.Factory returned null.&quot;); &#125; return call;&#125; parseResponse() 用来将 OkHttp 的响应转换成我们接口中定义的类型。比如，在我们的例子中，返回的是 Observable&lt;WXUserInfo&gt;: 1234567891011121314151617// 使用 serviceMethod 的 toResponse 方法获取 OkHttp 的 Response 实例Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; ResponseBody rawBody = rawResponse.body(); rawResponse = rawResponse.newBuilder() .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())) .build(); // ... ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody); try &#123; // 使用 serviceMethod 的 toResponse 方法获取 OkHttp 的 Response 实例 T body = serviceMethod.toResponse(catchingBody); return Response.success(body, rawResponse); &#125; catch (RuntimeException e) &#123; catchingBody.throwIfCaught(); throw e; &#125;&#125; 3.3 Retrofit 的工作过程上面是 Retrofit 框架设计中几个关键的部分的功能的解析。下面，我们再来具体看一下，从触发代理类的方法到拿到响应的结果，这一整个过程中，都有哪些类的哪些方法参与，以及它们在什么时候，扮演什么样的角色。这里我们仍然使用最初的示例： 上图中，我们将 Retrofit 的请求的过程分成三个过程来进行说明： 创建代理实例的过程：在这个过程中主要是调用 Proxy.newProxyInstance() 来获取一个代理实例。相关的主要参数是 validateEagerly，我们会使用它来决定是否立即对传入的接口的方法进行解析。不论我们什么时候进行解析，都会把解析的结果缓存起来。 触发代理方法的过程：触发代理方法是整个请求的第二过程，这个时候，我们调用了 WXInfoService 代理实例的 getWXUserInfo() 方法。此时，会触发 InvocationHandler 的 invoke() 方法。在该方法内部会调用 ServiceMethod 的构建者模式来创建 ServiceMethod 实例。当调用构建者模式的 build() 方法的时候，会对方法 getWXUserInfo() 的信息进行解析。然后，使用 ServiceMethod 实例创建 OkHttpCall。最后，使用 ServiceMethod 实例的 adapt() 方法将 OkHttpCall 实例转换成 Observable&lt;WXUserInfo&gt;。此时，会使用 CallAdapter 的 adapt() 方法来完成适配过程。 执行网络请求的过程：拿到了 Observable&lt;WXUserInfo&gt; 之后，需要对其进行订阅才能触发网络请求。相关的逻辑在 CallAdapter 中完成。首先，它会根据你使用同步还是异步的来决定使用哪个执行器。这里存在两个执行器，它们的区别是一个会在内部调用 OkHttpCall 的 enqueue()，另一个会在执行器中调用 OkHttpCall 的 execute() 方法。不论调用 enqueue() 还是 execute()，都会先使用 OkHttpCall 的 toCall() 方法获取一个 Call 请求。获取请求的过程中会使用 Converter 来将某个实例转换成请求体。拿到了请求之后，使用该请求来进行网络访问。当从网络中拿到了响应之后，会使用 Converter 来将响应体转换成对象。这样，拿到了实际的结果之后，就会调用 Observer 的 onNext() 方法把结果通知给观察者。 4、总结在这篇文章中，我们先简单介绍了 Retrofit 的使用，然后，因为 Retrofit 内部使用动态代理来实现的，所以，我们对动态代理相关内容进行了介绍。最后，我们对 Retrofit 的源码进行了分析，先从设计思路，后从各个环节的执行过程进行了说明。最后的最后，我们将两者结合起来用一个时序图做了说明。 从上文中可以看出来，Retrofit 设计的几个值得我们借鉴的地方： 使用运行时注解和反射简化请求描述，但是考虑到反射的效率比较低，所以将一次反射之后的结果缓存起来，以便于下次使用。 动态代理：使用接口描述请求的好处是它简洁，而且 “描述” 本来就是它的责任。但是，一般我们需要去实现接口才能使用。而这里告诉我们，使用动态代理一样可以使用接。 解耦：从我们上面的图中也可以看出来，Retrofit 的设计的思路是比较清晰的。它将一个请求的几个过程解耦出来。首先是我们 Observable 到请求的转换，这里使用适配器来完成；然后是请求体和响应体的转换，基本就是 Json 的转换，使用转换器来完成。这样，不论你使用 RxJava 1 还是 RxJava 2，不论是 Gson 还是 FastXml 都可以和 Retrifut 配合使用。 以上就是我们对 Retrofit 的源码的分析。]]></content>
      <categories>
        <category>Android网络访问</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>计算机网络</tag>
        <tag>OkHttp</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Andriod 网络框架 OkHttp 源码解析]]></title>
    <url>%2F2018%2F10%2F17%2FAndriod%20%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%20OkHttp%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1、OkHttp 的基本使用OkHttp 是 Square 的一款应用于 Android 和 Java 的 Http 和 Http/2 客户端。使用的时候只需要在 Gradle 里面加入下面一行依赖即可引入： implementation &apos;com.squareup.okhttp3:okhttp:3.11.0&apos; 我们知道，Http 请求有多种类型，常用的分为 Get 和 Post，而 POST 又分为 Form 和 Multiple 等。下面我们以 Form 类型的请求为例来看下 OkHttp 的 API 设计逻辑： OkHttpClient internalHttpClient = new OkHttpClient(); FormBody.Builder formBodyBuilder = new FormBody.Builder(); RequestBody body = formBodyBuilder.build(); Request.Builder builder = new Request.Builder().url(&quot;host:port/url&quot;).post(body); Request request = builder.build(); Response response = internalHttpClient.newCall(request).execute(); String retJson = response.body().string(); 这里我们先用了 FormBody 的构建者模式创建 Form 类型请求的请求体，然后使用 Request 的构建者创建完整的 Form 请求。之后，我们用创建好的 OkHttp 客户端 internalHttpClient 来获取一个请求，并从请求的请求体中获取 Json 数据。 根据 OkHttp 的 API，如果我们希望发送一个 Multipart 类型的请求的时候就需要使用 MultipartBody 的构建者创建 Multipart 请求的请求体。然后同样使用 Request 的构建者创建完整的 Multipart 请求，剩下的逻辑相同。 除了使用上面的直接实例化一个 OkHttp 客户端的方式，我们也可以使用 OkHttpClient 的构建者 OkHttpClient.Builder 来创建 OkHttp 客户端。 所以，我们可以总结： OkHttp 为不同的请求类型都提供了一个构建者方法用来创建请求体 RequestBody； 因为请求体只是整个请求的一部分，所以，又要用 Request.Builder 构建一个请求对象 Request； 这样我们得到了一个完整的 Http 请求，然后使用 OkHttpClient 对象进行网络访问得到响应对象 Response。 OkHttp 本身的设计比较友好，思路非常清晰，按照上面的思路搞懂了人家的 API 设计逻辑，自己再基于 OkHttp 封装一个库自然问题不大。 2、OkHttp 源码分析上面我们提到的一些是基础的 API 类，是提供给用户使用的。这些类的设计只是基于构建者模式，非常容易理解。这里我们关注点也不在这些 API 类上面，而是 OkHttp 内部的请求执行相关的类。下面我们就开始对 OkHttp 的请求过程进行源码分析（源码版本：3.10.0）。 2.1 一个请求的大致流程参考之前的示例程序，抛弃构建请求的过程不讲，单从请求的发送过程来看，我们的线索应该从 OkHttpClient.newCall(Request) 开始。下面是这个方法的定义，它会创建一个 RealCall 对象，并把 OkHttpClient 对象和 Request 对象作为参数传入进去： @Override public Call newCall(Request request) { return RealCall.newRealCall(this, request, false /* for web socket */); } 然后，RealCall 调用内部的静态方法 newRealCall 在其中创建一个 RealCall 实例并将其返回： static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { RealCall call = new RealCall(client, originalRequest, forWebSocket); call.eventListener = client.eventListenerFactory().create(call); return call; } 然后，当返回了 RealCall 之后，我们又会调用它的 execute() 方法来获取响应结果，下面是这个方法的定义： @Override public Response execute() throws IOException { synchronized (this) { if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; } captureCallStackTrace(); eventListener.callStart(this); try { // 加入到一个双端队列中 client.dispatcher().executed(this); // 从这里拿的响应Response Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(&quot;Canceled&quot;); return result; } catch (IOException e) { eventListener.callFailed(this, e); throw e; } finally { client.dispatcher().finished(this); } } 这里我们会用 client 对象（实际也就是上面创建 RealCall 的时候传入的 OkHttpClient）的 dispatcher() 方法来获取一个 Dispatcher 对象，并调用它的 executed() 方法来将当前的 RealCall 加入到一个双端队列中，下面是 executed(RealCall) 方法的定义，这里的 runningSyncCalls 的类型是 Deque&lt;RealCall&gt;： synchronized void executed(RealCall call) { runningSyncCalls.add(call); } 让我们回到上面的 execute() 方法，在把 RealCall 加入到双端队列之后，我们又调用了 getResponseWithInterceptorChain() 方法，下面就是该方法的定义。 Response getResponseWithInterceptorChain() throws IOException { // 添加一系列拦截器，注意添加的顺序 List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); // 桥拦截器 interceptors.add(new BridgeInterceptor(client.cookieJar())); // 缓存拦截器：从缓存中拿数据 interceptors.add(new CacheInterceptor(client.internalCache())); // 网络连接拦截器：建立网络连接 interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) { interceptors.addAll(client.networkInterceptors()); } // 服务器请求拦截器：向服务器发起请求获取数据 interceptors.add(new CallServerInterceptor(forWebSocket)); // 构建一条责任链 Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); // 处理责任链 return chain.proceed(originalRequest); } 这里，我们创建了一个列表对象之后把 client 中的拦截器、重连拦截器、桥拦截器、缓存拦截器、网络连接拦截器和服务器请求拦截器等依次加入到列表中。然后，我们用这个列表创建了一个拦截器链。这里使用了责任链设计模式，每当一个拦截器执行完毕之后会调用下一个拦截器或者不调用并返回结果。显然，我们最终拿到的响应就是这个链条执行之后返回的结果。当我们自定义一个拦截器的时候，也会被加入到这个拦截器链条里。 这里我们遇到了很多的新类，比如 RealCall、Dispatcher 以及责任链等。下文中，我们会对这些类之间的关系以及责任链中的环节做一个分析，而这里我们先对整个请求的流程做一个大致的梳理。下面是这个过程大致的时序图： 2.2 分发器 Dispatcher上面我们提到了 Dispatcher 这个类，它的作用是对请求进行分发。以最开始的示例代码为例，在使用 OkHttp 的时候，我们会创建一个 RealCall 并将其加入到双端队列中。但是请注意这里的双端队列的名称是 runningSyncCalls，也就是说这种请求是同步请求，会在当前的线程中立即被执行。所以，下面的 getResponseWithInterceptorChain() 就是这个同步的执行过程。而当我们执行完毕的时候，又会调用 Dispatcher 的 finished(RealCall) 方法把该请求从队列中移除。所以，这种同步的请求无法体现分发器的“分发”功能。 除了同步的请求，还有异步类型的请求：当我们拿到了 RealCall 的时候，调用它的 enqueue(Callback responseCallback) 方法并设置一个回调即可。该方法会执行下面这行代码： client.dispatcher().enqueue(new AsyncCall(responseCallback)); 即使用上面的回调创建一个 AsyncCall 并调用 enqueue(AsyncCall)。这里的 AsyncCall 间接继承自 Runnable，是一个可执行的对象，并且会在 Runnable 的 run() 方法里面调用 AsyncCall 的 execute() 方法。AsyncCall 的 execute() 方法与 RealCall 的 execute() 方法类似，都使用责任链来完成一个网络请求。只是后者可以放在一个异步的线程中进行执行。 当我们调用了 Dispatcher 的 enqueue(AsyncCall) 方法的时候也会将 AsyncCall 加入到一个队列中，并会在请求执行完毕的时候从该队列中移除，只是这里的队列是 runningAsyncCalls 或者 readyAsyncCalls。它们都是一个双端队列，并用来存储异步类型的请求。它们的区别是，runningAsyncCalls 是正在执行的队列，当正在执行的队列达到了限制的时候，就会将其放置到就绪队列 readyAsyncCalls 中： synchronized void enqueue(AsyncCall call) { if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) { runningAsyncCalls.add(call); executorService().execute(call); } else { readyAsyncCalls.add(call); } } 当把该请求加入到了正在执行的队列之后，我们会立即使用一个线程池来执行该 AsyncCall。这样这个请求的责任链就会在一个线程池当中被异步地执行了。这里的线程池由 executorService() 方法返回： public synchronized ExecutorService executorService() { if (executorService == null) { executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false)); } return executorService; } 显然，当线程池不存在的时候会去创建一个线程池。除了上面的这种方式，我们还可以在构建 OkHttpClient 的时候，自定义一个 Dispacher，并在其构造方法中为其指定一个线程池。下面我们类比 OkHttp 的同步请求绘制了一个异步请求的时序图。你可以通过将两个图对比来了解两种实现方式的不同： 以上就是分发器 Dispacher 的逻辑，看上去并没有那么复杂。并且从上面的分析中，我们可以看出实际请求的执行过程并不是在这里完成的，这里只能决定在哪个线程当中执行请求并把请求用双端队列缓存下来，而实际的请求执行过程是在责任链中完成的。下面我们就来分析一下 OkHttp 里的责任链的执行过程。 2.3 责任链的执行过程在典型的责任链设计模式里，很多对象由每一个对象对其下级的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。责任链在现实生活中的一种场景就是面试，当某轮面试官觉得你没有资格进入下一轮的时候可以否定你，不然会让下一轮的面试官继续面试。 在 OkHttp 里面，责任链的执行模式与之稍有不同。这里我们主要来分析一下在 OkHttp 里面，责任链是如何执行的，至于每个链条里面的具体逻辑，我们会在随后一一说明。 回到 2.1 的代码，有两个地方需要我们注意： 是当创建一个责任链 RealInterceptorChain 的时候，我们传入的第 5 个参数是 0。该参数名为 index，会被赋值给 RealInterceptorChain 实例内部的同名全局变量。 当启用责任链的时候，会调用它的 proceed(Request) 方法。 下面是 proceed(Request) 方法的定义： @Override public Response proceed(Request request) throws IOException { return proceed(request, streamAllocation, httpCodec, connection); } 这里又调用了内部的重载的 proceed() 方法。下面我们对该方法进行了简化： public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException { if (index &gt;= interceptors.size()) throw new AssertionError(); // ... // 调用责任链的下一个拦截器 RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); // ... return response; } 注意到这里使用责任链进行处理的时候，会新建下一个责任链并把 index+! 作为下一个责任链的 index。然后，我们使用 index 从拦截器列表中取出一个拦截器，调用它的 intercept() 方法，并把下一个执行链作为参数传递进去。 这样，当下一个拦截器希望自己的下一级继续处理这个请求的时候，可以调用传入的责任链的 proceed() 方法；如果自己处理完毕之后，下一级不需要继续处理，那么就直接返回一个 Response 实例即可。因为，每次都是在当前的 index 基础上面加 1，所以能在调用 proceed() 的时候准确地从拦截器列表中取出下一个拦截器进行处理。 我们还要注意的地方是之前提到过重试拦截器，这种拦截器会在内部启动一个 while 循环，并在循环体中调用执行链的 proceed() 方法来实现请求的不断重试。这是因为在它那里的拦截器链的 index 是固定的，所以能够每次调用 proceed() 的时候，都能够从自己的下一级执行一遍链条。下面就是这个责任链的执行过程： 清楚了 OkHttp 的拦截器链的执行过程之后，我们来看一下各个拦截器做了什么逻辑。 2.3 重试和重定向：RetryAndFollowUpInterceptorRetryAndFollowUpInterceptor 主要用来当请求失败的时候进行重试，以及在需要的情况下进行重定向。我们上面说，责任链会在进行处理的时候调用第一个拦截器的 intercept() 方法。如果我们在创建 OkHttp 客户端的时候没有加入自定义拦截器，那么RetryAndFollowUpInterceptor 就是我们的责任链中最先被调用的拦截器。 @Override public Response intercept(Chain chain) throws IOException { // ... // 注意这里我们初始化了一个 StreamAllocation 并赋值给全局变量，它的作用我们后面会提到 StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; // 用来记录重定向的次数 int followUpCount = 0; Response priorResponse = null; while (true) { if (canceled) { streamAllocation.release(); throw new IOException(&quot;Canceled&quot;); } Response response; boolean releaseConnection = true; try { // 这里从当前的责任链开始执行一遍责任链，是一种重试的逻辑 response = realChain.proceed(request, streamAllocation, null, null); releaseConnection = false; } catch (RouteException e) { // 调用 recover 方法从失败中进行恢复，如果可以恢复就返回true，否则返回false if (!recover(e.getLastConnectException(), streamAllocation, false, request)) { throw e.getLastConnectException(); } releaseConnection = false; continue; } catch (IOException e) { // 重试与服务器进行连接 boolean requestSendStarted = !(e instanceof ConnectionShutdownException); if (!recover(e, streamAllocation, requestSendStarted, request)) throw e; releaseConnection = false; continue; } finally { // 如果 releaseConnection 为 true 则表明中间出现了异常，需要释放资源 if (releaseConnection) { streamAllocation.streamFailed(null); streamAllocation.release(); } } // 使用之前的响应 priorResponse 构建一个响应，这种响应的响应体 body 为空 if (priorResponse != null) { response = response.newBuilder() .priorResponse(priorResponse.newBuilder().body(null).build()) .build(); } // 根据得到的响应进行处理，可能会增加一些认证信息、重定向或者处理超时请求 // 如果该请求无法继续被处理或者出现的错误不需要继续处理，将会返回 null Request followUp = followUpRequest(response, streamAllocation.route()); // 无法重定向，直接返回之前的响应 if (followUp == null) { if (!forWebSocket) { streamAllocation.release(); } return response; } // 关闭资源 closeQuietly(response.body()); // 达到了重定向的最大次数，就抛出一个异常 if (++followUpCount &gt; MAX_FOLLOW_UPS) { streamAllocation.release(); throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount); } if (followUp.body() instanceof UnrepeatableRequestBody) { streamAllocation.release(); throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code()); } // 这里判断新的请求是否能够复用之前的连接，如果无法复用，则创建一个新的连接 if (!sameConnection(response, followUp.url())) { streamAllocation.release(); streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(followUp.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; } else if (streamAllocation.codec() != null) { throw new IllegalStateException(&quot;Closing the body of &quot; + response + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;); } request = followUp; priorResponse = response; } } 以上的代码主要用来根据错误的信息做一些处理，会根据服务器返回的信息判断这个请求是否可以重定向，或者是否有必要进行重试。如果值得去重试就会新建或者复用之前的连接在下一次循环中进行请求重试，否则就将得到的请求包装之后返回给用户。这里，我们提到了 StreamAllocation 对象，它相当于一个管理类，维护了服务器连接、并发流和请求之间的关系，该类还会初始化一个 Socket 连接对象，获取输入/输出流对象。同时，还要注意这里我们通过 client.connectionPool() 传入了一个连接池对象 ConnectionPool。这里我们只是初始化了这些类，但实际在当前的方法中并没有真正用到这些类，而是把它们传递到下面的拦截器里来从服务器中获取请求的响应。稍后，我们会说明这些类的用途，以及之间的关系。 2.4 BridgeInterceptor桥拦截器 BridgeInterceptor 用于从用户的请求中构建网络请求，然后使用该请求访问网络，最后从网络响应当中构建用户响应。相对来说这个拦截器的逻辑比较简单，只是用来对请求进行包装，并将服务器响应转换成用户友好的响应： public final class BridgeInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Request userRequest = chain.request(); // 从用户请求中获取网络请求构建者 Request.Builder requestBuilder = userRequest.newBuilder(); // ... // 执行网络请求 Response networkResponse = chain.proceed(requestBuilder.build()); // ... // 从网络响应中获取用户响应构建者 Response.Builder responseBuilder = networkResponse.newBuilder().request(userRequest); // ... // 返回用户响应 return responseBuilder.build(); } } 2.5 使用缓存：CacheInterceptor缓存拦截器会根据请求的信息和缓存的响应的信息来判断是否存在缓存可用，如果有可以使用的缓存，那么就返回该缓存该用户，否则就继续责任链来从服务器中获取响应。当获取到响应的时候，又会把响应缓存到磁盘上面。以下是这部分的逻辑： public final class CacheInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); // 根据请求和缓存的响应中的信息来判断是否存在缓存可用 CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; // 如果该请求没有使用网络就为空 Response cacheResponse = strategy.cacheResponse; // 如果该请求没有使用缓存就为空 if (cache != null) { cache.trackResponse(strategy); } if (cacheCandidate != null &amp;&amp; cacheResponse == null) { closeQuietly(cacheCandidate.body()); } // 请求不使用网络并且不使用缓存，相当于在这里就拦截了，没必要交给下一级（网络请求拦截器）来执行 if (networkRequest == null &amp;&amp; cacheResponse == null) { return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message(&quot;Unsatisfiable Request (only-if-cached)&quot;) .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); } // 该请求使用缓存，但是不使用网络：从缓存中拿结果，没必要交给下一级（网络请求拦截器）执行 if (networkRequest == null) { return cacheResponse.newBuilder().cacheResponse(stripBody(cacheResponse)).build(); } Response networkResponse = null; try { // 这里调用了执行链的处理方法，实际就是交给自己的下一级来执行了 networkResponse = chain.proceed(networkRequest); } finally { if (networkResponse == null &amp;&amp; cacheCandidate != null) { closeQuietly(cacheCandidate.body()); } } // 这里当拿到了网络请求之后调用，下一级执行完毕会交给它继续执行，如果使用了缓存就把请求结果更新到缓存里 if (cacheResponse != null) { // 服务器返回的结果是304，返回缓存中的结果 if (networkResponse.code() == HTTP_NOT_MODIFIED) { Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); cache.trackConditionalCacheHit(); // 更新缓存 cache.update(cacheResponse, response); return response; } else { closeQuietly(cacheResponse.body()); } } Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); // 把请求的结果放进缓存里 if (cache != null) { if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) { CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); } if (HttpMethod.invalidatesCache(networkRequest.method())) { try { cache.remove(networkRequest); } catch (IOException ignored) { // The cache cannot be written. } } } return response; } } 对缓存，这里我们使用的是全局变量 cache，它是 InternalCache 类型的变量。InternalCache 是一个接口，在 OkHttp 中只有一个实现类 Cache。在 Cache 内部，使用了 DiskLruCache 来将缓存的数据存到磁盘上。DiskLruCache 以及 LruCache 是 Android 上常用的两种缓存策略。前者是基于磁盘来进行缓存的，后者是基于内存来进行缓存的，它们的核心思想都是 Least Recently Used，即最近最少使用算法。我们会在以后的文章中详细介绍这两种缓存框架，也请继续关注我们的文章。 另外，上面我们根据请求和缓存的响应中的信息来判断是否存在缓存可用的时候用到了 CacheStrategy 的两个字段，得到这两个字段的时候使用了非常多的判断，其中涉及 Http 缓存相关的知识，感兴趣的话可以自己参考源代码。 2.6 连接复用：ConnectInterceptor连接拦截器 ConnectInterceptor 用来打开到指定服务器的网络连接，并交给下一个拦截器处理。这里我们只打开了一个网络连接，但是并没有发送请求到服务器。从服务器获取数据的逻辑交给下一级的拦截器来执行。虽然，这里并没有真正地从网络中获取数据，而仅仅是打开一个连接，但这里有不少的内容值得我们去关注。因为在获取连接对象的时候，使用了连接池 ConnectionPool 来复用连接。 public final class ConnectInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;); HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection); } } 这里的 HttpCodec 用来编码请求并解码响应，RealConnection 用来向服务器发起连接。它们会在下一个拦截器中被用来从服务器中获取响应信息。下一个拦截器的逻辑并不复杂，这里万事具备之后，只要它来从服务器中读取数据即可。可以说，OkHttp 中的核心部分大概就在这里，所以，我们就先好好分析一下，这里在创建连接的时候如何借助连接池来实现连接复用的。 根据上面的代码，当我们调用 streamAllocation 的 newStream() 方法的时候，最终会经过一系列的判断到达 StreamAllocation 中的 findConnection() 方法。 private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException { // ... synchronized (connectionPool) { // ... // 尝试使用已分配的连接，已经分配的连接可能已经被限制创建新的流 releasedConnection = this.connection; // 释放当前连接的资源，如果该连接已经被限制创建新的流，就返回一个Socket以关闭连接 toClose = releaseIfNoNewStreams(); if (this.connection != null) { // 已分配连接，并且该连接可用 result = this.connection; releasedConnection = null; } if (!reportedAcquired) { // 如果该连接从未被标记为获得，不要标记为发布状态，reportedAcquired 通过 acquire() 方法修改 releasedConnection = null; } if (result == null) { // 尝试供连接池中获取一个连接 Internal.instance.get(connectionPool, address, this, null); if (connection != null) { foundPooledConnection = true; result = connection; } else { selectedRoute = route; } } } // 关闭连接 closeQuietly(toClose); if (releasedConnection != null) { eventListener.connectionReleased(call, releasedConnection); } if (foundPooledConnection) { eventListener.connectionAcquired(call, result); } if (result != null) { // 如果已经从连接池中获取到了一个连接，就将其返回 return result; } boolean newRouteSelection = false; if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection.hasNext())) { newRouteSelection = true; routeSelection = routeSelector.next(); } synchronized (connectionPool) { if (canceled) throw new IOException(&quot;Canceled&quot;); if (newRouteSelection) { // 根据一系列的 IP 地址从连接池中获取一个链接 List&lt;Route&gt; routes = routeSelection.getAll(); for (int i = 0, size = routes.size(); i &lt; size; i++) { Route route = routes.get(i); // 从连接池中获取一个连接 Internal.instance.get(connectionPool, address, this, route); if (connection != null) { foundPooledConnection = true; result = connection; this.route = route; break; } } } if (!foundPooledConnection) { if (selectedRoute == null) { selectedRoute = routeSelection.next(); } // 创建一个新的连接，并将其分配，这样我们就可以在握手之前进行终端 route = selectedRoute; refusedStreamCount = 0; result = new RealConnection(connectionPool, selectedRoute); acquire(result, false); } } // 如果我们在第二次的时候发现了一个池连接，那么我们就将其返回 if (foundPooledConnection) { eventListener.connectionAcquired(call, result); return result; } // 进行 TCP 和 TLS 握手 result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, call, eventListener); routeDatabase().connected(result.route()); Socket socket = null; synchronized (connectionPool) { reportedAcquired = true; // 将该连接放进连接池中 Internal.instance.put(connectionPool, result); // 如果同时创建了另一个到同一地址的多路复用连接，释放这个连接并获取那个连接 if (result.isMultiplexed()) { socket = Internal.instance.deduplicate(connectionPool, address, this); result = connection; } } closeQuietly(socket); eventListener.connectionAcquired(call, result); return result; } 该方法会被放置在一个循环当中被不停地调用以得到一个可用的连接。它优先使用当前已经存在的连接，不然就使用连接池中存在的连接，再不行的话，就创建一个新的连接。所以，上面的代码大致分成三个部分： 判断当前的连接是否可以使用：流是否已经被关闭，并且已经被限制创建新的流； 如果当前的连接无法使用，就从连接池中获取一个连接； 连接池中也没有发现可用的连接，创建一个新的连接，并进行握手，然后将其放到连接池中。 在从连接池中获取一个连接的时候，使用了 Internal 的 get() 方法。Internal 有一个静态的实例，会在 OkHttpClient 的静态代码快中被初始化。我们会在 Internal 的 get() 中调用连接池的 get() 方法来得到一个连接。 从上面的代码中我们也可以看出，实际上，我们使用连接复用的一个好处就是省去了进行 TCP 和 TLS 握手的一个过程。因为建立连接本身也是需要消耗一些时间的，连接被复用之后可以提升我们网络访问的效率。那么这些连接被放置在连接池之后是如何进行管理的呢？我们会在下文中分析 OkHttp 的 ConnectionPool 中是如何管理这些连接的。 2.7 CallServerInterceptor服务器请求拦截器 CallServerInterceptor 用来向服务器发起请求并获取数据。这是整个责任链的最后一个拦截器，这里没有再继续调用执行链的处理方法，而是把拿到的响应处理之后直接返回给了上一级的拦截器： public final class CallServerInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { RealInterceptorChain realChain = (RealInterceptorChain) chain; // 获取 ConnectInterceptor 中初始化的 HttpCodec HttpCodec httpCodec = realChain.httpStream(); // 获取 RetryAndFollowUpInterceptor 中初始化的 StreamAllocation StreamAllocation streamAllocation = realChain.streamAllocation(); // 获取 ConnectInterceptor 中初始化的 RealConnection RealConnection connection = (RealConnection) realChain.connection(); Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); realChain.eventListener().requestHeadersStart(realChain.call()); // 在这里写入请求头 httpCodec.writeRequestHeaders(request); realChain.eventListener().requestHeadersEnd(realChain.call(), request); Response.Builder responseBuilder = null; if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) { if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) { httpCodec.flushRequest(); realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(true); } // 在这里写入请求体 if (responseBuilder == null) { realChain.eventListener().requestBodyStart(realChain.call()); long contentLength = request.body().contentLength(); CountingSink requestBodyOut = new CountingSink(httpCodec.createRequestBody(request, contentLength)); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); // 写入请求体 request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); realChain.eventListener() .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount); } else if (!connection.isMultiplexed()) { streamAllocation.noNewStreams(); } } httpCodec.finishRequest(); if (responseBuilder == null) { realChain.eventListener().responseHeadersStart(realChain.call()); // 读取响应头 responseBuilder = httpCodec.readResponseHeaders(false); } Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); // 读取响应体 int code = response.code(); if (code == 100) { responseBuilder = httpCodec.readResponseHeaders(false); response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); code = response.code(); } realChain.eventListener().responseHeadersEnd(realChain.call(), response); if (forWebSocket &amp;&amp; code == 101) { response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); } else { response = response.newBuilder() .body(httpCodec.openResponseBody(response)) .build(); } // ... return response; } } 2.8 连接管理：ConnectionPool与请求的缓存类似，OkHttp 的连接池也使用一个双端队列来缓存已经创建的连接： private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;(); OkHttp 的缓存管理分成两个步骤，一边当我们创建了一个新的连接的时候，我们要把它放进缓存里面；另一边，我们还要来对缓存进行清理。在 ConnectionPool 中，当我们向连接池中缓存一个连接的时候，只要调用双端队列的 add() 方法，将其加入到双端队列即可，而清理连接缓存的操作则交给线程池来定时执行。 在 ConnectionPool 中存在一个静态的线程池： private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */, Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp ConnectionPool&quot;, true)); 每当我们向连接池中插入一个连接的时候就会调用下面的方法，将连接插入到双端队列的同时，会调用上面的线程池来执行清理缓存的任务： void put(RealConnection connection) { assert (Thread.holdsLock(this)); if (!cleanupRunning) { cleanupRunning = true; // 使用线程池执行清理任务 executor.execute(cleanupRunnable); } // 将新建的连接插入到双端队列中 connections.add(connection); } 这里的清理任务是 cleanupRunnable，是一个 Runnable 类型的实例。它会在方法内部调用 cleanup() 方法来清理无效的连接： private final Runnable cleanupRunnable = new Runnable() { @Override public void run() { while (true) { long waitNanos = cleanup(System.nanoTime()); if (waitNanos == -1) return; if (waitNanos &gt; 0) { long waitMillis = waitNanos / 1000000L; waitNanos -= (waitMillis * 1000000L); synchronized (ConnectionPool.this) { try { ConnectionPool.this.wait(waitMillis, (int) waitNanos); } catch (InterruptedException ignored) { } } } } } }; 下面是 cleanup() 方法： long cleanup(long now) { int inUseConnectionCount = 0; int idleConnectionCount = 0; RealConnection longestIdleConnection = null; long longestIdleDurationNs = Long.MIN_VALUE; synchronized (this) { // 遍历所有的连接 for (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) { RealConnection connection = i.next(); // 当前的连接正在使用中 if (pruneAndGetAllocationCount(connection, now) &gt; 0) { inUseConnectionCount++; continue; } idleConnectionCount++; // 如果找到了一个可以被清理的连接，会尝试去寻找闲置时间最久的连接来释放 long idleDurationNs = now - connection.idleAtNanos; if (idleDurationNs &gt; longestIdleDurationNs) { longestIdleDurationNs = idleDurationNs; longestIdleConnection = connection; } } if (longestIdleDurationNs &gt;= this.keepAliveDurationNs || idleConnectionCount &gt; this.maxIdleConnections) { // 该连接的时长超出了最大的活跃时长或者闲置的连接数量超出了最大允许的范围，直接移除 connections.remove(longestIdleConnection); } else if (idleConnectionCount &gt; 0) { // 闲置的连接的数量大于0，停顿指定的时间（等会儿会将其清理掉，现在还不是时候） return keepAliveDurationNs - longestIdleDurationNs; } else if (inUseConnectionCount &gt; 0) { // 所有的连接都在使用中，5分钟后再清理 return keepAliveDurationNs; } else { // 没有连接 cleanupRunning = false; return -1; } } closeQuietly(longestIdleConnection.socket()); return 0; } 在从缓存的连接中取出连接来判断是否应该将其释放的时候使用到了两个变量 maxIdleConnections 和 keepAliveDurationNs，分别表示最大允许的闲置的连接的数量和连接允许存活的最长的时间。默认空闲连接最大数目为5个，keepalive 时间最长为5分钟。 上面的方法会对缓存中的连接进行遍历，以寻找一个闲置时间最长的连接，然后根据该连接的闲置时长和最大允许的连接数量等参数来决定是否应该清理该连接。同时注意上面的方法的返回值是一个时间，如果闲置时间最长的连接仍然需要一段时间才能被清理的时候，会返回这段时间的时间差，然后会在这段时间之后再次对连接池进行清理。 总结：以上就是我们对 OkHttp 内部网络访问的源码的分析。当我们发起一个请求的时候会初始化一个 Call 的实例，然后根据同步和异步的不同，分别调用它的 execute() 和 enqueue() 方法。虽然，两个方法一个会在当前的线程中被立即执行，一个会在线程池当中执行，但是它们进行网络访问的逻辑都是一样的：通过拦截器组成的责任链，依次经过重试、桥接、缓存、连接和访问服务器等过程，来获取到一个响应并交给用户。其中，缓存和连接两部分内容是重点，因为前者涉及到了一些计算机网络方面的知识，后者则是 OkHttp 效率和框架的核心。]]></content>
      <categories>
        <category>Android网络访问</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>计算机网络</tag>
        <tag>OkHttp</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 体系详解：坐标系、滑动事件和分发机制]]></title>
    <url>%2F2018%2F10%2F14%2FView%20%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%9D%90%E6%A0%87%E7%B3%BB%E3%80%81%E6%BB%91%E5%8A%A8%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1、位置1.1 坐标系下面是 Android 中的 View 坐标系的基本图。要获得一个 View 的位置，我们可以借助两个对象，一个是 View ，一个是 MotionEvent。以下是它们的一些方法的位置的含义： 在 View 中共有 mLeft, mRight, mTop 和 mBottom 四个变量包含 View 的坐标信息，你可以在源码中获取它们的含义： mLeft：指定控件的左边缘距离其父控件左边缘的位置，单位：像素； mRight：指定控件的右边缘距离其父控件左边缘的位置，单位：像素； mTop：指定控件的上边缘距离其父控件上边缘的位置，单位：像素； mBottom：指定控件的下边缘距离其父控件上边缘的位置，单位：像素。 此外，View 中还有几个方法用来获取控件的位置等信息，实际上就是上面四个变量的 getter 方法： getLeft()：即 mLeft； getRight()：即 mRight； getTop()：即 mTop； getBottom()：即 mBottom； 所以，我们可以得到两个获取 View 高度和宽度信息的方法： getHeight()：即 mBottom - mTop； getWidth()：即 mRight - mLeft； 另外，就是 View 中的 getX() 和 getY() 两个方法，你需要注意将其与 MotionEvent 中的同名方法进行区分。在没有对控件进行平移的时候，getX() 与 getLeft() 返回结果相同，只是前者会在后者的基础上加上平移的距离： getX()：即 mLeft + getTranslationX()，即控件的左边缘加上 X 方向平移的距离； getY()：即 mTop + getTranslationY()，即控件的上边缘加上 Y 方向平移的距离； 以上是我们对 View 中获取控件位置的方法的梳理，你可以到源码中查看它们更加相详尽的定义，那更有助于自己的理解。 1.2 MotionEvent通常当你对控件进行触摸监听的时候会用到 MotionEvent ，它封住了触摸的位置等信息。下面我们对 MotionEvent 中的获取点击事件的位置的方法进行梳理，它主要涉及下面四个方法： MotionEvent.getX()：获取点击事件距离控件左边缘的距离，单位：像素； MotionEvent.getY()：获取点击事件距离控件上边缘的距离，单位：像素； MotionEvent.getRawX()：获取点击事件距离屏幕左边缘的距离，单位：像素； MotionEvent.getRawY()：获取点击事件距离屏幕上边缘的距离，单位：像素。 另外是触摸事件中的三种典型的行为，按下、移动和抬起。接下来的代码示例中我们会用到它们来判断手指的行为，并对其做响应的处理： MotionEvent.ACTION_DOWN：按下的行为； MotionEvent.ACTION_MOVE：手指在屏幕上移动的行为； MotionEvent.ACTION_UP：手指抬起的行为。 2、滑动我们有几种方式实现 View 的滑动： 2.1 layout() 方法调用控件的 layout() 方法进行滑动，下面是该方法的定义： 1public void layout(int l, int t, int r, int b) &#123; /*...*/ &#125; 其中的四个参数 l, t, r, b分别表示控件相对于父控件的左、上、右、下的距离，分别对应于上面的 mLeft, mTop, mRight 和 mBottom。所以，调用该方法同时可以改变控件的高度和宽度，但有时候我们不需要改变控件的高度和宽度，只要移动其位置即可。所以，我们又有方法 offsetLeftAndRight() 和 offsetTopAndBottom() 可以使用，后者只会对控件的位置进行平移。因此，我们可以进行如下的代码测试： private int lastX, lastY; private void layoutMove(MotionEvent event) { int x = (int) event.getX(), y = (int) event.getY(); switch (event.getAction()) { case MotionEvent.ACTION_DOWN: lastX = x; lastY = y; break; case MotionEvent.ACTION_MOVE: int offsetX = x - lastX, offsetY = y - lastY; getBinding().v.layout(getBinding().v.getLeft() + offsetX, getBinding().v.getTop() + offsetY, getBinding().v.getRight() + offsetX, getBinding().v.getBottom() + offsetY); break; case MotionEvent.ACTION_UP: break; } } 上面的代码的效果是指定的控件会随着手指的移动而移动。这里我们先记录下按下的位置，然后手指移动的时候记录下平移的位置，最后调用 layout() 即可。 2.2 offsetLeftAndRight() 和 offsetTopAndBottom()上面已经提到过这两个方法，它们只改变控件的位置，无法改变大小。我们只需要对上述代码做少量修改就可以实现同样的效果： getBinding().v.offsetLeftAndRight(offsetX); getBinding().v.offsetTopAndBottom(offsetY); 2.3 改变布局参数通过获取并修改控件的 LayoutParams，我们一样可以达到修改控件的位置的目的。毕竟，本身这个对象就代表着控件的布局： FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) getBinding().v.getLayoutParams(); lp.leftMargin = getBinding().v.getLeft() + offsetX; lp.topMargin = getBinding().v.getTop() + offsetY; getBinding().v.setLayoutParams(lp); 2.4 动画使用动画我们也可以实现控件移动的效果，这里所谓的动画主要是操作 View 的 transitionX 和 transitionY 属性： getBinding().v.animate().translationX(5f); getBinding().v.animate().translationY(5f); 关于动画的内容，我们会在后面详细介绍。 2.5 scrollTo() 和 scrollBy()scrollBy() 方法内部调用了 scrollTo()，以下是这部分的源码。scrollBy() 表示在当前的位置上面进行平移，而 scrollTo() 表示平移到指定的位置： public void scrollBy(int x, int y) { scrollTo(mScrollX + x, mScrollY + y); } 同样对上述代码进行修改，我们也可以实现之前的效果： ((View) getBinding().v.getParent()).scrollBy(-offsetX, -offsetY); 或者 View parent = ((View) getBinding().v.getParent()); parent.scrollTo(parent.getScrollX()-offsetX, parent.getScrollY()-offsetY); 此外，还有一个需要注意的地方是：与上面的 offsetLeftAndRight() 和 offsetTopAndBottom() 不同的是，这里我们用了平移的值的相反数。原因很简单，因为我们要使用这两个方法的时候需要对指定的控件所在的父容器进行调用（正如上面是先获取父控件）。当我们希望控件相对于之前的位置向右下方向移动，就应该让父容器相对于之前的位置向左上方向移动。因为实际上该控件相对于父控件的位置没有发生变化，变化的是父控件的位置。（参考的坐标系不同） 2.6 Scroller上面，我们的测试代码是让指定的控件随着手指移动，但是假如我们希望控件从一个位置移动到另一个位置呢？当然，它们也可以实现，但是这几乎就是在瞬间完成了整个操作，实际的UI效果肯定不会好。所以，为了让滑动的过程看起来更加流畅，我们可以借助 Scroller 来实现。 在使用 Scroller 之前，我们需要先实例化一个 Scroller ： private Scroller scroller = new Scroller(getContext()); 然后，我们需要覆写自定义控件的 computeScroll() 方法，这个方法会在绘制 View 的时候被调用。所以，这里的含义就是，当 View 重绘的时候会调用 computeScroll() 方法，而 computeScroll() 方法会判断是否需要继续滚动，如果需要继续滚动的时候就调用 invalidate() 方法，该方法会导致 View 进一步重绘。所以，也就是靠着这种不断进行重绘的方式实现了滚动的效果。 滑动效果最终结束的判断是通过 Scroller 的 computeScrollOffset() 方法实现的，当滚动停止的时候，该方法就会返回 false，这样不会继续调用 invalidate() 方法，因而也就不会继续绘制了。下面是该方法典型的覆写方式： @Override public void computeScroll() { super.computeScroll(); if (scroller.computeScrollOffset()) { ((View) getParent()).scrollTo(scroller.getCurrX(), scroller.getCurrY()); invalidate(); } } 然后，我们再加入一个滚动到指定位置的方法，在该方法内部我们使用了 2000ms 来指定完成整个滑动所需要的时间： public void smoothScrollTo(int descX, int descY) { scroller.startScroll(getScrollX(), getScrollY(), descX - getScrollX(), descY - getScrollY(), 2000); invalidate(); } 这样定义了之后，我们只需要在需要滚动的时候调用自定义 View 的 smoothScrollTo() 方法即可。 3、手势3.1 ViewConfiguration在类 ViewConfiguration 中定义了一些列的常量用来标志指定的行为，比如，TouchSlop 就是滑动的最小的距离。你可以通过 ViewConfiguration.get(context) 来获取 ViewConfiguration 实例，然后通过它的 getter 方法来获取这些常量的定义。 3.2 VelocityTrackerVelocityTracker 用来检测手指滑动的速率，它的使用非常简单。在使用之前，我们先使用它的静态方法 obtain() 获取一个实例，然后在 onTouch() 方法中调用它的 addMovement(MotionEvent) 方法： velocityTracker = VelocityTracker.obtain(); 随后，当我们想要获得速率的时候，先调用 computeCurrentVelocity(int) 传入一个时间片段，单位是毫秒，然后调用 getXVelocity() 和 getYVelocity() 分别获得在水平和竖直方向上的速率即可： velocityTracker.computeCurrentVelocity((int) duration); getBinding().tvVelocity.setText(&quot;X:&quot; + velocityTracker.getXVelocity() + &quot;\n&quot; + &quot;Y:&quot; + velocityTracker.getYVelocity()); 本质上，计算速率的时候是用指定时间的长度变化除以我们传入的时间片。当我们使用完了 VelocityTracker 之后，需要回收资源： velocityTracker.clear(); velocityTracker.recycle(); 3.3 GestureDectectorGestureDectector 用来检测手指的手势。在使用它之前我们需要先获取一个 GestureDetector 的实例： mGestureDetector = new GestureDetector(getContext(), new MyOnGestureListener()); 这里我们用了 GestureDetector 的构造方法，需要传入一个 OnGestureListener 对象。这里我们用了 MyOnGestureListener 实例。 MyOnGestureListener 是一个自定义的类，实现了 OnGestureListener 接口： private class MyOnGestureListener extends GestureDetector.SimpleOnGestureListener { @Override public boolean onSingleTapUp(MotionEvent e) { ToastUtils.makeToast(&quot;Click detected&quot;); return false; } @Override public void onLongPress(MotionEvent e) { LogUtils.d(&quot;Long press detected&quot;); } @Override public boolean onDoubleTap(MotionEvent e) { LogUtils.d(&quot;Double tab detected&quot;); return true; } @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) { LogUtils.d(&quot;Fling detected&quot;); return true; } } 在 MyOnGestureListener 中，我们覆写了它的一些方法。比如，单击、双击和长按等等，当检测到相应的手势的时候这些方法就会被调用。 然后，我们可以这样使用 GestureDetector，只要在控件的触摸事件回调中调用即可： getBinding().vg.setOnTouchListener((v, event) -&gt; { mGestureDetector.onTouchEvent(event); return true; }); 4、事件分发机制4.1 事件传递的过程当讨论事件分发机制的时候，我们首先要了解 Android 中 View 的组成结构。在 Android 中，一个 Activity 包含一个 PhoneWindow，当我们在 Activity 中调用 setContentView() 方法的时候，会调用该 PhoneWindow 的 setContentView() 方法，并在这个方法中生成一个 DecorView 作为 Activity 的跟 View。 根据上面的分析，当一个点击事件被触发的时候，首先接收到该事件的是 Activity。因为，Activity 覆盖了整个屏幕，我们需要先让它接收事件，然后它把事件传递给根 View 之后，再由根 View 向下继续传递。这样不断缩小搜索的范围，直到最顶层的 View。当然，任何的父容器都可以决定这个事件是不是要继续向下传递，因此，我们可以大致得到下面这个事件传递的图： 左边的图是一个 Activity 内部的 View 和 Window 的组织结构。右面的图可以看作它的切面图，其中的黑色箭头表示事件的传递过程。这里事件传递的过程是先从下到上，然后再从上到下。也就是从大到小，不断定位到触摸的控件，其中每个父容器可以决定是否将事件传递下去。（需要注意的地方是，如果一个父容器有多个子元素的话，那么在这些子元素中进行遍历的时候，顺序是从上往下的，也就是按照展示的顺序）。 上面我们分析了 Android 事件传递的过程，相信你有了一个大致的了解。但是，想要了解整个事件传递过程具体涉及了哪些方法、如何作用等，还需要我们对源码进行分析。 4.2 事件传递的原理当触摸事件发生的时候，首先会被 Activity 接收到，然后该 Activity 会通过其内部的 dispatchTouchEvent(MotionEvent) 将事件传递给内部的 PhoneWindow；接着 PhoneWindow 会把事件交给 DecorView，再由 DecorView 交给根 ViewGroup。剩下的事件传递就只在 ViewGroup 和 View 之间进行。我们可以通过覆写 Activity 的 dispatchTouchEvent(MotionEvent) 来阻止把事件传递给 PhoneWindow。实际上，在我们开发的时候不会对 Window 的事件传递方法进行重写，一般是对 ViewGroup 或者 View。所以，下面我们的分析只在这两种控件之间进行。 当讨论 View 的事件分发机制的时候，无外乎下面三个方法： boolean onInterceptTouchEvent(MotionEvent ev)：用来对事件进行拦截，该方法只存在于 ViewGroup 中。一般我们会通过覆写该方法来拦截触摸事件，使其不再继续传递给子 View。 boolean dispatchTouchEvent(MotionEvent event)：用来分发触摸事件，一般我们不覆写该方法，返回 true 则表示事件被处理了。在 View 中，它负责根据手势的类型和控件的状态对事件进行处理，会回调我们的 OnTouchListener 或者 OnClickListener；在 ViewGroup 中，该方法被覆写，它的责任是对事件进行分发，会对所有的子 View 进行遍历，决定是否将事件分发给指定的 View。 boolean onTouchEvent(MotionEvent event)：用于处理触摸事件，返回 true 表示触摸事件被处理了。ViewGroup 没有覆写该方法，故在 ViewGroup 中与 View 中的功能是一样的。需要注意的是，如果我们为控件设置了 OnTouchListener 并且在或者中返回了 true，那么这个方法不会被调用，也就是 OnTouchListener 比该方法的优先级较高。对我们开发来说，就是 OnTouchListener 比 OnClickListener 和 OnLongClickListener 的优先级要高。 于是，我们可以得到如下的伪代码。这段代码是存在于 ViewGroup 中的，也就是事件分发机制的核心代码： boolean dispatchTouchEvent(MotionEvent e) { boolean result; if (onInterceptTouchEvent(e)) { result = super.dispatchTouchEvent(e); } else { result = child.dispatchTouchEvent(e); } return result; } 按照上述分析，触摸事件经过 Activity 传递给根 ViewGroup 之后： 如果 ViewGourp 覆写了 onInterceptTouchEvent() 并且返回了 true 就表示希望拦截该方法，于是就把触摸事件交给当前 ViewGroup 进行处理（触发 OnTouchListener 或者 OnClickListener 等）；否则，会交给子元素的继续分发。如果该子元素是 ViewGroup 的话，就会在该子 View 中执行一遍上述逻辑，否则会在当前的子元素中对事件进行处理（触发 OnTouchListener 或者 OnClickListener 等）……就这样一层层地遍历下去，本质上是一个深度优先的搜索算法。 这里我们对整个事件分发机制的整体做了一个素描，在接下来的文章中我们会对各个方法的细节进行源码分析，为了防止您在接下来的行文中迷路，我们先把这个整体逻辑按下图进行描述： 4.3 事件传递的源码分析上述我们分析了事件分发机制的原理，下面我们通过源代码来更具体地了解这块是如何设计的。同样，我们的焦点也只在那三个需要重点关注的方法。 4.3.1 决定是否拦截事件首先，我们来看 ViewGroup 中的 dispatchTouchEvent(MotionEvent) 方法，我们节选了其一部分： @Override public boolean dispatchTouchEvent(MotionEvent ev) { // ... boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; if (actionMasked == MotionEvent.ACTION_DOWN) { // 1 // 这里表示如果是一个新的触摸事件就要重置所有的状态，其中包括将 mFirstTouchTarget 置为 null cancelAndClearTouchTargets(ev); resetTouchState(); } // 在这里检查是否拦截了事件，mFirstTouchTarget 是之前处理触摸事件的 View 的封装 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { // 这里判断该 ViewGroup 是否禁用了拦截，由 requestDisallowInterceptTouchEvent 设置 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); } else { intercepted = false; } } else { // 非按下事件并且 mFirstTouchTarget 为 null，说明判断过拦截的逻辑并且启用了拦截 intercepted = true; } // ... } // ... return handled; } 上面代码是我们节选的 ViewGroup 拦截事件的部分代码，这里的逻辑显然比伪代码复杂的多。不过，尽管如此，这些代码确实必不可少的。因为，当我们要去判断是否拦截一个触摸事件的时候，此时触摸的事件仍然在继续，这意味着这个方法会被持续调用；抬起的时候再按下，又是另一次调用。考虑到这个连续性，我们需要多做一些逻辑。 这里我们首先在 1 处通过行为是否是“按下”的来判断是否是一次新的触摸事件，如果是的话我们需要重置当前的触摸状态。其次，我们需要根据事件的类型来决定是否应该调用 onInterceptTouchEvent()，因为对一次触摸事件，我们只需要在“按下”的时候判断一次就够了。所以，显然我们需要将 MotionEvent.ACTION_DOWN 作为一个判断条件。然后，我们使用 mFirstTouchTarget 这个全局的变量来记录上次拦截的结果——如果之前的事件交给过子元素处理，那么它就不为空。 除了 mFirstTouchTarget，我们还需要用 mGroupFlags 的 FLAG_DISALLOW_INTERCEPT 标志位来判断该 ViewGroup 是否禁用了拦截。这个标志位可以通过 ViewGroup 的 requestDisallowInterceptTouchEvent(boolean) 来设置。只有没有禁用拦截事件的时候我们才需要调用 onInterceptTouchEvent() 判断是否开启了拦截。 4.3.2 分发事件给子元素如果在上面的操作中事件没有被拦截并且没有被取消，那么就会进入下面的逻辑。这部分代码处在 dispatchTouchEvent() 中。在下面的逻辑中会根据子元素的状态将事件传递给子元素： // 对子元素进行倒序遍历，即从上到下进行遍历 final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); // ... // 判断子元素是否能接收触摸事件：能接收事件并且不是正在进行动画的状态 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } // ... // 在这里调用了 dispatchTransformedTouchEvent() 方法将事件传递给子元素 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // ... 记录一些状态信息 // 在这里完成对 mFirstTouchTarget 的赋值，表示触摸事件被子元素处理 newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; // 结束循环，完成子元素的遍历 break; } // 显然，如果到了这一步，那么子元素的遍历仍将继续 } 当判断了指定的 View 可以接收触摸事件之后会调用 dispatchTransformedTouchEvent() 方法分发事件。其定义的节选如下： private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; // ... if (child == null) { // 本质上逻辑与 View 的 dispatchTouchEvent() 一致 handled = super.dispatchTouchEvent(transformedEvent); } else { // ... // 交给子元素继续分发事件 handled = child.dispatchTouchEvent(transformedEvent); } return handled; } dispatchTransformedTouchEvent() 会根据传入的 child 是否为 null 分成两种调用的情形：事件没有被拦截的时候，让子元素继续分发事件；另一种是当事件被拦截的时候，调用当前的 ViewGroup 的 super.dispatchTouchEvent(transformedEvent) 处理事件。 4.3.3 View 中的 dispatchTouchEvent上面我们分析的 dispatchTouchEvent(MotionEvent) 是 ViewGroup 中重写之后的方法。但是，正如我们上面的分析，重写之前的方法总是会被调用，只是对象不同。这里我们就来分析以下这个方法的作用。 public boolean dispatchTouchEvent(MotionEvent event) { // ... boolean result = false; // .... if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) { result = true; } // 这里回调了 setOnTouchListener() 方法传入的 OnTouchListener ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } // 如果 OnTouchListener 没有被回调过或者返回了 false，就会调用 onTouchEvent() 进行处理 if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } // ... return result; } 根据上面的源码分析，我们知道，如果当前的 View 设置过 OnTouchListener, 并且在 onTouch() 回调方法中返回了 true，那么 onTouchEvent(MotionEvent) 将不会得到调用。那么，我们再来看一下 onTouchEvent() 方法： public boolean onTouchEvent(MotionEvent event) { // ... // 判断当前控件是否是可以点击的：实现了点击、长按或者设置了可点击属性 final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; // ... if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) { switch (action) { case MotionEvent.ACTION_UP: // ... if (!focusTaken) { if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClick(); } } // ... break; case MotionEvent.ACTION_DOWN: // ... if (!clickable) { checkForLongClick(0, x, y); break; } // ... break; // ... } return true; } return false; } 这里先判断指定的控件是否是可点击的，即是否设置过点击或者长按的事件。然后会在手势抬起的时候调用 performClick() 方法，并会在这个方法中尝试从 ListenerInfo 取 OnClickListener 进行回调；会在长按的时候进行监听以调用相应长按事件；其他的事件与之类似，可以自行分析。所以，我们可以得出结论：当为控件的触摸事件进行了赋值并且在其中返回了 true 就代表该事件被消费了，即使设置过单击和长按事件也不会被回调，触摸事件的优先级比后面两者要高。 经过上述分析，我们可以知道 View 中的 dispatchTouchEvent(MotionEvent) 方法就是用来对手势进行处理的，所以回到 4.3.2，那里的意思就是：如果 ViewGroup 拦截了触摸事件，那么它就自己来对事件进行处理；否则就把触摸事件传递给子元素，让它来进行处理。 4.4.4 总结以上就是我们对 Android 中事件分发机制的详解，你可以通过图片和代码结合来更透彻得了解这方面的内容。虽然这部分代码比较多、比较长，但是每个地方的设计都是合情合理的。 源代码你可以在Github获取以上程序的源代码： Android-references。]]></content>
      <categories>
        <category>Android控件详解</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码阅读</tag>
        <tag>控件体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 体系详解：View 的工作流程]]></title>
    <url>%2F2018%2F10%2F14%2FView%20%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3%EF%BC%9AView%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、View 树的加载流程当我们调用 startActivity() 方法的时候，会调用到 ActivityThread 中的 performLaunchActivity() 获取一个 Activity 实例， 并在 Instrumentation 的 callActivityOnCreate() 方法中调用 Activity 的 onCreate() 完成 DecorView 的创建。这样我们就获取了一个 Activity 的实例，然后我们调用 handleResumeActivity() 来回调 Activity 的 onResume()： private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) { // .... WindowManagerGlobal.initialize(); // 创建 Activity 的实例，在这里完成对 Activity 的 onCreate() 方法的回调 Activity a = performLaunchActivity(r, customIntent); if (a != null) { // ... // 在这里回调 Activity 的 onResume() 方法 handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) { // 在这里完成对 Activity 的 onPause() 方法的回调 performPauseActivityIfNeeded(r, reason); // ... } } // ... } 然后，在 handleResumeActivity() 方法中的 performResumeActivity() 会回调 Activity 的 onResume() 方法。在该方法中，我们会从 Window 中获取之前添加进去的 DecorView，然后将其添加到 WindowManager 中： final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) { // 在这里会回调 Activity 的 onResume() r = performResumeActivity(token, clearHide, reason); if (r != null) { final Activity a = r.activity; // ... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) { r.window = r.activity.getWindow(); // 在这里获取 DecorView View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); // 获取 WindowManager 实例，实际是 WindowManagerImpl ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) { a.mWindowAdded = true; r.mPreserveWindow = false; // Activity 被重建，复用 DecorView，通知子元素 ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) { impl.notifyChildRebuilt(); } } if (a.mVisibleFromClient) { if (!a.mWindowAdded) { a.mWindowAdded = true; // 将 DecorView 添加到 WindowManager 中 wm.addView(decor, l); } else { a.onWindowAttributesChanged(l); } } } } } 这里的 WindowManager 是 WindowManagerImpl 的实例，而调用它的 addView() 方法的时候会使用 WindowManagerGlobal 的 addView() 方法。在该方法中会 new 出来一个 ViewRootImpl，然后调用它的 setView() 把传进来的 DecorView 添加到 Window 里。同时，会调用 requestLayout() 方法进行布局，然后，并最终调用 performTraversals() 完成对整个 View 树进行遍历： private void performTraversals() { // ... if (!mStopped || mReportNextDraw) { // ... performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); } // ... final boolean didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw); boolean triggerGlobalLayoutListener = didLayout || mAttachInfo.mRecomputeGlobalAttributes; if (didLayout) { performLayout(lp, mWidth, mHeight); // ... } // ... if (!cancelDraw &amp;&amp; !newSurface) { // ... performDraw(); } } 在该方法中会调用 performMeasure()、performLayout() 和 performDraw() 三个方法，它们分别会调用 DecorView 的 measure()、layout() 和 draw() 完成对整个 View 树的测量、布局和绘制，一个界面也就呈现给用户了。如果您做过自定义 View 的话，那么您对 onMeasure()、onLayout() 和 onDraw()三个方法一定不会陌生，前面的三个方法与后面的三个方法之间的关系就是：后面的三个方法会被前面的三个方法调用，本质上就是提供给用户用来自定义的方法。下面我们就看下这三个方法究竟各自做了什么操作，当然，我们尽可能从自定义控件的角度来分析，因为这对一个开发者可能帮助更大。 2、measure()View 的大小不仅由自身所决定，同时也会受到父控件的影响，为了我们的控件能更好的适应各种情况，一般会自己进行测量。在上面我们提到了 measure() 方法，它是用来测量 View 的大小的，但实际上测量的主要工作是交给 onMeasure() 方法的。在 View 中，onMeasure() 是一个 protected 的方法，显然它设计的目的就是：提供给子 View 按照父容器提供的限制条件，控制自身的大小，实现自己大小的测量逻辑。所以，当我们自定义一个控件的时候，只会去覆写 onMeasure() 而不去覆写 measure() 方法。 在 Android 中，我们的控件分成 View 和 ViewGroup 两种类型。根据上面的分析，对 View 的测量，我们可以得出如下结论：在 Android 中，ViewGroup 会根据其自身的布局特点，把限制条件封装成 widthMeasureSpec 和 heightMeasureSpec 两个参数传递给子元素；然后，在子元素中根据这两个参数来调整自身的大小。所以，ViewGroup 的 measure() 方法会根据其布局特性的不同而不同；而 View 的 measure()，不论其父容器是哪种类型，只根据 widthMeasureSpec 和 heightMeasureSpec 决定。 下面我们来看一下 onMeasure() 在 View 和 ViewGroup 中的不同表现形式。 2.1 View 的 onMeasure()下面是 View 类中的 onMeasure() 方法。这是一个默认的实现，调用了 setMeasuredDimension() 方法来存储测量之后的宽度和高度。当我们自定义 View 的时候，也需要调用 setMeasuredDimension() 方法把最终的测量结果存储起来： protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension( getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } 显然，我们的测量依据就是 widthMeasureSpec 和 heightMeasureSpec 两个参数。它们是整型的、32位变量，包含了测量模式和测量数值的信息（按位存储到整型变量上，包装成整型的目的是为了节约存储空间）。一般我们会像下面这样来分别获取高度和宽度的测量模式和测量数值（实际就是按位截取）： int widthsize = MeasureSpec.getSize(widthMeasureSpec); // 测量数值 int widthmode = MeasureSpec.getMode(widthMeasureSpec); // 测量模式 int heightsize = MeasureSpec.getSize(heightMeasureSpec); // 测量数值 int heightmode = MeasureSpec.getMode(heightMeasureSpec); // 测量模式 测量模式共有 MeasureSpec.UNSPECIFIED、MeasureSpec.AT_MOST 和 MeasureSpec.EXACTLY 三种，分别对应二进制数值 00、01 和 10，它们各自的含义如下： UNSPECIFIED：默认值，父控件没有给子 View 任何限制，子 View 可以设置为任意大小； EXACTLY：表示父控件已经确切的指定了子 View 的大小； AT_MOST：表示子 View 具体大小没有尺寸限制，但是存在上限，上限一般为父 View 大小。 这里，我不打算详细介绍 View 中默认测量逻辑的具体实现。它的大致逻辑是这样的：首先我们会用 getDefaultSize() 获取默认的宽度或者高度，这个方法接收两个参数，一个是默认的尺寸，一个测量模式。如果父控件没有给它任何限制，它就使用默认的尺寸，否则使用测量数值。这里的默认的尺寸通过 getSuggestedMinimumHeight()/getSuggestedMinimumWidth() 方法得到，它会根据背景图片高度/宽度和 mMinHeight/mMinWidth 的值，取一个最大的值作为控件的高度/宽度。 所以，View 的默认的测量逻辑的实际效果是：首先 View 的大小受父容器的影响，如果父容器没有给它限制的话，它会取背景图片和最小的高度或者宽度中取一个最大的值作为自己的大小。 2.2 ViewGroup 的 onMeasure()2.2.1 ViewGroup 中的方法由于 ViewGroup 本身没有布局的特点，所以它没有覆写 onMeasure()。有自身布局特点的，比如 LinearLayout 和 RelativeLayout 等都覆写并实现了这个方法。尽管如此，ViewGroup 提供了一些方法帮助我们进行测量，首先是 measureChildren() 方法： protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) { final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) { final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) { measureChild(child, widthMeasureSpec, heightMeasureSpec); } } } 这里的逻辑比较简单，就是对子元素进行遍历并判断如果指定的 View 是否位 GONE 的状态，如果不是就调用 measureChild() 方法： protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) { final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } 该方法也比较容易理解，就是将子元素的布局参数 LayoutParams 取出，获取它的宽度和高度之后，将所有信息传递给 getChildMeasureSpec()。这样就得到了用于子元素布局的 childWidthMeasureSpec 和 childHeightMeasureSpec 参数。然后，再调用子元素的 measure() 方法，从而依次完成对整个 View 树的遍历。下面我们看下 getChildMeasureSpec() 方法做了什么操作： public static int getChildMeasureSpec(int spec, int padding, int childDimension) { // 首先从 spec 中取出父控件的测量模式和测量数值 int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); // 这里需要保证 size 不能为负数，也就是预留给子元素的最大空间，由父元素的测量数值减去填充得到 int size = Math.max(0, specSize - padding); // 用于返回的值 int resultSize = 0; int resultMode = 0; // 根据父空间的测量模式 switch (specMode) { // 父控件的大小是固定的 case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) { // 子 View 指定了大小 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // 子元素希望大小与父控件相同（填满整个父控件） resultSize = size; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // 子元素希望有自己决定大小，但是不能比父控件大 resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // 父控件的具体大小没有尺寸限制，但是存在上限 case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) { // 子 View 指定了大小 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // 子控件希望与父控件大小一致，但是父控件的大小也是不确定的，故让子控件不要比父控件大 resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // 子控件希望自己决定大小，限制其不要比父控件大 resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // 父控件没有任何限制，可以设置为任意大小 case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) { // 子元素设置了大小 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // 子控件希望和父控件一样大，但是父控件多大都不确定；系统23以下返回true，以上返回size resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } else if (childDimension == LayoutParams.WRAP_CONTENT) { resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } break; } // 返回一个封装好的测量结果，就是把测量数值和测量模式封装成一个32位的整数 return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } 上面我们已经为这段代码作了非常详细的注释。只需要注意，这里在获取子元素的测量结果的时候是基于父控件的测量结果来的，需要根据父元素的测量模式和测量数值结合自身的布局特点分成上面九种情况。或者可以按照下面的写法将其划分成下面几种情况： public static int getChildMeasureSpec(int spec, int padding, int childDimension) { int specMode = MeasureSpec.getMode(spec), specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0, resultMode = 0; if (childDimension &gt;= 0) { // 子元素指定了具体的大小，就用子元素的大小 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == ViewGroup.LayoutParams.MATCH_PARENT) { // 子元素希望和父控件一样大，需要设置其上限，然后测量模式与父控件一致即可 if (specMode == MeasureSpec.EXACTLY || specMode == MeasureSpec.AT_MOST) { resultSize = size; resultMode = specMode; } else if (specMode == MeasureSpec.UNSPECIFIED) { // API23一下就是0，父控件没有指定大小的时候，子控件只能是0；以上是size resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } } else if (childDimension == ViewGroup.LayoutParams.WRAP_CONTENT) { // 子元素希望自己决定大小，设置其大小的上限是父控件的大小即可 if (specMode == MeasureSpec.EXACTLY || specMode == MeasureSpec.AT_MOST) { resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (specMode == MeasureSpec.UNSPECIFIED) { // API23一下就是0，父控件没有指定大小的时候，子控件只能是0；以上是size resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } } return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } 这两种方式只是划分的角度不一样，后面的这种方法是从子元素的布局参数上面来考虑的。另外，这里有个 sUseZeroUnspecifiedMeasureSpec 布尔参数需要提及一下，会根据系统的版本来进行赋值： sUseZeroUnspecifiedMeasureSpec = targetSdkVersion &lt; Build.VERSION_CODES.M; 也就是当系统是 API23 以下的时候的为 true. 加入这个参数的原因是，API23 之后，当父控件的测量模式是 UNSPECIFIED 的时候，子元素可以给父控件提供一个可能的大小。下面是注释的原话 ;-) // In M and newer, our widgets can pass a &quot;hint&quot; value in the size // for UNSPECIFIED MeasureSpecs. This lets child views of scrolling containers // know what the expected parent size is going to be, so e.g. list items can size // themselves at 1/3 the size of their container. It breaks older apps though, // specifically apps that use some popular open source libraries. 2.2.2 LinearLayout 的 onMeasure()上面我们分析的是 ViewGroup 中提供的一些方法，下面我们以 LinearLayout 为例，看一下一个标准的容器类型的控件是如何实现其测量的逻辑的。 下面是其 onMeasure() 方法，显然在进行测量的时候会根据其布局的方向分别实现测量的逻辑： protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { if (mOrientation == VERTICAL) { measureVertical(widthMeasureSpec, heightMeasureSpec); } else { measureHorizontal(widthMeasureSpec, heightMeasureSpec); } } 然后，我们以 measureVertical() 为例，来看一下 LinearLayout 在垂直方向上面是如何进行测量的。这段代码比较长，我们只截取其中的一部分来进行分析： void measureVertical(int widthMeasureSpec, int heightMeasureSpec) { // ... // 获取LinearLayout的测量模式 final int widthMode = MeasureSpec.getMode(widthMeasureSpec); final int heightMode = MeasureSpec.getMode(heightMeasureSpec); // ... mTotalLength += mPaddingTop + mPaddingBottom; int heightSize = mTotalLength; heightSize = Math.max(heightSize, getSuggestedMinimumHeight()); // ... for (int i = 0; i &lt; count; ++i) { final View child = getVirtualChildAt(i); if (child == null || child.getVisibility() == View.GONE) { continue; } final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final float childWeight = lp.weight; if (childWeight &gt; 0) { // ... // 获取一个测量的数值和测量模式 final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( Math.max(0, childHeight), MeasureSpec.EXACTLY); final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width); // 调用子元素进行测量 child.measure(childWidthMeasureSpec, childHeightMeasureSpec); childState = combineMeasuredStates(childState, child.getMeasuredState() &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT)); } final int margin = lp.leftMargin + lp.rightMargin; final int measuredWidth = child.getMeasuredWidth() + margin; maxWidth = Math.max(maxWidth, measuredWidth); boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT; alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth); allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT; final int totalLength = mTotalLength; // 将宽度增加到 mTotalLength 上 mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child)); } mTotalLength += mPaddingTop + mPaddingBottom; // ... maxWidth += mPaddingLeft + mPaddingRight; maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); // 最终确定测量的大小 setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState); // ... } 上面是 LinearLayout 在垂直方向上面的测量的过程，在测量的时候会根据子元素的布局将子元素的测量高度添加到 mTotalLength 上，然后再加上填充的大小，作为最终的测量结果。 3、layout() layout() 用于确定控件的位置，它提供了 onLayout() 来交给字类实现，同样我们在自定义控件的时候只要实现 onLayout() 方法即可。在我们自定义 View 的时候，如果定义的是非 ViewGroup 类型的控件，一般是不需要覆写 onLayout() 方法的。 下面我们先看一下 layout() 方法在 View 中的实现： public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { onLayout(changed, l, t, r, b); // ... } // ... } 这里会调用 setFrame() 方法，它的主要作用是根据新的布局参数和老的布局参数做一个对比，以判断控件的大小是否发生了变化，如果变化了的话就调用 invalidate() 方法并传入参数 true，以表明绘图的缓存也发生了变化。这里就不给出这个方法的具体实现了。然后注意到，在 layout() 方法中会回调 onLayout() 方法来完成各个控件的位置的确定。 对于 ViewGroup，它重写了 layout() 并在其中调用了 View 中的 layout() 方法，不过整体并没有做太多的逻辑。与测量过程类似，ViewGroup 并没有实现 onLayout 方法。同样，对于 ViewGroup 类型的控件，我们还是以 LinearLayout 为例说明一下 onLayout() 的实现逻辑： 与测量过程类似，LinearLayout 在 layout 的时候也根据布局的方向分成两种情形： protected void onLayout(boolean changed, int l, int t, int r, int b) { if (mOrientation == VERTICAL) { layoutVertical(l, t, r, b); } else { layoutHorizontal(l, t, r, b); } } 这里我们仍以垂直方向的方法为例。与测量的过程相比，layout 的过程的显得简单、清晰得多： void layoutVertical(int left, int top, int right, int bottom) { // ... // 根据控件的 gravity 特点得到顶部的位置 switch (majorGravity) { case Gravity.BOTTOM: childTop = mPaddingTop + bottom - top - mTotalLength; break; case Gravity.CENTER_VERTICAL: childTop = mPaddingTop + (bottom - top - mTotalLength) / 2; break; case Gravity.TOP: default: childTop = mPaddingTop; break; } // 遍历子控件 for (int i = 0; i &lt; count; i++) { final View child = getVirtualChildAt(i); if (child == null) { childTop += measureNullChild(i); } else if (child.getVisibility() != GONE) { final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); int gravity = lp.gravity; if (gravity &lt; 0) { gravity = minorGravity; } final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); // 得到子控件的左边的位置 switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) { case Gravity.CENTER_HORIZONTAL: childLeft = paddingLeft + ((childSpace - childWidth) / 2) + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: childLeft = childRight - childWidth - lp.rightMargin; break; case Gravity.LEFT: default: childLeft = paddingLeft + lp.leftMargin; break; } if (hasDividerBeforeChildAt(i)) { childTop += mDividerHeight; } childTop += lp.topMargin; // 本质上调用子控件的 layout() 方法 setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child, i); } } } 因为布局方向是垂直方向的，所以在对子元素进行遍历之前，先对自身的顶部的位置进行计算，然后再依次遍历子元素，并对顶部的高度不断叠加，最后调用 setChildFrame() 方法: private void setChildFrame(View child, int left, int top, int width, int height) { child.layout(left, top, left + width, top + height); } 这样就完成了对整个 View 树的 layout() 方法的调用。 4、draw()View 的 draw() 方法实现的逻辑也很清晰。在绘制的过程会按照如下的步骤进行： 绘制背景 保存 canvas 绘制自身的内容 绘制子控件 绘制 View 的褪色边缘，比如阴影效果之类的 绘制装饰，比如滚动条之类的 View 中提供了 onDraw() 方法用来完成对自身的内容的绘制，所以，我们自定义 View 的时候只要重写这个方法就可以了。当我们要自定义一个 ViewGroup 类型的控件的时候，一般是不需要重写 onDraw() 方法的，因为它只需要遍历子控件并依次调用它们的 draw() 方法就可以了。（当然，如果非要实现的话，也是可以的。） 下面是这部分代码，代码的注释中也详细注释了每个步骤的逻辑： public void draw(Canvas canvas) { final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) { drawBackground(canvas); } // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) { // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); drawAutofilledHighlight(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) { mOverlay.getOverlayView().dispatchDraw(canvas); } // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // Step 7, draw the default focus highlight drawDefaultFocusHighlight(canvas); if (debugDraw()) { debugDrawFocus(canvas); } // we&apos;re done... return; } // ... } 注意到在上面的方法中会调用 dispatchDraw(canvas) 方法来分发绘制事件给子控件来完成整个 View 树的绘制。在 View 中，这是一个空的方法，ViewGroup 覆写了这个方法，并在其中调用 drawChild() 来完成对指定的 View 的 draw() 方法的调用： protected boolean drawChild(Canvas canvas, View child, long drawingTime) { return child.draw(canvas, this, drawingTime); } 而对于 LinearLayout 这样本身没有绘制需求的控件，没有覆写 onDraw() 和 dispatchDraw(canvas) 等方法，因为 View 和 ViewGroup 中提供的功能已经足够使用。 总结：上文中，我们介绍了在 Android 系统中整个 View 树的工作的流程，从 DecorView 被加载到窗口中，到测量、布局和绘制三个方法的实现。本质上整个工作的流程就是对 View 树的一个深度优先的遍历过程。]]></content>
      <categories>
        <category>Android控件详解</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码阅读</tag>
        <tag>控件体系</tag>
      </tags>
  </entry>
</search>
